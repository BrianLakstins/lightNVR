{"version":3,"file":"TimelineView-BdrzusIU.js","sources":["../../js/components/preact/timeline/TimelineControls.js","../../js/components/preact/timeline/TimelineRuler.js","../../js/components/preact/timeline/TimelineSegments.js","../../js/components/preact/timeline/TimelineCursor.js","../../js/components/preact/timeline/SpeedControls.js","../../js/components/preact/timeline/TimelinePlayer.js","../../js/components/preact/timeline/TimelinePage.js","../../js/components/preact/timeline/TimelineView.js"],"sourcesContent":["/**\n * LightNVR Timeline Controls Component\n * Handles play/pause and zoom controls for the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelineControls component\n * @returns {JSX.Element} TimelineControls component\n */\nexport function TimelineControls() {\n  // Local state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineControls: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineControls: Received state update:', state);\n      console.log('TimelineControls: Is playing:', state.isPlaying);\n      console.log('TimelineControls: Zoom level:', state.zoomLevel);\n      console.log('TimelineControls: Segments count:', state.timelineSegments?.length || 0);\n      \n      setIsPlaying(state.isPlaying);\n      setZoomLevel(state.zoomLevel);\n    });\n    \n    // Log initial state\n    console.log('TimelineControls: Initial timelineState:', timelineState);\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Toggle playback (play/pause)\n  const togglePlayback = () => {\n    if (isPlaying) {\n      pausePlayback();\n    } else {\n      resumePlayback();\n    }\n  };\n\n  // Pause playback\n  const pausePlayback = () => {\n    timelineState.setState({ isPlaying: false });\n    \n    // If there's a video player, pause it\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      videoPlayer.pause();\n    }\n  };\n\n  // Resume playback\n  const resumePlayback = () => {\n    // If no segments, show message and return\n    if (!timelineState.timelineSegments || timelineState.timelineSegments.length === 0) {\n      showStatusMessage('No recordings to play', 'warning');\n      return;\n    }\n    \n    // Find the earliest segment in the timeline\n    let earliestSegmentIndex = 0;\n    let earliestTimestamp = Number.MAX_SAFE_INTEGER;\n    \n    timelineState.timelineSegments.forEach((segment, index) => {\n      if (segment.start_timestamp < earliestTimestamp) {\n        earliestTimestamp = segment.start_timestamp;\n        earliestSegmentIndex = index;\n      }\n    });\n    \n    console.log(`Starting from earliest segment (index ${earliestSegmentIndex})`);\n    \n    // Start playing from the earliest segment\n    timelineState.setState({ \n      currentSegmentIndex: earliestSegmentIndex,\n      currentTime: timelineState.timelineSegments[earliestSegmentIndex].start_timestamp,\n      isPlaying: true,\n      forceReload: true // Force reload to ensure video player updates\n    });\n    \n    // Force load the earliest segment's video\n    const segment = timelineState.timelineSegments[earliestSegmentIndex];\n    const videoPlayer = document.querySelector('#video-player video');\n    \n    if (videoPlayer) {\n      console.log('Loading earliest segment video:', segment);\n      \n      // Pause any current playback\n      videoPlayer.pause();\n      \n      // Clear the source and reload\n      videoPlayer.removeAttribute('src');\n      videoPlayer.load();\n      \n      // Set the new source with a timestamp to prevent caching\n      videoPlayer.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n      \n      // Set the current time and play\n      videoPlayer.onloadedmetadata = () => {\n        videoPlayer.currentTime = 0;\n        videoPlayer.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      };\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index) => {\n    // This function will be implemented in the TimelinePlayer component\n    // Here we just update the state\n    timelineState.setState({ \n      currentSegmentIndex: index,\n      isPlaying: true \n    });\n  };\n\n  // Zoom in on timeline\n  const zoomIn = () => {\n    if (zoomLevel < 8) {\n      const newZoomLevel = zoomLevel * 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed in: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  // Zoom out on timeline\n  const zoomOut = () => {\n    if (zoomLevel > 1) {\n      const newZoomLevel = zoomLevel / 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed out: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  return html`\n    <div class=\"timeline-controls flex justify-between items-center mb-2\">\n      <div class=\"flex items-center\">\n        <button \n          id=\"play-button\" \n          class=\"w-10 h-10 rounded-full bg-green-600 hover:bg-green-700 text-white flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-offset-1 transition-colors shadow-sm mr-2\"\n          onClick=${togglePlayback}\n          title=${isPlaying ? 'Pause' : 'Play from earliest recording'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            ${isPlaying \n              ? html`\n                <!-- Pause icon - two vertical bars -->\n                <rect x=\"6\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n                <rect x=\"14\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n              `\n              : html`\n                <!-- Play icon - triangle -->\n                <path d=\"M8 5.14v14l11-7-11-7z\" fill=\"white\" />\n              `\n            }\n          </svg>\n        </button>\n        <span class=\"text-xs text-gray-600 dark:text-gray-300\">Play from earliest recording</span>\n      </div>\n      \n      <div class=\"flex items-center gap-1\">\n        <span class=\"text-xs text-gray-600 dark:text-gray-300 mr-1\">Zoom:</span>\n        <button \n          id=\"zoom-out-button\" \n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomOut}\n          title=\"Zoom Out (Show more time)\"\n          disabled=${zoomLevel <= 1}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n        <button \n          id=\"zoom-in-button\" \n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomIn}\n          title=\"Zoom In (Show less time)\"\n          disabled=${zoomLevel >= 8}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Ruler Component\n * Displays the time ruler with hour markers\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineRuler component\n * @returns {JSX.Element} TimelineRuler component\n */\nexport function TimelineRuler() {\n  // Local state\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineRuler: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineRuler: Received state update:', state);\n      console.log('TimelineRuler: Zoom level:', state.zoomLevel);\n      \n      // Calculate time range based on zoom level\n      const hoursPerView = 24 / state.zoomLevel;\n      console.log('TimelineRuler: Hours per view:', hoursPerView);\n      \n      // Calculate the center hour based on current time or segments\n      let centerHour = 12; // Default to noon\n      \n      if (state.currentTime !== null) {\n        // If we have a current time, use it as the center\n        const currentDate = new Date(state.currentTime * 1000);\n        centerHour = currentDate.getHours() + (currentDate.getMinutes() / 60) + (currentDate.getSeconds() / 3600);\n      } else if (state.timelineSegments && state.timelineSegments.length > 0) {\n        // If we have segments but no current time, use the middle of the segments\n        let earliestHour = 24;\n        let latestHour = 0;\n        \n        state.timelineSegments.forEach(segment => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n          \n          const startHour = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n          const endHour = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n          \n          earliestHour = Math.min(earliestHour, startHour);\n          latestHour = Math.max(latestHour, endHour);\n        });\n        \n        centerHour = (earliestHour + latestHour) / 2;\n      }\n      \n      // Calculate start and end hours based on center and zoom level\n      let newStartHour = Math.max(0, centerHour - (hoursPerView / 2));\n      let newEndHour = Math.min(24, newStartHour + hoursPerView);\n      \n      // Adjust start hour if end hour is at the limit\n      if (newEndHour === 24 && hoursPerView < 24) {\n        newStartHour = Math.max(0, 24 - hoursPerView);\n        newEndHour = 24;\n      } else if (newStartHour === 0 && hoursPerView < 24) {\n        newEndHour = Math.min(24, hoursPerView);\n      }\n      \n      console.log('TimelineRuler: New hour range:', { newStartHour, newEndHour });\n      \n      // Update local state\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setZoomLevel(state.zoomLevel);\n      \n      // Only update global state if the values have actually changed\n      // to prevent infinite recursion\n      if (timelineState.timelineStartHour !== newStartHour || \n          timelineState.timelineEndHour !== newEndHour) {\n        timelineState.setState({\n          timelineStartHour: newStartHour,\n          timelineEndHour: newEndHour\n        });\n      }\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Generate hour markers and labels\n  const generateHourMarkers = () => {\n    const markers = [];\n    const hourWidth = 100 / (endHour - startHour);\n    \n    // Add hour markers and labels\n    for (let hour = Math.floor(startHour); hour <= Math.ceil(endHour); hour++) {\n      if (hour >= 0 && hour <= 24) {\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        \n        // Add hour marker\n        markers.push(html`\n          <div \n            key=\"tick-${hour}\" \n            class=\"absolute top-0 w-px h-5 bg-gray-500 dark:bg-gray-400\" \n            style=\"left: ${position}%;\"\n          ></div>\n        `);\n        \n        // Add hour label\n        markers.push(html`\n          <div \n            key=\"label-${hour}\" \n            class=\"absolute top-0 text-xs text-gray-600 dark:text-gray-300 transform -translate-x-1/2\" \n            style=\"left: ${position}%;\"\n          >\n            ${hour}:00\n          </div>\n        `);\n        \n        // Add half-hour marker if not the last hour and we're zoomed in enough\n        if (hour < 24 && zoomLevel >= 2) {\n          const halfHourPosition = ((hour + 0.5 - startHour) / (endHour - startHour)) * 100;\n          markers.push(html`\n            <div \n              key=\"tick-${hour}-30\" \n              class=\"absolute top-2 w-px h-3 bg-gray-400 dark:bg-gray-500\" \n              style=\"left: ${halfHourPosition}%;\"\n            ></div>\n          `);\n          \n          // Add 15-minute markers if zoomed in even more\n          if (zoomLevel >= 4) {\n            const quarterHourPosition1 = ((hour + 0.25 - startHour) / (endHour - startHour)) * 100;\n            const quarterHourPosition3 = ((hour + 0.75 - startHour) / (endHour - startHour)) * 100;\n            \n            markers.push(html`\n              <div \n                key=\"tick-${hour}-15\" \n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\" \n                style=\"left: ${quarterHourPosition1}%;\"\n              ></div>\n            `);\n            \n            markers.push(html`\n              <div \n                key=\"tick-${hour}-45\" \n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\" \n                style=\"left: ${quarterHourPosition3}%;\"\n              ></div>\n            `);\n          }\n        }\n      }\n    }\n    \n    return markers;\n  };\n\n  return html`\n    <div class=\"timeline-ruler relative w-full h-8 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-600\">\n      ${generateHourMarkers()}\n      <div class=\"absolute bottom-0 left-0 text-xs text-gray-500 px-1\">\n        Zoom: ${zoomLevel}x (${Math.round(24 / zoomLevel)} hours)\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Segments Component\n * Displays recording segments on the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelineSegments component\n * @returns {JSX.Element} TimelineSegments component\n */\nexport function TimelineSegments() {\n  // Local state\n  const [segments, setSegments] = useState([]);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  \n  // Refs\n  const containerRef = useRef(null);\n  const isDragging = useRef(false);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineSegments: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineSegments: Received state update');\n      \n      // Update segments\n      if (state.timelineSegments) {\n        console.log(`TimelineSegments: Updating segments (${state.timelineSegments.length})`);\n        setSegments(state.timelineSegments);\n      }\n      \n      // Update other state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n      setCurrentSegmentIndex(state.currentSegmentIndex || -1);\n    });\n    \n    // Check if we already have segments in the timelineState\n    if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n      console.log(`TimelineSegments: Initial segments available (${timelineState.timelineSegments.length})`);\n      setSegments(timelineState.timelineSegments);\n      setCurrentSegmentIndex(timelineState.currentSegmentIndex || 0);\n    }\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set up drag handling\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    \n    const handleMouseDown = (e) => {\n      // Only handle clicks on the container itself, not on segments\n      if (e.target === container || e.target.classList.contains('timeline-clickable-area')) {\n        isDragging.current = true;\n        handleTimelineClick(e);\n        \n        // Add event listeners for drag\n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n      }\n    };\n    \n    const handleMouseMove = (e) => {\n      if (!isDragging.current) return;\n      handleTimelineClick(e);\n    };\n    \n    const handleMouseUp = () => {\n      isDragging.current = false;\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n    \n    container.addEventListener('mousedown', handleMouseDown);\n    \n    return () => {\n      container.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [startHour, endHour, segments]);\n\n  // Handle click on timeline for seeking\n  const handleTimelineClick = (event) => {\n    const container = containerRef.current;\n    if (!container) return;\n    \n    // Get click position relative to container\n    const rect = container.getBoundingClientRect();\n    const clickX = event.clientX - rect.left;\n    const containerWidth = rect.width;\n    \n    // Calculate time based on click position\n    const clickPercent = clickX / containerWidth;\n    const clickHour = startHour + (clickPercent * (endHour - startHour));\n    \n    // Find the segment that contains this time\n    const clickDate = new Date(timelineState.selectedDate);\n    clickDate.setHours(Math.floor(clickHour));\n    clickDate.setMinutes(Math.floor((clickHour % 1) * 60));\n    clickDate.setSeconds(Math.floor(((clickHour % 1) * 60) % 1 * 60));\n    \n    const clickTimestamp = clickDate.getTime() / 1000;\n    \n    // Find segment that contains this timestamp\n    let foundSegment = false;\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      if (clickTimestamp >= segment.start_timestamp && clickTimestamp <= segment.end_timestamp) {\n        console.log(`TimelineSegments: Found segment ${i} containing timestamp`);\n        \n        // Calculate relative time within the segment\n        const relativeTime = clickTimestamp - segment.start_timestamp;\n        \n        // Update current segment index\n        setCurrentSegmentIndex(i);\n        \n        // Play this segment starting at the clicked time\n        playSegment(i, relativeTime);\n        foundSegment = true;\n        break;\n      }\n    }\n    \n    if (!foundSegment) {\n      if (segments.length > 0) {\n        console.log('TimelineSegments: No segment contains the timestamp, finding closest segment');\n        // Find the closest segment\n        let closestSegment = -1;\n        let minDistance = Infinity;\n        \n        for (let i = 0; i < segments.length; i++) {\n          const segment = segments[i];\n          const startDistance = Math.abs(segment.start_timestamp - clickTimestamp);\n          const endDistance = Math.abs(segment.end_timestamp - clickTimestamp);\n          const distance = Math.min(startDistance, endDistance);\n          \n          if (distance < minDistance) {\n            minDistance = distance;\n            closestSegment = i;\n          }\n        }\n        \n        if (closestSegment >= 0) {\n          console.log(`TimelineSegments: Playing closest segment ${closestSegment}`);\n          \n          // Play the closest segment\n          playSegment(closestSegment);\n        }\n      } else {\n        // No segments found, just update the currentTime\n        console.log('TimelineSegments: No segments found, just updating currentTime');\n        timelineState.setState({ \n          currentTime: clickTimestamp,\n          prevCurrentTime: timelineState.currentTime\n        });\n      }\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index, relativeTime = null) => {\n    console.log(`TimelineSegments: playSegment(${index}, ${relativeTime})`);\n    \n    if (index < 0 || index >= segments.length) {\n      console.warn(`TimelineSegments: Invalid segment index: ${index}`);\n      return;\n    }\n    \n    const segment = segments[index];\n    \n    // Calculate absolute timestamp for currentTime\n    const absoluteTime = relativeTime !== null \n      ? segment.start_timestamp + relativeTime \n      : segment.start_timestamp;\n    \n    // First, pause any current playback and reset the segment index\n    timelineState.setState({ \n      isPlaying: false,\n      currentSegmentIndex: -1\n    });\n    \n    // Force a synchronous DOM update\n    document.body.offsetHeight;\n    \n    // Now set the new segment index and start playing\n    setTimeout(() => {\n      timelineState.setState({ \n        currentSegmentIndex: index,\n        currentTime: absoluteTime,\n        isPlaying: true,\n        forceReload: true\n      });\n      \n      // Force the video player to reload\n      setTimeout(() => {\n        const videoElement = document.querySelector('#video-player video');\n        if (videoElement) {\n          // Pause any current playback\n          videoElement.pause();\n          \n          // Clear the source and reload\n          videoElement.removeAttribute('src');\n          videoElement.load();\n          \n          // Set the new source\n          videoElement.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n          \n          // Set the current time and play\n          videoElement.onloadedmetadata = () => {\n            const seekTime = relativeTime !== null ? relativeTime : 0;\n            videoElement.currentTime = seekTime;\n            videoElement.play().catch(e => console.error('Error playing video:', e));\n          };\n        }\n      }, 50);\n    }, 50);\n  };\n\n  // Render segments\n  const renderSegments = () => {\n    console.log(`TimelineSegments: Rendering ${segments.length} segments`);\n    \n    if (!segments || segments.length === 0) {\n      return null;\n    }\n    \n    const visibleSegments = [];\n    const hourMap = new Map();\n    \n    // First pass: collect all segments by hour\n    segments.forEach((segment, index) => {\n      // Convert timestamps to Date objects\n      const startTime = new Date(segment.start_timestamp * 1000);\n      const endTime = new Date(segment.end_timestamp * 1000);\n      \n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n      \n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n      \n      // Mark each hour that this segment spans\n      const startFloorHour = Math.floor(startHourFloat);\n      const endCeilHour = Math.min(Math.ceil(endHourFloat), 24);\n      \n      for (let h = startFloorHour; h < endCeilHour; h++) {\n        if (h >= startHour && h <= endHour) {\n          if (!hourMap.has(h)) {\n            hourMap.set(h, []);\n          }\n          hourMap.get(h).push(index);\n        }\n      }\n    });\n    \n    // Preprocess segments to merge adjacent ones\n    const mergedSegments = [];\n    let currentMergedSegment = null;\n    \n    // Sort segments by start time\n    const sortedSegments = [...segments].sort((a, b) => a.start_timestamp - b.start_timestamp);\n    \n    // Merge adjacent segments (no gap or very small gap)\n    sortedSegments.forEach((segment, index) => {\n      if (!currentMergedSegment) {\n        // First segment\n        currentMergedSegment = { ...segment, originalIndices: [index] };\n      } else {\n        // Check if this segment is adjacent to the current merged segment\n        // Allow a small gap (1 second) to account for rounding errors\n        const gap = segment.start_timestamp - currentMergedSegment.end_timestamp;\n        \n        if (gap <= 1) {\n          // Merge with current segment\n          currentMergedSegment.end_timestamp = segment.end_timestamp;\n          currentMergedSegment.originalIndices.push(index);\n          \n          // If this segment has detection, mark the merged segment as having detection\n          if (segment.has_detection) {\n            currentMergedSegment.has_detection = true;\n          }\n        } else {\n          // Gap is too large, start a new merged segment\n          mergedSegments.push(currentMergedSegment);\n          currentMergedSegment = { ...segment, originalIndices: [index] };\n        }\n      }\n    });\n    \n    // Add the last merged segment\n    if (currentMergedSegment) {\n      mergedSegments.push(currentMergedSegment);\n    }\n    \n    console.log(`TimelineSegments: Merged ${segments.length} segments into ${mergedSegments.length} segments`);\n    \n    // Second pass: add visible segments\n    mergedSegments.forEach((segment, mergedIndex) => {\n      // Convert timestamps to Date objects\n      const startTime = new Date(segment.start_timestamp * 1000);\n      const endTime = new Date(segment.end_timestamp * 1000);\n      \n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n      \n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n      \n      // Adjust start and end to fit within visible range\n      const visibleStartHour = Math.max(startHourFloat, startHour);\n      const visibleEndHour = Math.min(endHourFloat, endHour);\n      \n      // Calculate position and width as percentages\n      const startPercent = ((visibleStartHour - startHour) / (endHour - startHour)) * 100;\n      const widthPercent = ((visibleEndHour - visibleStartHour) / (endHour - startHour)) * 100;\n      \n      // Format duration for tooltip\n      const duration = Math.round(segment.end_timestamp - segment.start_timestamp);\n      const durationStr = `${duration}s`;\n      \n      // Format times for tooltip\n      const startTimeStr = startTime.toLocaleTimeString();\n      const endTimeStr = endTime.toLocaleTimeString();\n      \n      // Use a consistent height for all segments\n      const heightPercent = 80; // 80% height for all segments\n      \n      visibleSegments.push(html`\n        <div \n          key=\"segment-${mergedIndex}\"\n          class=\"timeline-segment absolute rounded-sm transition-all duration-200 ${segment.has_detection ? 'bg-red-500' : 'bg-blue-500'}\"\n          style=\"left: ${startPercent}%; width: ${widthPercent}%; height: ${heightPercent}%; top: 50%; transform: translateY(-50%);\"\n          title=\"${startTimeStr} - ${endTimeStr} (${durationStr})\"\n        ></div>\n      `);\n    });\n    \n    // Third pass: fill in gaps with clickable areas\n    for (let hour = Math.floor(startHour); hour < Math.ceil(endHour); hour++) {\n      if (!hourMap.has(hour)) {\n        // No segments in this hour, create a clickable area\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        const width = 100 / (endHour - startHour);\n        \n        visibleSegments.push(html`\n          <div \n            key=\"clickable-${hour}\"\n            class=\"timeline-clickable-area absolute h-full cursor-pointer\"\n            style=\"left: ${position}%; width: ${width}%;\"\n            data-hour=${hour}\n          ></div>\n        `);\n      }\n    }\n    \n    return visibleSegments;\n  };\n\n  return html`\n    <div \n      class=\"timeline-segments relative w-full h-16 pt-2\"\n      ref=${containerRef}\n    >\n      ${renderSegments()}\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Cursor Component\n * Displays the playback cursor on the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineCursor component\n * @returns {JSX.Element} TimelineCursor component\n */\nexport function TimelineCursor() {\n  // Local state\n  const [position, setPosition] = useState(0);\n  const [visible, setVisible] = useState(false);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentTime, setCurrentTime] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n  \n  // Refs\n  const cursorRef = useRef(null);\n  const containerRef = useRef(null);\n  const dragStartXRef = useRef(0);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n      setCurrentTime(state.currentTime);\n      \n      // Update time display\n      updateTimeDisplay(state.currentTime);\n      \n      // Update cursor position (only if not dragging)\n      if (!isDragging) {\n        updateCursorPosition(state.currentTime, state.timelineStartHour || 0, state.timelineEndHour || 24);\n      }\n    });\n    \n    return () => unsubscribe();\n  }, [isDragging]);\n\n  // Set up drag handling\n  useEffect(() => {\n    const cursor = cursorRef.current;\n    if (!cursor) return;\n    \n    const handleMouseDown = (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      // Store the starting X position\n      dragStartXRef.current = e.clientX;\n      \n      setIsDragging(true);\n      \n      // Add event listeners for drag\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    };\n    \n    const handleMouseMove = (e) => {\n      if (!isDragging) return;\n      \n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n      \n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n      \n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      setPosition(positionPercent);\n      \n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      \n      // Convert hour to timestamp\n      const date = new Date(timelineState.selectedDate);\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      \n      const timestamp = date.getTime() / 1000;\n      \n      // Update time display\n      updateTimeDisplay(timestamp);\n    };\n    \n    const handleMouseUp = (e) => {\n      if (!isDragging) return;\n      \n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n      \n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n      \n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      \n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      \n      // Convert hour to timestamp\n      const date = new Date(timelineState.selectedDate);\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      \n      const timestamp = date.getTime() / 1000;\n      \n      // Reset dragging state FIRST\n      setIsDragging(false);\n      \n      // Remove event listeners\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      \n      // Find segment that contains this timestamp\n      const segments = timelineState.timelineSegments || [];\n      let foundSegment = false;\n      \n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (timestamp >= segment.start_timestamp && timestamp <= segment.end_timestamp) {\n          // Calculate relative time within the segment\n          const relativeTime = timestamp - segment.start_timestamp;\n          \n          // Update timeline state\n          timelineState.setState({ \n            currentSegmentIndex: i,\n            currentTime: timestamp,\n            prevCurrentTime: timelineState.currentTime,\n            isPlaying: true\n          });\n          \n          foundSegment = true;\n          break;\n        }\n      }\n      \n      // If no segment found, find the closest one\n      if (!foundSegment && segments.length > 0) {\n        let closestSegment = 0;\n        let minDistance = Infinity;\n        \n        for (let i = 0; i < segments.length; i++) {\n          const segment = segments[i];\n          const startDistance = Math.abs(segment.start_timestamp - timestamp);\n          const endDistance = Math.abs(segment.end_timestamp - timestamp);\n          const distance = Math.min(startDistance, endDistance);\n          \n          if (distance < minDistance) {\n            minDistance = distance;\n            closestSegment = i;\n          }\n        }\n        \n        // Update timeline state\n        timelineState.setState({ \n          currentSegmentIndex: closestSegment,\n          currentTime: segments[closestSegment].start_timestamp,\n          prevCurrentTime: timelineState.currentTime,\n          isPlaying: true\n        });\n      }\n    };\n    \n    // Add event listeners\n    cursor.addEventListener('mousedown', handleMouseDown);\n    \n    return () => {\n      cursor.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [cursorRef.current, startHour, endHour, isDragging]);\n\n  // Update cursor position\n  const updateCursorPosition = (time, startHr, endHr) => {\n    if (time === null) {\n      setVisible(false);\n      return;\n    }\n    \n    // Calculate cursor position\n    const date = new Date(time * 1000);\n    const hour = date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n    \n    // Check if the current time is within the visible range\n    if (hour < startHr || hour > endHr) {\n      setVisible(false);\n      return;\n    }\n    \n    // Calculate position as percentage\n    const position = ((hour - startHr) / (endHr - startHr)) * 100;\n    \n    // Update cursor position\n    setPosition(position);\n    setVisible(true);\n  };\n\n  // Update time display\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  // Force the cursor to be visible on initial render\n  useEffect(() => {\n    // Set visible to true after a short delay\n    setTimeout(() => {\n      if (timelineState.currentTime) {\n        setVisible(true);\n        updateCursorPosition(\n          timelineState.currentTime, \n          timelineState.timelineStartHour || 0, \n          timelineState.timelineEndHour || 24\n        );\n      }\n    }, 500);\n  }, []);\n\n  return html`\n    <div \n      ref=${cursorRef}\n      class=\"timeline-cursor absolute top-0 h-full z-50 transition-all duration-100 cursor-ew-resize\"\n      style=\"left: ${position}%; display: ${visible ? 'block' : 'none'}; pointer-events: auto; width: 7px; margin-left: -3.5px;\"\n    >\n      <!-- Invisible wider clickable area -->\n      <div class=\"absolute top-0 bottom-0 left-0 w-full\"></div>\n      \n      <!-- Skinnier needle with no middle chunk -->\n      <div class=\"absolute top-0 bottom-0 w-0.5 bg-orange-500 left-1/2 transform -translate-x-1/2 pointer-events-none\"></div>\n      \n      <!-- Top handle (black) -->\n      <div class=\"absolute top-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 -translate-y-1/2 shadow-md pointer-events-none\"></div>\n      \n      <!-- Bottom handle (black) -->\n      <div class=\"absolute bottom-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 translate-y-1/2 shadow-md pointer-events-none\"></div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Speed Controls Component\n * Handles playback speed controls for the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * SpeedControls component\n * @returns {JSX.Element} SpeedControls component\n */\nexport function SpeedControls() {\n  // Local state\n  const [currentSpeed, setCurrentSpeed] = useState(1.0);\n  \n  // Available speeds\n  const speeds = [0.25, 0.5, 1.0, 1.5, 2.0, 4.0];\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('SpeedControls: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('SpeedControls: Received state update:', state);\n      console.log('SpeedControls: Playback speed:', state.playbackSpeed);\n      \n      setCurrentSpeed(state.playbackSpeed);\n    });\n    \n    // Log initial state\n    console.log('SpeedControls: Initial timelineState:', timelineState);\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set playback speed\n  const setPlaybackSpeed = (speed) => {\n    // Update video playback rate\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      // Store the current playback rate for debugging\n      const oldRate = videoPlayer.playbackRate;\n      \n      // Set the new playback rate\n      videoPlayer.playbackRate = speed;\n      \n      console.log(`Setting video playback rate from ${oldRate}x to ${speed}x`, videoPlayer);\n      console.log(`Actual playback rate after setting: ${videoPlayer.playbackRate}x`);\n      \n      // Force the playback rate again after a short delay\n      setTimeout(() => {\n        videoPlayer.playbackRate = speed;\n        console.log(`Re-setting playback rate to ${speed}x, actual rate: ${videoPlayer.playbackRate}x`);\n      }, 100);\n    } else {\n      console.warn('Video player element not found');\n    }\n    \n    // Update timeline state\n    timelineState.setState({ playbackSpeed: speed });\n    \n    // Show status message\n    showStatusMessage(`Playback speed: ${speed}x`, 'info');\n  };\n\n  return html`\n    <div class=\"mt-2 mb-4 p-2 border border-green-500 rounded-lg bg-white dark:bg-gray-800 shadow-sm\">\n      <div class=\"flex flex-col items-center\">\n        <div class=\"text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300\">Playback Speed</div>\n        \n        <div class=\"flex flex-wrap justify-center gap-1\">\n          ${speeds.map(speed => html`\n            <button \n              key=${`speed-${speed}`}\n              class=${`speed-btn px-2 py-1 text-sm rounded-full ${speed === currentSpeed \n                ? 'bg-green-500 text-white' \n                : 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600'} \n                font-medium transition-all focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-opacity-50`}\n              data-speed=${speed}\n              onClick=${() => setPlaybackSpeed(speed)}\n            >\n              ${speed === 1.0 ? '1× (Normal)' : `${speed}×`}\n            </button>\n          `)}\n        </div>\n        \n        <div class=\"mt-1 text-xs font-medium text-green-600 dark:text-green-400\">\n          Current: ${currentSpeed}× ${currentSpeed === 1.0 ? '(Normal)' : ''}\n        </div>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Player Component\n * Handles video playback for the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelinePlayer component\n * @returns {JSX.Element} TimelinePlayer component\n */\nexport function TimelinePlayer() {\n  // Local state\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [segments, setSegments] = useState([]);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n\n  // Refs\n  const videoRef = useRef(null);\n  const lastTimeUpdateRef = useRef(null);\n  const lastSegmentIdRef = useRef(null);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setCurrentSegmentIndex(state.currentSegmentIndex);\n      setIsPlaying(state.isPlaying);\n      setSegments(state.timelineSegments || []);\n      setPlaybackSpeed(state.playbackSpeed);\n\n      // Handle video playback\n      handleVideoPlayback(state);\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Handle video playback based on state changes\n  const handleVideoPlayback = (state) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have valid segments and segment index\n    if (!state.timelineSegments || \n        state.timelineSegments.length === 0 || \n        state.currentSegmentIndex < 0 || \n        state.currentSegmentIndex >= state.timelineSegments.length) {\n      return;\n    }\n    \n    // Get current segment\n    const segment = state.timelineSegments[state.currentSegmentIndex];\n    if (!segment) return;\n    \n    // Check if we need to load a new segment\n    const segmentChanged = lastSegmentIdRef.current !== segment.id;\n    \n    // IMPORTANT: Only reload if the segment has actually changed\n    // This prevents constant reloading\n    const needsReload = segmentChanged;\n    \n    // Calculate relative time within the segment\n    const relativeTime = state.currentTime !== null && \n                         state.currentTime >= segment.start_timestamp\n      ? state.currentTime - segment.start_timestamp\n      : 0;\n    \n    // Only update the video if:\n    // 1. We need to load a new segment, OR\n    // 2. The user is dragging the cursor (indicated by a significant time change)\n    const timeChanged = state.prevCurrentTime !== null && \n                        Math.abs(state.currentTime - state.prevCurrentTime) > 1;\n    \n    // Update last segment ID\n    if (segmentChanged) {\n      console.log(`Segment changed from ${lastSegmentIdRef.current} to ${segment.id}`);\n      lastSegmentIdRef.current = segment.id;\n    }\n    \n    // Handle playback\n    if (needsReload) {\n      // Load new segment\n      console.log(`Loading new segment ${segment.id} (segmentChanged: ${segmentChanged})`);\n      loadSegment(segment, relativeTime, state.isPlaying);\n    } else if (timeChanged) {\n      // User is dragging the cursor, just update the current time\n      console.log(`Seeking to ${relativeTime}s within current segment`);\n      video.currentTime = relativeTime;\n    } else if (state.isPlaying && video.paused) {\n      // Resume playback if needed\n      video.play().catch(error => {\n        console.error('Error playing video:', error);\n      });\n    } else if (!state.isPlaying && !video.paused) {\n      // Pause playback if needed\n      video.pause();\n    }\n    \n    // Update playback speed if needed\n    if (video.playbackRate !== state.playbackSpeed) {\n      video.playbackRate = state.playbackSpeed;\n    }\n  };\n\n  // Load a segment\n  const loadSegment = (segment, seekTime = 0, autoplay = false) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    console.log(`Loading segment ${segment.id} at time ${seekTime}s, autoplay: ${autoplay}`);\n    \n    // Pause current playback\n    video.pause();\n    \n    // Set new source with timestamp to prevent caching\n    const recordingUrl = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n    \n    // Set up event listeners for the new video\n    const onLoadedMetadata = () => {\n      console.log('Video metadata loaded');\n      \n      // Set current time\n      video.currentTime = seekTime;\n      \n      // Set playback speed\n      video.playbackRate = playbackSpeed;\n      \n      // Play if needed\n      if (autoplay) {\n        video.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      }\n      \n      // Remove event listener\n      video.removeEventListener('loadedmetadata', onLoadedMetadata);\n    };\n    \n    // Add event listener for metadata loaded\n    video.addEventListener('loadedmetadata', onLoadedMetadata);\n    \n    // Set new source\n    video.src = recordingUrl;\n    video.load();\n  };\n\n  // Handle video ended event\n  const handleEnded = () => {\n    console.log('Video ended');\n    \n    // Check if we have a next segment\n    if (currentSegmentIndex < segments.length - 1) {\n      // Play next segment\n      const nextIndex = currentSegmentIndex + 1;\n      console.log(`Playing next segment ${nextIndex}`);\n      \n      // Update timeline state\n      timelineState.setState({\n        currentSegmentIndex: nextIndex,\n        currentTime: segments[nextIndex].start_timestamp,\n        isPlaying: true,\n        forceReload: true\n      });\n    } else {\n      // End of all segments\n      console.log('End of all segments');\n      \n      // Update timeline state\n      timelineState.setState({\n        isPlaying: false\n      });\n    }\n  };\n\n  // Handle video time update event\n  const handleTimeUpdate = () => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have a valid segment\n    if (currentSegmentIndex < 0 || \n        !segments || \n        segments.length === 0 || \n        currentSegmentIndex >= segments.length) {\n      return;\n    }\n    \n    const segment = segments[currentSegmentIndex];\n    if (!segment) return;\n    \n    // Calculate current timestamp\n    const currentTime = segment.start_timestamp + video.currentTime;\n    \n    // Directly update the time display as well\n    updateTimeDisplay(currentTime);\n    \n    // Update timeline state with the current time\n    timelineState.setState({\n      currentTime: currentTime,\n      prevCurrentTime: lastTimeUpdateRef.current\n    });\n    \n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n  };\n\n  // Add a direct time display update function\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  return html`\n    <div class=\"timeline-player-container mb-2\" id=\"video-player\">\n      <div class=\"relative w-full bg-black rounded-lg shadow-md\" style=\"aspect-ratio: 16/9;\">\n        <video\n            ref=${videoRef}\n            class=\"w-full h-full object-contain\"\n            controls\n            autoplay=${false}\n            muted=${false}\n            playsInline\n            onended=${handleEnded}\n            ontimeupdate=${handleTimeUpdate}\n        ></video>\n        \n        <!-- Add a message for invalid segments -->\n        <div \n          class=\"absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-center p-4 ${currentSegmentIndex >= 0 && segments.length > 0 ? 'hidden' : ''}\"\n        >\n          <div>\n            <p class=\"mb-2\">No valid segment selected.</p>\n            <p class=\"text-sm\">Click on a segment in the timeline or use the play button to start playback.</p>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Playback speed controls -->\n    <${SpeedControls} />\n  `;\n}\n","/**\n * LightNVR Timeline Page Component\n * Main component for the timeline view\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../../preact.hooks.module.js';\nimport { TimelineControls } from './TimelineControls.js';\nimport { TimelineRuler } from './TimelineRuler.js';\nimport { TimelineSegments } from './TimelineSegments.js';\nimport { TimelineCursor } from './TimelineCursor.js';\nimport { TimelinePlayer } from './TimelinePlayer.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\nimport { LoadingIndicator } from '../LoadingIndicator.js';\n\n// Global timeline state for child components\nconst timelineState = {\n  streams: [],\n  timelineSegments: [],\n  selectedStream: null,\n  selectedDate: null,\n  isPlaying: false,\n  currentSegmentIndex: -1,\n  zoomLevel: 1, // 1 = 1 hour, 2 = 30 minutes, 4 = 15 minutes\n  timelineStartHour: 0,\n  timelineEndHour: 24,\n  currentTime: null,\n  prevCurrentTime: null,\n  playbackSpeed: 1.0,\n  showOnlySegments: true,\n  forceReload: false,\n  listeners: new Set(),\n\n  // Update state and notify listeners\n  setState(newState) {\n    Object.assign(this, newState);\n    this.notifyListeners();\n  },\n\n  // Subscribe to state changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  },\n\n  // Notify all listeners of state change\n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this));\n  }\n};\n\n/**\n * Format date for input element\n */\nfunction formatDateForInput(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/**\n * Parse URL parameters\n */\nfunction parseUrlParams() {\n  const params = new URLSearchParams(window.location.search);\n  return {\n    stream: params.get('stream') || '',\n    date: params.get('date') || formatDateForInput(new Date())\n  };\n}\n\n/**\n * Update URL parameters\n */\nfunction updateUrlParams(stream, date) {\n  if (!stream) return;\n  const url = new URL(window.location.href);\n  url.searchParams.set('stream', stream);\n  url.searchParams.set('date', date);\n  window.history.replaceState({}, '', url);\n}\n\n/**\n * TimelinePage component\n */\nexport function TimelinePage() {\n  // Get initial values from URL parameters\n  const urlParams = parseUrlParams();\n  \n  // State\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamsList, setStreamsList] = useState([]);\n  const [selectedStream, setSelectedStream] = useState(urlParams.stream);\n  const [selectedDate, setSelectedDate] = useState(urlParams.date);\n  const [segments, setSegments] = useState([]);\n  \n  // Refs\n  const timelineContainerRef = useRef(null);\n  const initialLoadRef = useRef(false);\n  \n  // Load streams on mount\n  useEffect(() => {\n    console.log('TimelinePage: Initial mount, loading streams');\n    loadStreams();\n  }, []);\n  \n  // Handle initial data load when streams are available\n  useEffect(() => {\n    if (streamsList.length > 0 && !initialLoadRef.current) {\n      console.log('TimelinePage: Streams loaded, initializing data');\n      initialLoadRef.current = true;\n      \n      // Check if the selected stream from URL exists\n      const streamExists = streamsList.some(s => s.name === selectedStream);\n      \n      if (streamExists && selectedStream) {\n        console.log(`TimelinePage: Using stream from URL: ${selectedStream}`);\n        loadTimelineData(selectedStream, selectedDate);\n      } else if (streamsList.length > 0) {\n        // Use first stream if URL stream doesn't exist\n        const firstStream = streamsList[0].name;\n        console.log(`TimelinePage: Using first stream: ${firstStream}`);\n        setSelectedStream(firstStream);\n        loadTimelineData(firstStream, selectedDate);\n      }\n    }\n  }, [streamsList]);\n  \n  // Load streams\n  const loadStreams = () => {\n    console.log('TimelinePage: Loading streams');\n    setIsLoading(true);\n    \n    fetch('/api/streams')\n      .then(response => {\n        if (!response.ok) throw new Error('Failed to load streams');\n        return response.json();\n      })\n      .then(data => {\n        console.log('TimelinePage: Streams data received:', data);\n        \n        // Ensure we have an array\n        const streams = Array.isArray(data) ? data : [];\n        console.log(`TimelinePage: Loaded ${streams.length} streams`);\n        \n        // Update state\n        setStreamsList(streams);\n        setIsLoading(false);\n        \n        // Update global state for child components\n        timelineState.setState({ streams });\n        \n        if (streams.length > 0) {\n          console.log('TimelinePage: First stream:', streams[0]);\n        }\n      })\n      .catch(error => {\n        console.error('TimelinePage: Error loading streams:', error);\n        showStatusMessage('Error loading streams: ' + error.message, 'error');\n        setIsLoading(false);\n      });\n  };\n  \n  // Load timeline data\n  const loadTimelineData = (stream, date) => {\n    if (!stream) {\n      showStatusMessage('Please select a stream', 'error');\n      return;\n    }\n    \n    console.log(`TimelinePage: Loading timeline data for ${stream} on ${date}`);\n    setIsLoading(true);\n    setSegments([]);\n    showStatusMessage('Loading timeline data...', 'info');\n    \n    // Update URL\n    updateUrlParams(stream, date);\n    \n    // Calculate time range (full day)\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n    \n    const endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n    \n    // Format dates for API\n    const startTime = startDate.toISOString();\n    const endTime = endDate.toISOString();\n    \n    // Update global state\n    timelineState.setState({\n      selectedStream: stream,\n      selectedDate: date,\n      timelineSegments: [],\n      currentSegmentIndex: -1,\n      currentTime: null,\n      isPlaying: false\n    });\n    \n    // Fetch timeline segments\n    fetch(`/api/timeline/segments?stream=${encodeURIComponent(stream)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}`)\n      .then(response => {\n        if (!response.ok) throw new Error('Failed to load timeline data');\n        return response.json();\n      })\n      .then(data => {\n        console.log('TimelinePage: Timeline data received:', data);\n        const timelineSegments = data.segments || [];\n        console.log(`TimelinePage: Received ${timelineSegments.length} segments`);\n        \n        setIsLoading(false);\n        \n        if (timelineSegments.length === 0) {\n          console.log('TimelinePage: No segments found');\n          setSegments([]);\n          \n          // Update global state\n          timelineState.setState({\n            timelineSegments: [],\n            currentSegmentIndex: -1,\n            currentTime: null,\n            isPlaying: false\n          });\n          \n          showStatusMessage('No recordings found for the selected date', 'warning');\n          return;\n        }\n        \n        console.log('TimelinePage: Setting segments');\n        setSegments(timelineSegments);\n        \n        // Update global state with the first segment selected\n        const initialTime = timelineSegments[0].start_timestamp;\n        timelineState.setState({\n          timelineSegments,\n          currentSegmentIndex: 0,\n          currentTime: initialTime,\n          prevCurrentTime: initialTime,\n          isPlaying: false\n        });\n        \n        // Preload the first segment's video\n        const videoPlayer = document.querySelector('#video-player video');\n        if (videoPlayer) {\n          videoPlayer.src = `/api/recordings/play/${timelineSegments[0].id}`;\n          videoPlayer.load();\n        }\n        \n        showStatusMessage(`Loaded ${timelineSegments.length} recording segments`, 'success');\n      })\n      .catch(error => {\n        console.error('TimelinePage: Error loading timeline data:', error);\n        showStatusMessage('Error loading timeline data: ' + error.message, 'error');\n        setIsLoading(false);\n        setSegments([]);\n      });\n  };\n  \n  // Handle stream selection change\n  const handleStreamChange = (e) => {\n    const newStream = e.target.value;\n    console.log(`TimelinePage: Stream changed to ${newStream}`);\n    setSelectedStream(newStream);\n    \n    if (newStream) {\n      loadTimelineData(newStream, selectedDate);\n    }\n  };\n  \n  // Handle date selection change\n  const handleDateChange = (e) => {\n    const newDate = e.target.value;\n    console.log(`TimelinePage: Date changed to ${newDate}`);\n    setSelectedDate(newDate);\n    \n    if (selectedStream) {\n      loadTimelineData(selectedStream, newDate);\n    }\n  };\n  \n  // Render content based on state\n  const renderContent = () => {\n    if (isLoading) {\n      return html`<${LoadingIndicator} message=\"Loading timeline data...\" />`;\n    }\n    \n    if (segments.length === 0) {\n      return html`\n        <div class=\"flex flex-col items-center justify-center py-12 text-center\">\n          <svg class=\"w-16 h-16 text-gray-400 dark:text-gray-600 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path>\n          </svg>\n          <p class=\"text-gray-600 dark:text-gray-400 text-lg\">No recordings found for the selected date and stream</p>\n        </div>\n      `;\n    }\n    \n    return html`\n      <!-- Video player -->\n      <${TimelinePlayer} />\n\n      <!-- Playback controls -->\n      <${TimelineControls} />\n\n        <!-- Timeline -->\n        <div\n            id=\"timeline-container\"\n            class=\"relative w-full h-24 bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg mb-6 overflow-hidden\"\n            ref=${timelineContainerRef}\n        >\n          <${TimelineRuler} />\n          <${TimelineSegments} />\n          <${TimelineCursor} />\n          \n          <!-- Instructions for cursor -->\n          <div class=\"absolute bottom-1 right-2 text-xs text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 px-2 py-1 rounded\">\n            Drag the orange dial to navigate\n          </div>\n        </div>\n    `;\n  };\n  \n  return html`\n    <div class=\"timeline-page\">\n      <div class=\"flex items-center mb-4\">\n        <h1 class=\"text-2xl font-bold\">Timeline Playback</h1>\n        <div class=\"ml-4 flex\">\n          <a href=\"recordings.html\" class=\"px-3 py-1 bg-gray-300 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-l-md\">Table View</a>\n          <a href=\"timeline.html\" class=\"px-3 py-1 bg-blue-500 text-white rounded-r-md\">Timeline View</a>\n        </div>\n      </div>\n\n      <!-- Stream selector and date picker -->\n      <div class=\"flex flex-wrap gap-4 mb-2\">\n        <div class=\"stream-selector flex-grow\">\n          <div class=\"flex justify-between items-center mb-2\">\n            <label for=\"stream-selector\">Stream</label>\n            <button \n              class=\"text-xs bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 px-2 py-1 rounded\"\n              onClick=${() => loadStreams()}\n            >\n              Reload Streams\n            </button>\n          </div>\n          <select\n              id=\"stream-selector\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedStream || ''}\n              onChange=${handleStreamChange}\n          >\n            <option value=\"\" disabled>Select a stream (${streamsList.length} available)</option>\n            ${streamsList.map(stream => html`\n              <option key=${stream.name} value=${stream.name}>${stream.name}</option>\n            `)}\n          </select>\n        </div>\n\n        <div class=\"date-selector flex-grow\">\n          <label for=\"timeline-date\" class=\"block mb-2\">Date</label>\n          <input\n              type=\"date\"\n              id=\"timeline-date\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedDate}\n              onChange=${handleDateChange}\n          />\n        </div>\n      </div>\n      \n      <!-- Auto-load message -->\n      <div class=\"mb-4 text-sm text-gray-500 dark:text-gray-400 italic\">\n        ${isLoading ? 'Loading...' : 'Recordings auto-load when stream or date changes'}\n      </div>\n\n      <!-- Current time display -->\n      <div class=\"flex justify-between items-center mb-2\">\n        <div id=\"time-display\" class=\"timeline-time-display bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded font-mono text-base\">00:00:00</div>\n      </div>\n      \n      <!-- Debug info -->\n      <div class=\"mb-2 text-xs text-gray-500\">\n        Debug - isLoading: ${isLoading ? 'true' : 'false'}, \n        Streams: ${streamsList.length},\n        Segments: ${segments.length}\n      </div>\n      \n      <!-- Content -->\n      ${renderContent()}\n\n      <!-- Instructions -->\n      <div class=\"mt-6 p-4 bg-gray-200 dark:bg-gray-800 rounded\">\n        <h3 class=\"text-lg font-semibold mb-2\">How to use the timeline:</h3>\n        <ul class=\"list-disc pl-5\">\n          <li>Select a stream and date to load recordings</li>\n          <li>Click on the timeline to seek to a specific time</li>\n          <li>Click on a segment (blue bar) to play that recording</li>\n          <li>Use the play/pause button to control playback</li>\n          <li>Use the zoom buttons to adjust the timeline scale</li>\n        </ul>\n      </div>\n    </div>\n  `;\n}\n\n// Export the timeline state for use in other components\nexport { timelineState };\n","/**\n * LightNVR Timeline View Component\n * Loads the Timeline page component into the main content area\n */\n\nimport { h, render } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { TimelinePage } from './TimelinePage.js';\n\n/**\n * Load TimelineView component\n */\nexport function loadTimelineView() {\n  const mainContent = document.getElementById('main-content');\n  if (!mainContent) return;\n\n  // Clear any existing content\n  mainContent.innerHTML = '';\n\n  // Render the TimelinePage component to the container\n  render(html`<${TimelinePage} />`, mainContent);\n}"],"names":["TimelineControls","isPlaying","setIsPlaying","useState","zoomLevel","setZoomLevel","useEffect","unsubscribe","timelineState","state","_a","togglePlayback","pausePlayback","resumePlayback","videoPlayer","showStatusMessage","earliestSegmentIndex","earliestTimestamp","segment","index","error","zoomIn","newZoomLevel","zoomOut","html","_c","__template","_b","TimelineRuler","startHour","setStartHour","endHour","setEndHour","hoursPerView","centerHour","currentDate","earliestHour","latestHour","startTime","endTime","newStartHour","newEndHour","generateHourMarkers","markers","hour","position","_d","_e","halfHourPosition","_f","quarterHourPosition1","quarterHourPosition3","_g","_h","_i","TimelineSegments","segments","setSegments","currentSegmentIndex","setCurrentSegmentIndex","containerRef","useRef","isDragging","container","handleMouseDown","e","handleTimelineClick","handleMouseMove","handleMouseUp","event","rect","clickX","containerWidth","clickPercent","clickHour","clickDate","clickTimestamp","foundSegment","i","relativeTime","playSegment","closestSegment","minDistance","startDistance","endDistance","distance","absoluteTime","videoElement","seekTime","renderSegments","visibleSegments","hourMap","startHourFloat","endHourFloat","startFloorHour","endCeilHour","h","mergedSegments","currentMergedSegment","a","b","mergedIndex","visibleStartHour","visibleEndHour","startPercent","widthPercent","duration","durationStr","startTimeStr","endTimeStr","_j","width","_k","_l","TimelineCursor","setPosition","visible","setVisible","currentTime","setCurrentTime","setIsDragging","cursorRef","dragStartXRef","updateTimeDisplay","updateCursorPosition","cursor","positionPercent","hourRange","date","timestamp","time","startHr","endHr","timeDisplay","hours","minutes","seconds","_m","SpeedControls","currentSpeed","setCurrentSpeed","speeds","setPlaybackSpeed","speed","oldRate","_o","_n","TimelinePlayer","playbackSpeed","videoRef","lastTimeUpdateRef","lastSegmentIdRef","handleVideoPlayback","video","segmentChanged","needsReload","timeChanged","loadSegment","autoplay","recordingUrl","onLoadedMetadata","handleEnded","nextIndex","handleTimeUpdate","_p","newState","listener","formatDateForInput","year","month","day","parseUrlParams","params","updateUrlParams","stream","url","TimelinePage","urlParams","isLoading","setIsLoading","streamsList","setStreamsList","selectedStream","setSelectedStream","selectedDate","setSelectedDate","timelineContainerRef","initialLoadRef","loadStreams","s","loadTimelineData","firstStream","response","data","streams","startDate","endDate","timelineSegments","initialTime","handleStreamChange","newStream","handleDateChange","newDate","renderContent","_q","LoadingIndicator","_r","_s","_u","_t","loadTimelineView","mainContent","render","_v"],"mappings":"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"}