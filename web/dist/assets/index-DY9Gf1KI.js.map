{"version":3,"file":"index-DY9Gf1KI.js","sources":["../../js/components/preact/WebRTCView.jsx","../../js/pages/index-page.jsx"],"sourcesContent":["/**\n * LightNVR Web Interface WebRTCView Component\n * Preact component for the WebRTC view page\n */\n\n\nimport { useState, useEffect, useRef, useCallback } from 'preact/hooks';\nimport { showStatusMessage, showSnapshotPreview, setupModals, addStatusMessageStyles, addModalStyles } from './UI.js';\nimport { toggleFullscreen, exitFullscreenMode } from './FullscreenManager.js';\nimport { startDetectionPolling, cleanupDetectionPolling } from './DetectionOverlay.js';\nimport { usePostMutation, useMutation, useQuery, useQueryClient } from '../../query-client.js';\nimport { WebRTCVideoCell } from './WebRTCVideoCell.jsx';\n\n/**\n * WebRTCView component\n * @returns {JSX.Element} WebRTCView component\n */\nexport function WebRTCView() {\n  // WebRTC offer mutation hook - we don't specify the URL here as it will be dynamic based on the stream\n  const webrtcOfferMutation = useMutation({\n    mutationFn: async (data) => {\n      const { streamName, ...offerData } = data;\n      const auth = localStorage.getItem('auth');\n\n      const response = await fetch(`/api/webrtc?src=${encodeURIComponent(streamName)}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(auth ? { 'Authorization': 'Basic ' + auth } : {})\n        },\n        body: JSON.stringify(offerData),\n        signal: data.signal\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to send offer: ${response.status} ${response.statusText}`);\n      }\n\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch (jsonError) {\n        console.error(`Error parsing JSON for stream ${streamName}:`, jsonError);\n        console.log(`Raw response text: ${text}`);\n        throw new Error(`Failed to parse WebRTC answer: ${jsonError.message}`);\n      }\n    },\n    onError: (error, variables) => {\n      console.error(`Error sending WebRTC offer for stream ${variables.streamName}:`, error);\n    }\n  });\n\n  const [streams, setStreams] = useState([]);\n  // Initialize layout from URL or sessionStorage if available\n  const [layout, setLayout] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const layoutParam = urlParams.get('layout');\n    if (layoutParam) {\n      return layoutParam;\n    }\n    // Check sessionStorage as a backup\n    const storedLayout = sessionStorage.getItem('webrtc_layout');\n    return storedLayout || '4';\n  });\n\n  // Initialize selectedStream from URL or sessionStorage if available\n  const [selectedStream, setSelectedStream] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const streamParam = urlParams.get('stream');\n    if (streamParam) {\n      return streamParam;\n    }\n    // Check sessionStorage as a backup\n    const storedStream = sessionStorage.getItem('webrtc_selected_stream');\n    return storedStream || '';\n  });\n\n  const [isFullscreen, setIsFullscreen] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Initialize currentPage from URL or sessionStorage if available (URL uses 1-based indexing, internal state uses 0-based)\n  const [currentPage, setCurrentPage] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const pageParam = urlParams.get('page');\n    if (pageParam) {\n      // Convert from 1-based (URL) to 0-based (internal)\n      return Math.max(0, parseInt(pageParam, 10) - 1);\n    }\n    // Check sessionStorage as a backup\n    const storedPage = sessionStorage.getItem('webrtc_current_page');\n    if (storedPage) {\n      // Convert from 1-based (stored) to 0-based (internal)\n      return Math.max(0, parseInt(storedPage, 10) - 1);\n    }\n    return 0;\n  });\n  const videoGridRef = useRef(null);\n  const webrtcConnections = useRef({});\n  const detectionIntervals = useRef({});\n\n  // Set up event listeners and UI components\n  useEffect(() => {\n    // Set up modals for snapshot preview\n    setupModals();\n    addStatusMessageStyles();\n    addModalStyles();\n\n    // Add event listener to preserve URL parameters when page is reloaded\n    const handleBeforeUnload = () => {\n      console.log('Preserving URL parameters before page reload');\n\n      // Create a URL with the current parameters\n      const url = new URL(window.location);\n\n      // Ensure page parameter is set correctly (convert from 0-based internal to 1-based URL)\n      if (currentPage > 0) {\n        url.searchParams.set('page', currentPage + 1);\n      } else {\n        url.searchParams.delete('page');\n      }\n\n      // Ensure layout parameter is set if not default\n      if (layout !== '4') {\n        url.searchParams.set('layout', layout);\n      } else {\n        url.searchParams.delete('layout');\n      }\n\n      // Ensure stream parameter is set if in single stream mode\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without triggering navigation\n      window.history.replaceState({}, '', url);\n\n      // Store the current page in sessionStorage as a backup\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      // Store layout in sessionStorage\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      // Store selected stream in sessionStorage\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    };\n\n    // Register the beforeunload handler\n    window.addEventListener('beforeunload', handleBeforeUnload);\n\n    // Set up periodic connection check\n    const connectionCheckInterval = setInterval(() => {\n      Object.keys(webrtcConnections.current).forEach(streamName => {\n        const pc = webrtcConnections.current[streamName];\n        if (pc) {\n          // Log connection state for debugging\n          console.debug(`WebRTC connection state for ${streamName}: ${pc.connectionState}, ICE state: ${pc.iceConnectionState}`);\n\n          // If connection is failed or disconnected for too long, try to reconnect\n          if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n            console.warn(`WebRTC connection for ${streamName} is in ${pc.iceConnectionState} state, will attempt reconnect`);\n\n            // Clean up the old connection\n            cleanupWebRTCPlayer(streamName);\n\n            // Find the stream info and reinitialize\n            const stream = streams.find(s => s.name === streamName);\n            if (stream) {\n              console.log(`Attempting to reconnect WebRTC for stream ${streamName}`);\n              initializeWebRTCPlayer(stream);\n            }\n          }\n        }\n      });\n    }, 30000); // Check every 30 seconds\n\n    // Cleanup\n    return () => {\n      // Remove event listeners\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      clearInterval(connectionCheckInterval);\n      stopAllWebRTCStreams();\n    };\n  }, [streams, currentPage, layout, selectedStream]); // Add all relevant dependencies\n\n  // Get query client for fetching and invalidating queries\n  const queryClient = useQueryClient();\n\n  // Fetch streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery(\n    'streams',\n    '/api/streams',\n    {\n      timeout: 15000, // 15 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    }\n  );\n\n  // Update loading state based on streams query status\n  useEffect(() => {\n    setIsLoading(isLoadingStreams);\n  }, [isLoadingStreams]);\n\n  // Process streams data when it's loaded\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData)) {\n      // Process the streams data\n      const processStreams = async () => {\n        try {\n          // Filter and process the streams\n          const filteredStreams = await filterStreamsForWebRTC(streamsData);\n\n          if (filteredStreams.length > 0) {\n            setStreams(filteredStreams);\n\n            // Set selectedStream based on URL parameter if it exists and is valid\n            const urlParams = new URLSearchParams(window.location.search);\n            const streamParam = urlParams.get('stream');\n\n            if (streamParam && filteredStreams.some(stream => stream.name === streamParam)) {\n              // If the stream from URL exists in the loaded streams, use it\n              setSelectedStream(streamParam);\n            } else if (!selectedStream || !filteredStreams.some(stream => stream.name === selectedStream)) {\n              // Otherwise use the first stream if selectedStream is not set or invalid\n              setSelectedStream(filteredStreams[0].name);\n            }\n          } else {\n            console.warn('No streams available for WebRTC view after filtering');\n          }\n        } catch (error) {\n          console.error('Error processing streams:', error);\n          showStatusMessage('Error processing streams: ' + error.message);\n        }\n      };\n\n      processStreams();\n    }\n  }, [streamsData, selectedStream, queryClient]);\n\n  // Use a ref to track previous values to prevent unnecessary updates\n  const previousValues = useRef({ layout, selectedStream, currentPage, streamsLength: streams.length });\n\n  useEffect(() => {\n    // Only update if something actually changed\n    const prev = previousValues.current;\n    if (\n      prev.layout !== layout ||\n      prev.selectedStream !== selectedStream ||\n      prev.currentPage !== currentPage ||\n      prev.streamsLength !== streams.length\n    ) {\n      console.log('Layout, selectedStream, currentPage, or streams changed, updating video grid');\n      updateVideoGrid();\n\n      // Update previous values\n      previousValues.current = { layout, selectedStream, currentPage, streamsLength: streams.length };\n    }\n  }, [layout, selectedStream, streams, currentPage]);\n\n  // Update URL when layout, page, or selectedStream changes\n  useEffect(() => {\n    // Don't update URL during initial load or when streams are empty\n    if (streams.length === 0) return;\n\n    // Use a debounce to prevent multiple URL updates in quick succession\n    const updateURLTimeout = setTimeout(() => {\n      console.log('Updating URL parameters');\n      const url = new URL(window.location);\n\n      // Handle page parameter (convert from 0-based internal to 1-based URL)\n      if (currentPage === 0) {\n        url.searchParams.delete('page');\n      } else {\n        // Add 1 to convert from 0-based (internal) to 1-based (URL)\n        url.searchParams.set('page', currentPage + 1);\n      }\n\n      // Handle layout parameter\n      if (layout !== '4') { // Only set if not the default\n        url.searchParams.set('layout', layout);\n      } else {\n        // Remove layout parameter if it's the default value\n        url.searchParams.delete('layout');\n      }\n\n      // Handle selectedStream parameter\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        // Remove stream parameter if not in single stream mode\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without reloading the page\n      window.history.replaceState({}, '', url);\n\n      // Also update sessionStorage\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    }, 300); // 300ms debounce\n\n    // Clean up the timeout if the component re-renders before the timeout completes\n    return () => clearTimeout(updateURLTimeout);\n  }, [currentPage, layout, selectedStream, streams.length]);\n\n  /**\n   * Filter streams for WebRTC view\n   * @param {Array} streams - Array of streams\n   * @returns {Promise<Array>} Promise resolving to filtered array of streams\n   */\n  const filterStreamsForWebRTC = async (streams) => {\n    try {\n      if (!streams || !Array.isArray(streams)) {\n        console.warn('No streams data provided to filter');\n        return [];\n      }\n\n      // For WebRTC view, we need to fetch full details for each stream\n      const streamPromises = streams.map(async (stream) => {\n        try {\n          const streamId = stream.id || stream.name;\n\n          const streamDetails = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamId],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamId)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to load details for stream ${stream.name}`);\n              }\n              return response.json();\n            },\n            staleTime: 30000 // 30 seconds\n          });\n\n          return streamDetails;\n        } catch (error) {\n          console.error(`Error loading details for stream ${stream.name}:`, error);\n          // Return the basic stream info if we can't get details\n          return stream;\n        }\n      });\n\n      const detailedStreams = await Promise.all(streamPromises);\n      console.log('Loaded detailed streams for WebRTC view:', detailedStreams);\n\n      // Filter out streams that are soft deleted, inactive, or not configured for streaming\n      const filteredStreams = detailedStreams.filter(stream => {\n        // Filter out soft deleted streams\n        if (stream.is_deleted) {\n          console.log(`Stream ${stream.name} is soft deleted, filtering out`);\n          return false;\n        }\n\n        // Filter out inactive streams\n        if (!stream.enabled) {\n          console.log(`Stream ${stream.name} is inactive, filtering out`);\n          return false;\n        }\n\n        // Filter out streams not configured for streaming\n        if (!stream.streaming_enabled) {\n          console.log(`Stream ${stream.name} is not configured for streaming, filtering out`);\n          return false;\n        }\n\n        return true;\n      });\n\n      console.log('Filtered streams for WebRTC view:', filteredStreams);\n\n      return filteredStreams || [];\n    } catch (error) {\n      console.error('Error filtering streams for WebRTC view:', error);\n      showStatusMessage('Error processing streams: ' + error.message);\n      return [];\n    }\n  };\n\n  /**\n   * Get maximum number of streams to display based on layout\n   * @returns {number} Maximum number of streams\n   */\n  const getMaxStreamsForLayout = () => {\n    switch (layout) {\n      case '1': return 1;  // Single view\n      case '2': return 2;  // 2x1 grid\n      case '4': return 4;  // 2x2 grid\n      case '6': return 6;  // 2x3 grid\n      case '9': return 9;  // 3x3 grid\n      case '16': return 16; // 4x4 grid\n      default: return 4;\n    }\n  };\n\n  /**\n   * Get streams to show based on layout, selected stream, and pagination\n   * @returns {Array} Streams to show\n   */\n  const getStreamsToShow = () => {\n    // Filter streams based on layout and selected stream\n    let streamsToShow = streams;\n    if (layout === '1' && selectedStream) {\n      streamsToShow = streams.filter(stream => stream.name === selectedStream);\n    } else {\n      // Apply pagination\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      // Ensure current page is valid\n      if (currentPage >= totalPages && totalPages > 0) {\n        // We'll handle this in updateVideoGrid\n        return [];\n      }\n\n      // Get streams for current page\n      const startIdx = currentPage * maxStreams;\n      const endIdx = Math.min(startIdx + maxStreams, streams.length);\n      streamsToShow = streams.slice(startIdx, endIdx);\n    }\n\n    return streamsToShow;\n  };\n\n  /**\n   * Update video grid based on layout, streams, and pagination\n   */\n  const updateVideoGrid = () => {\n    if (!videoGridRef.current) return;\n\n    // Filter streams based on layout and selected stream\n    let streamsToShow = getStreamsToShow();\n\n    // If no streams to show and we have streams, check if page is invalid\n    if (streamsToShow.length === 0 && streams.length > 0) {\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      if (currentPage >= totalPages) {\n        setCurrentPage(Math.max(0, totalPages - 1));\n        return; // Will re-render with corrected page\n      }\n    }\n\n    // Get the names of streams that should be shown\n    const streamsToShowNames = streamsToShow.map(stream => stream.name);\n\n    // Log page change for debugging\n    console.log(`Updating video grid for page ${currentPage + 1}, showing streams:`, streamsToShowNames);\n\n    // Clean up connections for streams that are no longer visible\n    const connectionsToCleanup = Object.keys(webrtcConnections.current).filter(\n      streamName => !streamsToShowNames.includes(streamName)\n    );\n\n    if (connectionsToCleanup.length > 0) {\n      console.log(`Cleaning up ${connectionsToCleanup.length} WebRTC connections that are no longer visible:`, connectionsToCleanup);\n      connectionsToCleanup.forEach(streamName => {\n        cleanupWebRTCPlayer(streamName);\n      });\n    }\n  };\n\n  /**\n   * Initialize WebRTC player for a stream\n   * @param {Object} stream - Stream object\n   * @param {HTMLVideoElement} videoElement - Video element\n   * @param {HTMLCanvasElement} canvasOverlay - Canvas overlay for detection\n   * @param {Object} callbacks - Callback functions\n   */\n  const initializeWebRTCPlayer = (stream, videoElement, canvasOverlay, callbacks = {}) => {\n    if (!stream || !videoElement) {\n      console.error(`Cannot initialize WebRTC player: missing stream or video element`);\n      return;\n    }\n\n    // Check if there's already a connection for this stream\n    if (webrtcConnections.current[stream.name]) {\n      console.log(`WebRTC connection for stream ${stream.name} already exists, cleaning up first`);\n      cleanupWebRTCPlayer(stream.name);\n    }\n\n    console.log(`Initializing WebRTC player for stream ${stream.name}`);\n\n    // Create a new RTCPeerConnection with ICE servers\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ],\n      // Add additional configuration to ensure proper ICE credentials\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'balanced',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'unified-plan'\n    });\n\n    // Store the connection for cleanup\n    webrtcConnections.current[stream.name] = pc;\n\n    // Add event listeners\n    pc.ontrack = (event) => {\n      console.log(`Track received for stream ${stream.name}:`, event);\n      if (event.track.kind === 'video') {\n        videoElement.srcObject = event.streams[0];\n\n        // Add event handlers for video element\n        videoElement.onloadeddata = () => {\n          console.log(`Video data loaded for stream ${stream.name}`);\n          if (callbacks.onLoadedData) {\n            callbacks.onLoadedData();\n          }\n        };\n\n        videoElement.onplaying = () => {\n          console.log(`Video playing for stream ${stream.name}`);\n          if (callbacks.onPlaying) {\n            callbacks.onPlaying();\n          }\n\n          // Start detection polling now that the video is playing\n          if (stream.detection_based_recording && stream.detection_model && canvasOverlay) {\n            console.log(`Starting detection polling for stream ${stream.name} now that video is playing`);\n            startDetectionPolling(stream.name, canvasOverlay, videoElement, detectionIntervals.current);\n          } else {\n            console.log(`Detection not enabled for stream ${stream.name}`);\n          }\n        };\n\n        videoElement.onerror = (e) => {\n          console.error(`Video error for stream ${stream.name}:`, e);\n          if (callbacks.onError) {\n            callbacks.onError('Video playback error');\n          }\n        };\n      }\n    };\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log(`ICE candidate for stream ${stream.name}:`, event.candidate);\n        // go2rtc doesn't use a separate ICE endpoint, so we don't need to send ICE candidates\n      }\n    };\n\n    pc.oniceconnectionstatechange = () => {\n      console.log(`ICE connection state for stream ${stream.name}:`, pc.iceConnectionState);\n\n      // Handle different ICE connection states\n      if (pc.iceConnectionState === 'failed') {\n        console.warn(`ICE failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC ICE connection failed');\n        }\n      } else if (pc.iceConnectionState === 'disconnected') {\n        console.warn(`ICE disconnected for stream ${stream.name}`);\n        // Don't immediately handle as error, as disconnected can be temporary\n      }\n    };\n\n    // Also monitor connection state changes\n    pc.onconnectionstatechange = () => {\n      console.log(`Connection state changed for stream ${stream.name}:`, pc.connectionState);\n\n      if (pc.connectionState === 'failed') {\n        console.warn(`Connection failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC connection failed');\n        }\n      }\n    };\n\n    // Add transceivers to ensure we get both audio and video tracks\n    pc.addTransceiver('video', {direction: 'recvonly'});\n    pc.addTransceiver('audio', {direction: 'recvonly'});\n\n    // Create an offer with specific codec requirements\n    const offerOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n\n    // Create a timeout for the entire WebRTC setup process\n    const setupTimeoutId = setTimeout(() => {\n      console.warn(`WebRTC setup timed out for stream ${stream.name}`);\n      if (callbacks.onError) {\n        callbacks.onError('WebRTC setup timed out');\n      }\n\n      // Clean up the connection if it exists\n      if (webrtcConnections.current[stream.name]) {\n        cleanupWebRTCPlayer(stream.name);\n      }\n    }, 30000); // 30 second timeout for the entire setup process\n\n    // Create a separate timeout for video playback\n    const videoPlaybackTimeoutId = setTimeout(() => {\n      // Only show error if the connection still exists but video isn't playing\n      if (webrtcConnections.current[stream.name] &&\n          (!videoElement.srcObject || videoElement.readyState < 2)) { // HAVE_CURRENT_DATA = 2\n        console.warn(`Video playback timed out for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('Video playback timed out');\n        }\n      }\n    }, 20000); // 20 second timeout for video playback\n\n    // Add a check to ensure the connection still exists before proceeding\n    const checkConnectionExists = () => {\n      return webrtcConnections.current[stream.name] === pc;\n    };\n\n    pc.createOffer(offerOptions)\n      .then(offer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up during offer creation');\n        }\n        console.log(`Created offer for stream ${stream.name}`);\n        return pc.setLocalDescription(offer);\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting local description');\n        }\n        console.log(`Set local description for stream ${stream.name}`);\n        // Send the offer to the server\n        return sendOffer(stream.name, pc.localDescription);\n      })\n      .then(answer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after receiving answer');\n        }\n        console.log(`Received answer for stream ${stream.name}`);\n        // Set the remote description\n        return pc.setRemoteDescription(new RTCSessionDescription(answer));\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting remote description');\n        }\n        console.log(`Set remote description for stream ${stream.name}`);\n\n        // Clear both timeouts since we've successfully set up the connection\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n      })\n      .catch(error => {\n        // Clear both timeouts\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n\n        // Only log and call error callback if the connection still exists\n        if (checkConnectionExists()) {\n          console.error(`Error setting up WebRTC for stream ${stream.name}:`, error);\n          if (callbacks.onError) {\n            callbacks.onError(error.message);\n          }\n        } else {\n          console.log(`WebRTC setup for stream ${stream.name} was cancelled: ${error.message}`);\n        }\n      });\n\n    // Add event listener to clear the video playback timeout when video starts playing\n    videoElement.addEventListener('playing', () => {\n      clearTimeout(videoPlaybackTimeoutId);\n    }, { once: true }); // Use once: true to ensure it only fires once\n  };\n\n  /**\n   * Send WebRTC offer to server\n   * @param {string} streamName - Stream name\n   * @param {RTCSessionDescription} offer - WebRTC offer\n   * @returns {Promise<RTCSessionDescription>} Promise resolving to WebRTC answer\n   */\n  const sendOffer = useCallback(async (streamName, offer) => {\n    try {\n      // Format the offer according to go2rtc expectations\n      const formattedOffer = {\n        type: offer.type,\n        sdp: offer.sdp\n      };\n\n      console.log(`Sending formatted offer for stream ${streamName}`);\n\n      // Create an AbortController to allow cancellation of the request\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n\n      // Store the abort controller in the connection object for later cleanup\n      if (webrtcConnections.current[streamName]) {\n        webrtcConnections.current[streamName].abortController = abortController;\n      } else {\n        // If the connection no longer exists, abort immediately\n        console.log(`Connection for stream ${streamName} no longer exists, aborting offer`);\n        abortController.abort();\n        return Promise.reject(new Error('Connection no longer exists'));\n      }\n\n      // Use the mutation to send the offer with the abort signal\n      const result = await webrtcOfferMutation.mutateAsync({\n        ...formattedOffer,\n        streamName, // Add streamName for the URL construction in mutationFn\n        signal      // Add signal for request cancellation\n      });\n\n      // Check if the connection still exists before returning the result\n      if (webrtcConnections.current[streamName]) {\n        return result;\n      } else {\n        // If the connection was cleaned up during the request, abort and reject\n        console.log(`Connection for stream ${streamName} was cleaned up during offer, rejecting result`);\n        return Promise.reject(new Error('Connection was cleaned up during offer'));\n      }\n    } catch (error) {\n      // Check if this was an abort error, which we can safely ignore\n      if (error.name === 'AbortError') {\n        console.log(`WebRTC offer request for stream ${streamName} was aborted`);\n        // Return a rejected promise to stop the WebRTC connection process\n        return Promise.reject(new Error('Request aborted'));\n      }\n\n      console.error(`Error sending offer for stream ${streamName}:`, error);\n      throw error;\n    }\n  }, [webrtcOfferMutation]);\n\n  // ICE candidates are handled internally by the browser for go2rtc\n\n  /**\n   * Handle WebRTC error\n   * @param {string} streamName - Stream name\n   * @param {string} message - Error message\n   */\n  const handleWebRTCError = async (streamName, message) => {\n    console.error(`WebRTC error for stream ${streamName}:`, message);\n\n    // Find the video cell\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    if (!videoElement) return;\n\n    const videoCell = videoElement.closest('.video-cell');\n    if (!videoCell) return;\n\n    // Hide loading indicator\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'none';\n    }\n\n    // Create error indicator if it doesn't exist\n    let errorIndicator = videoCell.querySelector('.error-indicator');\n    if (!errorIndicator) {\n      errorIndicator = document.createElement('div');\n      errorIndicator.className = 'error-indicator';\n      errorIndicator.style.position = 'absolute';\n      errorIndicator.style.top = '0';\n      errorIndicator.style.left = '0';\n      errorIndicator.style.width = '100%';\n      errorIndicator.style.height = '100%';\n      errorIndicator.style.display = 'flex';\n      errorIndicator.style.flexDirection = 'column';\n      errorIndicator.style.justifyContent = 'center';\n      errorIndicator.style.alignItems = 'center';\n      errorIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n      errorIndicator.style.color = 'white';\n      errorIndicator.style.zIndex = '20'; // Above video but below controls\n      videoCell.appendChild(errorIndicator);\n    }\n\n    // Create the error message and retry button\n    const errorIcon = document.createElement('div');\n    errorIcon.className = 'error-icon';\n    errorIcon.textContent = '!';\n    errorIcon.style.fontSize = '24px';\n    errorIcon.style.marginBottom = '10px';\n    errorIcon.style.fontWeight = 'bold';\n\n    const errorMsg = document.createElement('p');\n    errorMsg.textContent = message || 'WebRTC connection failed';\n    errorMsg.style.marginBottom = '15px';\n    errorMsg.style.textAlign = 'center';\n    errorMsg.style.maxWidth = '80%';\n    errorMsg.style.color = 'white';\n\n    const retryButton = document.createElement('button');\n    retryButton.className = 'retry-button';\n    retryButton.textContent = 'Retry';\n    retryButton.style.padding = '8px 16px';\n    retryButton.style.backgroundColor = '#2563eb'; // blue-600\n    retryButton.style.color = 'white';\n    retryButton.style.borderRadius = '4px';\n    retryButton.style.border = 'none';\n    retryButton.style.cursor = 'pointer';\n    retryButton.style.position = 'relative';\n    retryButton.style.zIndex = '30';\n    retryButton.style.pointerEvents = 'auto';\n    retryButton.style.margin = '0 auto';\n    retryButton.style.display = 'block';\n\n    // Clear the error indicator and add the new elements\n    errorIndicator.innerHTML = '';\n    errorIndicator.appendChild(errorIcon);\n    errorIndicator.appendChild(errorMsg);\n    errorIndicator.appendChild(retryButton);\n\n    errorIndicator.style.display = 'flex';\n    errorIndicator.style.pointerEvents = 'auto'; // Enable pointer events when visible to allow retry button clicks\n\n    // Add event listener to retry button\n    retryButton.addEventListener('click', async (event) => {\n      console.log('Retry button clicked for stream:', streamName);\n      event.preventDefault();\n      event.stopPropagation();\n\n      // Show loading indicator\n      if (loadingIndicator) {\n        loadingIndicator.style.display = 'flex';\n      }\n\n      // Hide error indicator\n      errorIndicator.style.display = 'none';\n\n      // Cleanup existing connection\n      cleanupWebRTCPlayer(streamName);\n\n      // Find the stream in our streams array\n      const stream = streams.find(s => s.name === streamName);\n\n      if (stream) {\n        console.log(`Found stream ${streamName} in local state, reinitializing`);\n        // Small delay to ensure cleanup is complete\n        setTimeout(() => {\n          initializeWebRTCPlayer(stream);\n        }, 100);\n      } else {\n        console.log(`Stream ${streamName} not found in local state, fetching from API`);\n\n        try {\n          // Fetch stream info using queryClient\n          const streamInfo = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamName],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamName)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to fetch stream info: ${response.status} ${response.statusText}`);\n              }\n              return response.json();\n            },\n            staleTime: 10000 // 10 seconds\n          });\n\n          console.log(`Received stream info for ${streamName}, reinitializing`);\n          // Reinitialize with a small delay\n          setTimeout(() => {\n            initializeWebRTCPlayer(streamInfo);\n          }, 100);\n        } catch (error) {\n          console.error('Error fetching stream info:', error);\n\n          // Show error indicator again with new message\n          errorIndicator.style.display = 'flex';\n          errorMsg.textContent = 'Could not reconnect: ' + error.message;\n\n          // Hide loading indicator\n          if (loadingIndicator) {\n            loadingIndicator.style.display = 'none';\n          }\n        }\n      }\n    });\n  };\n\n  /**\n   * Cleanup WebRTC player\n   * @param {string} streamName - Stream name\n   */\n  const cleanupWebRTCPlayer = (streamName) => {\n    console.log(`Cleaning up WebRTC player for stream ${streamName}`);\n\n    // Close and remove the RTCPeerConnection\n    if (webrtcConnections.current[streamName]) {\n      // Create a local reference to the connection before deleting it\n      const connection = webrtcConnections.current[streamName];\n\n      // Abort any pending fetch requests\n      if (connection.abortController) {\n        console.log(`Aborting pending WebRTC requests for stream ${streamName}`);\n        try {\n          connection.abortController.abort();\n        } catch (e) {\n          console.error(`Error aborting WebRTC request for stream ${streamName}:`, e);\n        }\n      }\n\n      // Remove all event listeners to prevent memory leaks\n      if (connection.onicecandidate) connection.onicecandidate = null;\n      if (connection.oniceconnectionstatechange) connection.oniceconnectionstatechange = null;\n      if (connection.onconnectionstatechange) connection.onconnectionstatechange = null;\n      if (connection.ontrack) connection.ontrack = null;\n\n      // Close the connection\n      connection.close();\n\n      // Remove from our reference object\n      delete webrtcConnections.current[streamName];\n\n      console.log(`Closed WebRTC connection for stream ${streamName}`);\n    }\n\n    // Clean up detection polling\n    cleanupDetectionPolling(streamName, detectionIntervals.current);\n  };\n\n  /**\n   * Stop all WebRTC streams\n   */\n  const stopAllWebRTCStreams = () => {\n    console.log('Stopping all WebRTC streams');\n    // Close all RTCPeerConnections\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      cleanupWebRTCPlayer(streamName);\n    });\n    console.log('All WebRTC streams stopped');\n  };\n\n/**\n * Take snapshot of a stream\n * @param {string} streamId - Stream ID\n * @param {Event} event - Click event\n */\nconst takeSnapshot = (streamId, event) => {\n  // Prevent default button behavior\n  if (event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  console.log(`Taking snapshot of stream with ID: ${streamId}`);\n\n  // Find the stream by ID or name\n  let streamName = streamId;\n  const stream = streams.find(s => s.id === streamId || s.name === streamId);\n  if (stream) {\n    streamName = stream.name;\n  }\n\n  if (!streamName) {\n    console.error('Stream name not found for snapshot');\n    showStatusMessage('Cannot take snapshot: Stream not identified');\n    return;\n  }\n\n  // Find the video element\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  if (!videoElement) {\n    console.error('Video element not found for stream:', streamName);\n    showStatusMessage('Cannot take snapshot: Video element not found');\n    return;\n  }\n\n  // Create a canvas element to capture the frame\n  const canvas = document.createElement('canvas');\n  canvas.width = videoElement.videoWidth;\n  canvas.height = videoElement.videoHeight;\n  canvas.style.pointerEvents = 'none'; // Ensure canvas doesn't capture clicks\n\n  // Check if we have valid dimensions\n  if (canvas.width === 0 || canvas.height === 0) {\n    console.error('Invalid video dimensions:', canvas.width, canvas.height);\n    showStatusMessage('Cannot take snapshot: Video not loaded or has invalid dimensions');\n    return;\n  }\n\n  // Draw the current frame to the canvas\n  const ctx = canvas.getContext('2d');\n  ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);\n\n  try {\n    // Save the canvas to global scope for direct access in the overlay\n    window.__snapshotCanvas = canvas;\n\n    // Generate a filename\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = `snapshot-${streamName.replace(/\\s+/g, '-')}-${timestamp}.jpg`;\n    window.__snapshotFileName = fileName;\n\n    // Show the standard preview\n    showSnapshotPreview(canvas.toDataURL('image/jpeg', 0.95), `Snapshot: ${streamName}`);\n\n    // Show success message\n    showStatusMessage('Snapshot taken successfully');\n  } catch (error) {\n    console.error('Error creating snapshot:', error);\n    showStatusMessage('Failed to create snapshot: ' + error.message);\n  }\n};\n\n  /**\n   * Toggle fullscreen mode for a specific stream\n   * @param {string} streamName - Stream name\n   * @param {Event} event - Click event\n   */\n  const toggleStreamFullscreen = (streamName, event) => {\n    // Prevent default button behavior\n    if (event) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (!streamName) {\n      console.error('Stream name not provided for fullscreen toggle');\n      return;\n    }\n\n    console.log(`Toggling fullscreen for stream: ${streamName}`);\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n\n    if (!videoCell) {\n      console.error('Stream not found:', streamName);\n      return;\n    }\n\n    if (!document.fullscreenElement) {\n      console.log('Entering fullscreen mode for video cell');\n      videoCell.requestFullscreen().catch(err => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n      });\n    } else {\n      console.log('Exiting fullscreen mode');\n      document.exitFullscreen();\n    }\n  };\n\n  return (\n    <section id=\"live-page\" className={`page ${isFullscreen ? 'fullscreen-mode' : ''}`}>\n      <div className=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\">\n        <div className=\"flex items-center space-x-2\">\n          <h2 className=\"text-xl font-bold mr-4\">Live View</h2>\n          <div className=\"flex space-x-2\">\n            <button\n              id=\"hls-toggle-btn\"\n              className=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick={() => window.location.href = '/hls.html'}\n            >\n              HLS View\n            </button>\n          </div>\n        </div>\n        <div className=\"controls flex items-center space-x-2\">\n          <div className=\"flex items-center\">\n            <label for=\"layout-selector\" className=\"mr-2\">Layout:</label>\n            <select\n                id=\"layout-selector\"\n                className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                value={layout}\n                onChange={(e) => {\n                  const newLayout = e.target.value;\n                  setLayout(newLayout);\n                  setCurrentPage(0); // Reset to first page when layout changes\n                  // URL will be updated by the useEffect hook\n                }}\n            >\n              <option value=\"1\">1 Stream</option>\n              <option value=\"2\">2 Streams</option>\n              <option value=\"4\" selected>4 Streams</option>\n              <option value=\"6\">6 Streams</option>\n              <option value=\"9\">9 Streams</option>\n              <option value=\"16\">16 Streams</option>\n            </select>\n          </div>\n\n          {layout === '1' && (\n              <div className=\"flex items-center\">\n                <label for=\"stream-selector\" className=\"mr-2\">Stream:</label>\n                <select\n                    id=\"stream-selector\"\n                    className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                    value={selectedStream}\n                    onChange={(e) => {\n                      const newStream = e.target.value;\n                      setSelectedStream(newStream);\n                      // URL will be updated by the useEffect hook\n                    }}\n                >\n                  {streams.map(stream =>\n                      <option key={stream.name} value={stream.name}>{stream.name}</option>\n                  )}\n                </select>\n              </div>\n          )}\n\n          <button\n              id=\"fullscreen-btn\"\n              className=\"p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 focus:outline-none\"\n              onClick={() => toggleFullscreen(isFullscreen, setIsFullscreen)}\n              title=\"Toggle Fullscreen\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\"\n                 stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n              <path\n                  d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path>\n            </svg>\n          </button>\n        </div>\n      </div>\n\n      <div className=\"flex flex-col space-y-4\">\n        <div\n            id=\"video-grid\"\n            className={`video-container layout-${layout}`}\n            ref={videoGridRef}\n        >\n          {isLoadingStreams ? (\n              <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n                <div className=\"flex flex-col items-center justify-center py-8\">\n                  <div\n                      className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                  <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (isLoading && !isLoadingStreams) ? (\n            <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n              <div className=\"flex flex-col items-center justify-center py-8\">\n                <div\n                    className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (streamsError) ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">Error loading streams: {streamsError.message}</p>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\"\n              >\n                Retry\n              </button>\n            </div>\n          ) : streams.length === 0 ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n              <a href=\"streams.html\" className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n            </div>\n          ) : (\n            // Render video cells using our WebRTCVideoCell component\n            getStreamsToShow().map(stream => (\n              <WebRTCVideoCell\n                key={stream.name}\n                stream={stream}\n                onTakeSnapshot={takeSnapshot}\n                onToggleFullscreen={toggleStreamFullscreen}\n                webrtcConnections={webrtcConnections}\n                detectionIntervals={detectionIntervals}\n                initializeWebRTCPlayer={initializeWebRTCPlayer}\n                cleanupWebRTCPlayer={cleanupWebRTCPlayer}\n              />\n            ))\n          )}\n        </div>\n\n        {layout !== '1' && streams.length > getMaxStreamsForLayout() ? (\n          <div className=\"pagination-controls flex justify-center items-center space-x-4 mt-4\">\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to previous page');\n                setCurrentPage(Math.max(0, currentPage - 1));\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                const newPage = currentPage - 1;\n\n                if (newPage > 0) {\n                  url.searchParams.set('page', newPage + 1);\n                  sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n                } else {\n                  url.searchParams.delete('page');\n                  sessionStorage.removeItem('webrtc_current_page');\n                }\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage === 0}\n            >\n              Previous\n            </button>\n\n            <span className=\"text-gray-700 dark:text-gray-300\">\n              Page {currentPage + 1} of {Math.ceil(streams.length / getMaxStreamsForLayout())}\n            </span>\n\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to next page');\n                const newPage = Math.min(Math.ceil(streams.length / getMaxStreamsForLayout()) - 1, currentPage + 1);\n                setCurrentPage(newPage);\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                url.searchParams.set('page', newPage + 1);\n                sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage >= Math.ceil(streams.length / getMaxStreamsForLayout()) - 1}\n            >\n              Next\n            </button>\n          </div>\n        ) : null}\n      </div>\n    </section>\n  );\n}\n","/**\n * LightNVR Web Interface Live View Page\n * Entry point for the live view page with WebRTC/HLS support\n */\n\nimport { render } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { LiveView } from '../components/preact/LiveView.jsx';\nimport { WebRTCView } from '../components/preact/WebRTCView.jsx';\nimport { QueryClientProvider, queryClient } from '../query-client.js';\nimport { Header } from \"../components/preact/Header.jsx\";\nimport { Footer } from \"../components/preact/Footer.jsx\";\n\n/**\n * Main App component that conditionally renders WebRTCView or LiveView\n * based on whether WebRTC is disabled in settings\n */\nfunction App() {\n    const [isWebRTCDisabled, setIsWebRTCDisabled] = useState(false);\n    const [isLoading, setIsLoading] = useState(true);\n\n    useEffect(() => {\n        // Check if WebRTC is disabled in settings\n        async function checkWebRTCStatus() {\n            try {\n                const response = await fetch('/api/settings');\n                if (!response.ok) {\n                    console.error('Failed to fetch settings:', response.status, response.statusText);\n                    setIsLoading(false);\n                    return;\n                }\n\n                const settings = await response.json();\n                \n                if (settings.webrtc_disabled) {\n                    console.log('WebRTC is disabled, using HLS view');\n                    setIsWebRTCDisabled(true);\n                } else {\n                    console.log('WebRTC is enabled, using WebRTC view');\n                    setIsWebRTCDisabled(false);\n                }\n            } catch (error) {\n                console.error('Error checking WebRTC status:', error);\n            } finally {\n                setIsLoading(false);\n            }\n        }\n\n        checkWebRTCStatus();\n    }, []);\n\n    if (isLoading) {\n        return <div className=\"loading\">Loading...</div>;\n    }\n\n    return (\n        <>\n            <Header />\n            {isWebRTCDisabled ? <LiveView isWebRTCDisabled={true} /> : <WebRTCView />}\n            <Footer />\n        </>\n    );\n}\n\n// Render the App component when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Get the container element\n    const container = document.getElementById('main-content');\n\n    if (container) {\n        render(\n            <QueryClientProvider client={queryClient}>\n                <App />\n            </QueryClientProvider>,\n            container\n        );\n    }\n});\n"],"names":["WebRTCView","webrtcOfferMutation","useMutation","data","streamName","offerData","auth","response","text","jsonError","error","variables","streams","setStreams","useState","layout","setLayout","layoutParam","selectedStream","setSelectedStream","streamParam","isFullscreen","setIsFullscreen","isLoading","setIsLoading","currentPage","setCurrentPage","pageParam","storedPage","videoGridRef","useRef","webrtcConnections","detectionIntervals","useEffect","setupModals","addStatusMessageStyles","addModalStyles","handleBeforeUnload","url","connectionCheckInterval","pc","cleanupWebRTCPlayer","stream","s","initializeWebRTCPlayer","stopAllWebRTCStreams","queryClient","useQueryClient","streamsData","isLoadingStreams","streamsError","useQuery","filteredStreams","filterStreamsForWebRTC","showStatusMessage","previousValues","prev","updateVideoGrid","updateURLTimeout","streamPromises","streamId","detailedStreams","getMaxStreamsForLayout","getStreamsToShow","streamsToShow","maxStreams","totalPages","startIdx","endIdx","streamsToShowNames","connectionsToCleanup","videoElement","canvasOverlay","callbacks","event","startDetectionPolling","e","offerOptions","setupTimeoutId","videoPlaybackTimeoutId","checkConnectionExists","offer","sendOffer","answer","useCallback","formattedOffer","abortController","signal","result","connection","cleanupDetectionPolling","takeSnapshot","videoElementId","canvas","timestamp","fileName","showSnapshotPreview","toggleStreamFullscreen","videoCell","err","jsxs","jsx","newLayout","newStream","toggleFullscreen","WebRTCVideoCell","newPage","App","isWebRTCDisabled","setIsWebRTCDisabled","checkWebRTCStatus","Fragment","Header","LiveView","Footer","container","render","QueryClientProvider"],"mappings":"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"}