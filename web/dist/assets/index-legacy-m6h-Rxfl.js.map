{"version":3,"file":"index-legacy-m6h-Rxfl.js","sources":["../../js/components/preact/WebRTCView.jsx","../../js/pages/index-page.jsx"],"sourcesContent":["/**\n * LightNVR Web Interface WebRTCView Component\n * Preact component for the WebRTC view page\n */\n\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { showStatusMessage, showSnapshotPreview, setupModals, addStatusMessageStyles, addModalStyles } from './UI.js';\nimport { toggleFullscreen, exitFullscreenMode } from './FullscreenManager.js';\nimport { startDetectionPolling, cleanupDetectionPolling } from './DetectionOverlay.js';\n\n/**\n * WebRTCView component\n * @returns {JSX.Element} WebRTCView component\n */\nexport function WebRTCView() {\n  const [streams, setStreams] = useState([]);\n  // Initialize layout from URL if available\n  const [layout, setLayout] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get('layout') || '4';\n  });\n  // Initialize selectedStream from URL if available\n  const [selectedStream, setSelectedStream] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get('stream') || '';\n  });\n  const [isFullscreen, setIsFullscreen] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  // Initialize currentPage from URL if available (URL uses 1-based indexing, internal state uses 0-based)\n  const [currentPage, setCurrentPage] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const pageParam = urlParams.get('page');\n    // Convert from 1-based (URL) to 0-based (internal)\n    return pageParam ? Math.max(0, parseInt(pageParam, 10) - 1) : 0;\n  });\n  const videoGridRef = useRef(null);\n  const webrtcConnections = useRef({});\n  const detectionIntervals = useRef({});\n\n  // Set up event listeners and UI components\n  useEffect(() => {\n    // Set up modals for snapshot preview\n    setupModals();\n    addStatusMessageStyles();\n    addModalStyles();\n\n    // Set up periodic connection check\n    const connectionCheckInterval = setInterval(() => {\n      Object.keys(webrtcConnections.current).forEach(streamName => {\n        const pc = webrtcConnections.current[streamName];\n        if (pc) {\n          // Log connection state for debugging\n          console.debug(`WebRTC connection state for ${streamName}: ${pc.connectionState}, ICE state: ${pc.iceConnectionState}`);\n\n          // If connection is failed or disconnected for too long, try to reconnect\n          if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n            console.warn(`WebRTC connection for ${streamName} is in ${pc.iceConnectionState} state, will attempt reconnect`);\n\n            // Clean up the old connection\n            cleanupWebRTCPlayer(streamName);\n\n            // Find the stream info and reinitialize\n            const stream = streams.find(s => s.name === streamName);\n            if (stream) {\n              console.log(`Attempting to reconnect WebRTC for stream ${streamName}`);\n              initializeWebRTCPlayer(stream);\n            }\n          }\n        }\n      });\n    }, 30000); // Check every 30 seconds\n\n    // Cleanup\n    return () => {\n      // No need to remove handleEscape as it's now handled in FullscreenManager.js\n      clearInterval(connectionCheckInterval);\n      stopAllWebRTCStreams();\n    };\n  }, [streams]); // Add streams as dependency to ensure we have the latest stream data\n\n  // Load streams after the component has rendered and videoGridRef is available\n  useEffect(() => {\n      // Set loading state initially\n      setIsLoading(true);\n\n      // Create a timeout to handle potential stalls in loading\n      const timeoutId = setTimeout(() => {\n        console.warn('Stream loading timed out');\n        setIsLoading(false);\n        showStatusMessage('Loading streams timed out. Please try refreshing the page.');\n      }, 15000); // 15 second timeout\n\n      // Load streams from API with timeout handling\n      loadStreams()\n        .then((streamData) => {\n          clearTimeout(timeoutId);\n          if (streamData && streamData.length > 0) {\n            setStreams(streamData);\n\n            // Set selectedStream based on URL parameter if it exists and is valid\n            const urlParams = new URLSearchParams(window.location.search);\n            const streamParam = urlParams.get('stream');\n\n            if (streamParam && streamData.some(stream => stream.name === streamParam)) {\n              // If the stream from URL exists in the loaded streams, use it\n              setSelectedStream(streamParam);\n            } else if (!selectedStream || !streamData.some(stream => stream.name === selectedStream)) {\n              // Otherwise use the first stream if selectedStream is not set or invalid\n              setSelectedStream(streamData[0].name);\n            }\n          } else {\n            console.warn('No streams returned from API');\n          }\n          setIsLoading(false);\n        })\n        .catch((error) => {\n          clearTimeout(timeoutId);\n          console.error('Error loading streams:', error);\n          showStatusMessage('Error loading streams: ' + error.message);\n          setIsLoading(false);\n        });\n  }, []);\n\n  useEffect(() => {\n    updateVideoGrid();\n  }, [layout, selectedStream, streams, currentPage]);\n\n  /**\n   * Load streams from API\n   * @returns {Promise<Array>} Promise resolving to array of streams\n   */\n  const loadStreams = async () => {\n    try {\n      // Create a timeout promise to handle potential stalls\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Request timed out')), 5000); // 5 second timeout\n      });\n\n      // Fetch streams from API with timeout\n      const fetchPromise = fetch('/api/streams');\n      const response = await Promise.race([fetchPromise, timeoutPromise]);\n\n      if (!response.ok) {\n        throw new Error('Failed to load streams');\n      }\n\n      // Create another timeout for the JSON parsing\n      const jsonTimeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('JSON parsing timed out')), 3000); // 3 second timeout\n      });\n\n      const jsonPromise = response.json();\n      const data = await Promise.race([jsonPromise, jsonTimeoutPromise]);\n\n      // For WebRTC view, we need to fetch full details for each stream\n      const streamPromises = (data || []).map(stream => {\n        // Create a timeout promise for this stream's details fetch\n        const detailsTimeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(new Error(`Timeout fetching details for stream ${stream.name}`)), 3000);\n        });\n\n        // Fetch stream details with timeout\n        const detailsFetchPromise = fetch(`/api/streams/${encodeURIComponent(stream.id || stream.name)}`)\n          .then(response => {\n            if (!response.ok) {\n              throw new Error(`Failed to load details for stream ${stream.name}`);\n            }\n            return response.json();\n          });\n\n        // Race the fetch against the timeout\n        return Promise.race([detailsFetchPromise, detailsTimeoutPromise])\n          .catch(error => {\n            console.error(`Error loading details for stream ${stream.name}:`, error);\n            // Return the basic stream info if we can't get details\n            return stream;\n          });\n      });\n\n      const detailedStreams = await Promise.all(streamPromises);\n      console.log('Loaded detailed streams for WebRTC view:', detailedStreams);\n\n      // Filter out streams that are soft deleted, inactive, or not configured for HLS\n      const filteredStreams = detailedStreams.filter(stream => {\n        // Filter out soft deleted streams\n        if (stream.is_deleted) {\n          console.log(`Stream ${stream.name} is soft deleted, filtering out`);\n          return false;\n        }\n\n        // Filter out inactive streams\n        if (!stream.enabled) {\n          console.log(`Stream ${stream.name} is inactive, filtering out`);\n          return false;\n        }\n\n        // Filter out streams not configured for HLS\n        if (!stream.streaming_enabled) {\n          console.log(`Stream ${stream.name} is not configured for HLS, filtering out`);\n          return false;\n        }\n\n        return true;\n      });\n\n      console.log('Filtered streams for WebRTC view:', filteredStreams);\n\n      return filteredStreams || [];\n    } catch (error) {\n      console.error('Error loading streams for WebRTC view:', error);\n      showStatusMessage('Error loading streams: ' + error.message);\n\n      return [];\n    }\n  };\n\n  /**\n   * Get maximum number of streams to display based on layout\n   * @returns {number} Maximum number of streams\n   */\n  const getMaxStreamsForLayout = () => {\n    switch (layout) {\n      case '1': return 1;  // Single view\n      case '2': return 2;  // 2x1 grid\n      case '4': return 4;  // 2x2 grid\n      case '6': return 6;  // 2x3 grid\n      case '9': return 9;  // 3x3 grid\n      case '16': return 16; // 4x4 grid\n      default: return 4;\n    }\n  };\n\n  /**\n   * Update video grid based on layout, streams, and pagination\n   */\n  const updateVideoGrid = () => {\n    if (!videoGridRef.current) return;\n\n    // Clear existing content except placeholder\n    const placeholder = videoGridRef.current.querySelector('.placeholder');\n    videoGridRef.current.innerHTML = '';\n\n    // If placeholder exists and no streams, add it back\n    if (placeholder && streams.length === 0) {\n      videoGridRef.current.appendChild(placeholder);\n      // Remove the overlay after a short delay\n      setTimeout(() => {\n        if (document.body.contains(preventClickOverlay)) {\n          document.body.removeChild(preventClickOverlay);\n        }\n      }, 100);\n      return;\n    }\n\n    // Filter streams based on layout and selected stream\n    let streamsToShow = streams;\n    if (layout === '1' && selectedStream) {\n      streamsToShow = streams.filter(stream => stream.name === selectedStream);\n    } else {\n      // Apply pagination\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      // Ensure current page is valid\n      if (currentPage >= totalPages) {\n        setCurrentPage(Math.max(0, totalPages - 1));\n        return; // Will re-render with corrected page\n      }\n\n      // Get streams for current page\n      const startIdx = currentPage * maxStreams;\n      const endIdx = Math.min(startIdx + maxStreams, streams.length);\n      streamsToShow = streams.slice(startIdx, endIdx);\n    }\n\n    // Get the names of streams that should be shown\n    const streamsToShowNames = streamsToShow.map(stream => stream.name);\n\n    // Clean up connections for streams that are no longer visible\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      if (!streamsToShowNames.includes(streamName)) {\n        console.log(`Cleaning up WebRTC connection for stream ${streamName} as it's not on the current page`);\n        cleanupWebRTCPlayer(streamName);\n      }\n    });\n\n    // Stagger initialization of WebRTC connections\n    streamsToShow.forEach((stream, index) => {\n      // Create video cell immediately for UI responsiveness\n      createVideoCell(stream);\n\n      // Only initialize WebRTC if it's not already connected\n      if (!webrtcConnections.current[stream.name]) {\n        // Stagger the actual WebRTC initialization\n        setTimeout(() => {\n          initializeWebRTCPlayer(stream);\n        }, index * 500); // 500ms delay between each stream initialization\n      } else {\n        console.log(`WebRTC connection for stream ${stream.name} already exists, reusing`);\n      }\n    });\n\n    // Remove the overlay after all cells are created\n    setTimeout(() => {\n      if (document.body.contains(preventClickOverlay)) {\n        document.body.removeChild(preventClickOverlay);\n      }\n    }, 100);\n  };\n\n  /**\n   * Create video cell without initializing WebRTC\n   * @param {Object} stream - Stream object\n   */\n  const createVideoCell = (stream) => {\n    // Ensure we have an ID for the stream (use name as fallback if needed)\n    const streamId = stream.id || stream.name;\n\n    const videoCell = document.createElement('div');\n    videoCell.className = 'video-cell';\n    videoCell.dataset.streamName = stream.name;\n    videoCell.dataset.streamId = streamId;\n    videoCell.style.position = 'relative'; // Create stacking context\n\n    // Create video element\n    const videoElement = document.createElement('video');\n    videoElement.id = `video-${stream.name.replace(/\\s+/g, '-')}`;\n    videoElement.className = 'video-element';\n    videoElement.playsInline = true;\n    videoElement.autoplay = true;\n    videoElement.muted = true;\n    videoElement.style.pointerEvents = 'none'; // Allow clicks to pass through to controls\n\n    // Create loading indicator\n    const loadingIndicator = document.createElement('div');\n    loadingIndicator.className = 'loading-indicator';\n    loadingIndicator.innerHTML = `\n      <div className=\"spinner\"></div>\n      <p>Connecting...</p>\n    `;\n    loadingIndicator.style.position = 'absolute';\n    loadingIndicator.style.top = '0';\n    loadingIndicator.style.left = '0';\n    loadingIndicator.style.width = '100%';\n    loadingIndicator.style.height = '100%';\n    loadingIndicator.style.display = 'flex';\n    loadingIndicator.style.flexDirection = 'column';\n    loadingIndicator.style.justifyContent = 'center';\n    loadingIndicator.style.alignItems = 'center';\n    loadingIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n    loadingIndicator.style.color = 'white';\n    loadingIndicator.style.zIndex = '20'; // Above video but below controls\n    loadingIndicator.style.pointerEvents = 'none'; // Ensure loading indicator doesn't capture clicks\n\n    // Create error indicator (hidden by default)\n    const errorIndicator = document.createElement('div');\n    errorIndicator.className = 'error-indicator';\n    errorIndicator.style.display = 'none';\n    errorIndicator.style.position = 'absolute';\n    errorIndicator.style.top = '0';\n    errorIndicator.style.left = '0';\n    errorIndicator.style.width = '100%';\n    errorIndicator.style.height = '100%';\n    errorIndicator.style.flexDirection = 'column';\n    errorIndicator.style.justifyContent = 'center';\n    errorIndicator.style.alignItems = 'center';\n    errorIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n    errorIndicator.style.color = 'white';\n    errorIndicator.style.zIndex = '20'; // Above video but below controls\n    // We'll set pointerEvents to 'auto' only when it's visible to allow retry button clicks\n\n    // Create stream name overlay\n    const streamNameOverlay = document.createElement('div');\n    streamNameOverlay.className = 'stream-name-overlay';\n    streamNameOverlay.textContent = stream.name;\n    streamNameOverlay.style.position = 'absolute';\n    streamNameOverlay.style.top = '10px';\n    streamNameOverlay.style.left = '10px';\n    streamNameOverlay.style.padding = '5px 10px';\n    streamNameOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n    streamNameOverlay.style.color = 'white';\n    streamNameOverlay.style.borderRadius = '4px';\n    streamNameOverlay.style.fontSize = '14px';\n    streamNameOverlay.style.zIndex = '15'; // Above video but below controls\n    streamNameOverlay.style.pointerEvents = 'none'; // Ensure stream name doesn't capture clicks\n\n    // Create stream controls\n    const streamControls = document.createElement('div');\n    streamControls.className = 'stream-controls';\n    streamControls.innerHTML = `\n      <button class=\"snapshot-btn\" title=\"Take Snapshot\" data-id=\"${streamId}\" data-name=\"${stream.name}\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"></path><circle cx=\"12\" cy=\"13\" r=\"4\"></circle></svg>\n      </button>\n      <button class=\"fullscreen-btn\" title=\"Toggle Fullscreen\" data-id=\"${streamId}\" data-name=\"${stream.name}\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path></svg>\n      </button>\n    `;\n    streamControls.style.position = 'absolute';\n    streamControls.style.bottom = '10px';\n    streamControls.style.right = '10px';\n    streamControls.style.display = 'flex';\n    streamControls.style.gap = '10px';\n    streamControls.style.zIndex = '30'; // Above everything else\n    streamControls.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n    streamControls.style.padding = '5px';\n    streamControls.style.borderRadius = '4px';\n    streamControls.style.pointerEvents = 'auto'; // Ensure clicks are registered\n\n    // Add canvas for detection overlay\n    const canvasOverlay = document.createElement('canvas');\n    canvasOverlay.id = `canvas-${stream.name.replace(/\\s+/g, '-')}`;\n    canvasOverlay.className = 'detection-overlay';\n    canvasOverlay.style.position = 'absolute';\n    canvasOverlay.style.top = '0';\n    canvasOverlay.style.left = '0';\n    canvasOverlay.style.width = '100%';\n    canvasOverlay.style.height = '100%';\n    canvasOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through\n    canvasOverlay.style.zIndex = '5'; // Above video but below controls\n\n    // Assemble the video cell\n    videoCell.appendChild(videoElement);\n    videoCell.appendChild(loadingIndicator);\n    videoCell.appendChild(errorIndicator);\n    videoCell.appendChild(streamNameOverlay);\n    videoCell.appendChild(streamControls);\n    videoCell.appendChild(canvasOverlay);\n\n    // Add to grid\n    videoGridRef.current.appendChild(videoCell);\n\n    // Make sure all buttons have proper z-index and pointer events\n    const allButtons = videoCell.querySelectorAll('button');\n    allButtons.forEach(button => {\n      button.style.position = 'relative';\n      button.style.zIndex = '30';\n      button.style.pointerEvents = 'auto';\n      button.style.cursor = 'pointer';\n      button.style.backgroundColor = 'transparent';\n      button.style.border = 'none';\n      button.style.padding = '5px';\n      button.style.borderRadius = '4px';\n      button.style.color = 'white';\n      button.style.transition = 'background-color 0.2s';\n\n      // Add hover effect\n      button.addEventListener('mouseover', () => {\n        button.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';\n      });\n\n      button.addEventListener('mouseout', () => {\n        button.style.backgroundColor = 'transparent';\n      });\n    });\n\n    // Add event listeners for buttons\n    const snapshotBtn = videoCell.querySelector('.snapshot-btn');\n    if (snapshotBtn) {\n      snapshotBtn.addEventListener('click', (event) => {\n        console.log('Snapshot button clicked for stream:', stream.name);\n        event.preventDefault();\n        event.stopPropagation();\n        takeSnapshot(streamId, event);\n      });\n    }\n\n    const fullscreenBtn = videoCell.querySelector('.fullscreen-btn');\n    if (fullscreenBtn) {\n      fullscreenBtn.addEventListener('click', (event) => {\n        console.log('Fullscreen button clicked for stream:', stream.name);\n        event.preventDefault();\n        event.stopPropagation();\n        toggleStreamFullscreen(stream.name);\n      });\n    }\n  };\n\n  /**\n   * Initialize WebRTC player for a stream\n   * @param {Object} stream - Stream object\n   */\n  const initializeWebRTCPlayer = (stream) => {\n    const videoElementId = `video-${stream.name.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n\n    if (!videoElement || !videoCell) return;\n\n    // Show loading state\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'flex';\n    }\n\n    // Create canvas overlay for detection bounding boxes\n    const canvasId = `canvas-${stream.name.replace(/\\s+/g, '-')}`;\n    let canvasOverlay = document.getElementById(canvasId);\n\n    if (!canvasOverlay) {\n      canvasOverlay = document.createElement('canvas');\n      canvasOverlay.id = canvasId;\n      canvasOverlay.className = 'detection-overlay';\n      canvasOverlay.style.position = 'absolute';\n      canvasOverlay.style.top = '0';\n      canvasOverlay.style.left = '0';\n      canvasOverlay.style.width = '100%';\n      canvasOverlay.style.height = '100%';\n      canvasOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through\n      videoCell.appendChild(canvasOverlay);\n    }\n\n    // Create a new RTCPeerConnection with ICE servers\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ],\n      // Add additional configuration to ensure proper ICE credentials\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'balanced',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'unified-plan'\n    });\n\n    // Store the connection for cleanup\n    webrtcConnections.current[stream.name] = pc;\n\n    // Add event listeners\n    pc.ontrack = (event) => {\n      console.log(`Track received for stream ${stream.name}:`, event);\n      if (event.track.kind === 'video') {\n        videoElement.srcObject = event.streams[0];\n\n        // Hide loading indicator when video starts playing\n        videoElement.onloadeddata = () => {\n          if (loadingIndicator) {\n            loadingIndicator.style.display = 'none';\n          }\n        };\n      }\n    };\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log(`ICE candidate for stream ${stream.name}:`, event.candidate);\n        // go2rtc doesn't use a separate ICE endpoint, so we don't need to send ICE candidates\n      }\n    };\n\n    pc.oniceconnectionstatechange = () => {\n      console.log(`ICE connection state for stream ${stream.name}:`, pc.iceConnectionState);\n      if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n        // Handle connection failure\n        handleWebRTCError(stream.name, 'WebRTC connection failed');\n      }\n    };\n\n    // Add transceivers to ensure we get both audio and video tracks\n    pc.addTransceiver('video', {direction: 'recvonly'});\n    pc.addTransceiver('audio', {direction: 'recvonly'});\n\n    // Create an offer with specific codec requirements\n    const offerOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n\n    // Create a timeout for the entire WebRTC setup process\n    const setupTimeoutId = setTimeout(() => {\n      console.warn(`WebRTC setup timed out for stream ${stream.name}`);\n      handleWebRTCError(stream.name, 'WebRTC setup timed out');\n\n      // Clean up the connection if it exists\n      if (webrtcConnections.current[stream.name]) {\n        cleanupWebRTCPlayer(stream.name);\n      }\n    }, 15000); // 15 second timeout for the entire setup process\n\n    pc.createOffer(offerOptions)\n      .then(offer => {\n        console.log(`Created offer for stream ${stream.name}:`, offer);\n\n        // Log the original SDP to ensure it has ice-ufrag and ice-pwd\n        console.log(`Original SDP for stream ${stream.name}:`, offer.sdp);\n\n        // Check if the SDP has ice-ufrag and ice-pwd\n        if (!offer.sdp.includes('a=ice-ufrag:') || !offer.sdp.includes('a=ice-pwd:')) {\n          console.warn(`SDP for stream ${stream.name} is missing ice-ufrag or ice-pwd!`);\n        }\n\n        // We'll use the original offer without modifications to preserve ice-ufrag and ice-pwd\n        console.log(`Using original offer for stream ${stream.name}`);\n        return pc.setLocalDescription(offer);\n      })\n      .then(() => {\n        console.log(`Set local description for stream ${stream.name}`);\n        // Send the offer to the server\n        return sendOffer(stream.name, pc.localDescription);\n      })\n      .then(answer => {\n        console.log(`Received answer for stream ${stream.name}:`, answer);\n        // Set the remote description\n        return pc.setRemoteDescription(new RTCSessionDescription(answer));\n      })\n      .then(() => {\n        console.log(`Set remote description for stream ${stream.name}`);\n\n        // Clear the setup timeout since we've successfully set up the connection\n        clearTimeout(setupTimeoutId);\n\n        // Start detection polling if detection is enabled for this stream\n        console.log(`Stream ${stream.name} detection settings:`, {\n          detection_based_recording: stream.detection_based_recording,\n          detection_model: stream.detection_model,\n          detection_threshold: stream.detection_threshold\n        });\n\n        if (stream.detection_based_recording && stream.detection_model) {\n          console.log(`Starting detection polling for stream ${stream.name}`);\n          startDetectionPolling(stream.name, canvasOverlay, videoElement, detectionIntervals.current);\n        } else {\n          console.log(`Detection not enabled for stream ${stream.name}`);\n        }\n      })\n      .catch(error => {\n        // Clear the setup timeout\n        clearTimeout(setupTimeoutId);\n\n        console.error(`Error setting up WebRTC for stream ${stream.name}:`, error);\n        handleWebRTCError(stream.name, error.message);\n      });\n  };\n\n  /**\n   * Send WebRTC offer to server\n   * @param {string} streamName - Stream name\n   * @param {RTCSessionDescription} offer - WebRTC offer\n   * @returns {Promise<RTCSessionDescription>} Promise resolving to WebRTC answer\n   */\n  const sendOffer = async (streamName, offer) => {\n    try {\n      // Get auth from localStorage\n      const auth = localStorage.getItem('auth');\n\n      // Send the offer to the server\n      // Format the offer according to go2rtc expectations\n      const formattedOffer = {\n        type: offer.type,\n        sdp: offer.sdp\n      };\n\n      console.log(`Sending formatted offer for stream ${streamName}:`, formattedOffer);\n\n      // Create an AbortController for the fetch request\n      const controller = new AbortController();\n      const signal = controller.signal;\n\n      // Set a timeout to abort the fetch after 8 seconds\n      const timeoutId = setTimeout(() => {\n        console.warn(`Aborting WebRTC offer request for stream ${streamName} due to timeout`);\n        controller.abort();\n      }, 8000);\n\n      try {\n        // Note: Session cookie is automatically included in fetch requests\n        // We only need to add the Authorization header if we have it in localStorage\n        const response = await fetch(`/api/webrtc?src=${encodeURIComponent(streamName)}`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(auth ? { 'Authorization': 'Basic ' + auth } : {})\n          },\n          body: JSON.stringify(formattedOffer),\n          signal: signal\n        });\n\n        // Clear the timeout since the request completed\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          throw new Error(`Failed to send offer: ${response.status} ${response.statusText}`);\n        }\n\n        // Create another AbortController for the JSON parsing\n        const jsonController = new AbortController();\n        const jsonSignal = jsonController.signal;\n\n        // Set a timeout to abort the JSON parsing after 5 seconds\n        const jsonTimeoutId = setTimeout(() => {\n          console.warn(`Aborting JSON parsing for stream ${streamName} due to timeout`);\n          jsonController.abort();\n        }, 5000);\n\n        try {\n          // Use a separate try/catch for the JSON parsing\n          const text = await response.text();\n\n          // Clear the JSON timeout\n          clearTimeout(jsonTimeoutId);\n\n          // Try to parse the JSON\n          try {\n            const answer = JSON.parse(text);\n            return answer;\n          } catch (jsonError) {\n            console.error(`Error parsing JSON for stream ${streamName}:`, jsonError);\n            console.log(`Raw response text: ${text}`);\n            throw new Error(`Failed to parse WebRTC answer: ${jsonError.message}`);\n          }\n        } catch (textError) {\n          // Clear the JSON timeout if it hasn't been cleared yet\n          clearTimeout(jsonTimeoutId);\n\n          if (textError.name === 'AbortError') {\n            throw new Error(`WebRTC answer parsing timed out for stream ${streamName}`);\n          }\n          throw textError;\n        }\n      } catch (fetchError) {\n        // Clear the timeout if it hasn't been cleared yet\n        clearTimeout(timeoutId);\n\n        if (fetchError.name === 'AbortError') {\n          throw new Error(`WebRTC offer request timed out for stream ${streamName}`);\n        }\n        throw fetchError;\n      }\n    } catch (error) {\n      console.error(`Error sending offer for stream ${streamName}:`, error);\n      throw error;\n    }\n  };\n\n  // ICE candidates are handled internally by the browser for go2rtc\n\n  /**\n   * Handle WebRTC error\n   * @param {string} streamName - Stream name\n   * @param {string} message - Error message\n   */\n  const handleWebRTCError = (streamName, message) => {\n    console.error(`WebRTC error for stream ${streamName}:`, message);\n\n    // Find the video cell\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    if (!videoElement) return;\n\n    const videoCell = videoElement.closest('.video-cell');\n    if (!videoCell) return;\n\n    // Hide loading indicator\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'none';\n    }\n\n    // Create error indicator if it doesn't exist\n    let errorIndicator = videoCell.querySelector('.error-indicator');\n    if (!errorIndicator) {\n      errorIndicator = document.createElement('div');\n      errorIndicator.className = 'error-indicator';\n      errorIndicator.style.position = 'absolute';\n      errorIndicator.style.top = '0';\n      errorIndicator.style.left = '0';\n      errorIndicator.style.width = '100%';\n      errorIndicator.style.height = '100%';\n      errorIndicator.style.display = 'flex';\n      errorIndicator.style.flexDirection = 'column';\n      errorIndicator.style.justifyContent = 'center';\n      errorIndicator.style.alignItems = 'center';\n      errorIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n      errorIndicator.style.color = 'white';\n      errorIndicator.style.zIndex = '20'; // Above video but below controls\n      videoCell.appendChild(errorIndicator);\n    }\n\n    errorIndicator.innerHTML = `\n      <div className=\"error-icon\">!</div>\n      <p>${message || 'WebRTC connection failed'}</p>\n      <button className=\"retry-button mt-4 px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Retry</button>\n    `;\n    errorIndicator.style.display = 'flex';\n    errorIndicator.style.pointerEvents = 'auto'; // Enable pointer events when visible to allow retry button clicks\n\n    // Make sure retry button is clickable\n    const retryButton = errorIndicator.querySelector('.retry-button');\n    if (retryButton) {\n      retryButton.style.position = 'relative';\n      retryButton.style.zIndex = '30';\n      retryButton.style.pointerEvents = 'auto';\n\n      retryButton.addEventListener('click', () => {\n        // Show loading indicator\n        if (loadingIndicator) {\n          loadingIndicator.style.display = 'flex';\n        }\n\n        // Hide error indicator\n        errorIndicator.style.display = 'none';\n\n        // Cleanup existing connection\n        cleanupWebRTCPlayer(streamName);\n\n        // Fetch stream info again and reinitialize\n        fetch(`/api/streams/${encodeURIComponent(streamName)}`)\n          .then(response => response.json())\n          .then(streamInfo => {\n            // Reinitialize\n            initializeWebRTCPlayer(streamInfo);\n          })\n          .catch(error => {\n            console.error('Error fetching stream info:', error);\n\n            // Show error indicator again with new message\n            errorIndicator.style.display = 'flex';\n            const errorMsg = errorIndicator.querySelector('p');\n            if (errorMsg) {\n              errorMsg.textContent = 'Could not reconnect: ' + error.message;\n            }\n\n            // Hide loading indicator\n            if (loadingIndicator) {\n              loadingIndicator.style.display = 'none';\n            }\n          });\n      });\n    }\n  };\n\n  /**\n   * Cleanup WebRTC player\n   * @param {string} streamName - Stream name\n   */\n  const cleanupWebRTCPlayer = (streamName) => {\n    // Close and remove the RTCPeerConnection\n    if (webrtcConnections.current[streamName]) {\n      webrtcConnections.current[streamName].close();\n      delete webrtcConnections.current[streamName];\n    }\n\n    // Reset video element\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    if (videoElement) {\n      videoElement.srcObject = null;\n    }\n\n    // Clean up detection polling\n    cleanupDetectionPolling(streamName, detectionIntervals.current);\n  };\n\n  /**\n   * Stop all WebRTC streams\n   */\n  const stopAllWebRTCStreams = () => {\n    // Close all RTCPeerConnections\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      cleanupWebRTCPlayer(streamName);\n    });\n  };\n\n/**\n * Take snapshot of a stream\n * @param {string} streamId - Stream ID\n * @param {Event} event - Click event\n */\nconst takeSnapshot = (streamId, event) => {\n  console.log(`Taking snapshot of stream with ID: ${streamId}`, event);\n\n  // Find the stream by button element\n  const streamElement = document.querySelector(`.snapshot-btn[data-id=\"${streamId}\"]`);\n  let streamName;\n\n  if (streamElement) {\n    // Get the stream name from the data attribute\n    streamName = streamElement.getAttribute('data-name');\n    console.log(`Found stream name from button attribute: ${streamName}`);\n  } else {\n    // If we can't find by data-id (which might be missing in the new UI),\n    // try to find the parent video cell and get the stream name\n    const clickedButton = event ? (event.currentTarget || event.target) : null;\n    console.log('Clicked button:', clickedButton);\n\n    const videoCell = clickedButton ? clickedButton.closest('.video-cell') : null;\n    console.log('Video cell:', videoCell);\n\n    if (videoCell) {\n      streamName = videoCell.dataset.streamName;\n      console.log(`Found stream name from video cell: ${streamName}`);\n    }\n\n    // If still not found, try to find the stream by ID in the streams array\n    if (!streamName) {\n      const stream = streams.find(s => s.id === streamId || s.name === streamId);\n      if (stream) {\n        streamName = stream.name;\n        console.log(`Found stream name from streams array: ${streamName}`);\n      }\n    }\n  }\n\n  if (!streamName) {\n    console.error('Stream name not found for snapshot');\n    showStatusMessage('Cannot take snapshot: Stream not identified');\n    return;\n  }\n\n  // Find the video element\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  if (!videoElement) {\n    console.error('Video element not found for stream:', streamName);\n    showStatusMessage('Cannot take snapshot: Video element not found');\n    return;\n  }\n\n  // Create a canvas element to capture the frame\n  const canvas = document.createElement('canvas');\n  canvas.width = videoElement.videoWidth;\n  canvas.height = videoElement.videoHeight;\n  canvas.style.pointerEvents = 'none'; // Ensure canvas doesn't capture clicks\n\n  // Check if we have valid dimensions\n  if (canvas.width === 0 || canvas.height === 0) {\n    console.error('Invalid video dimensions:', canvas.width, canvas.height);\n    showStatusMessage('Cannot take snapshot: Video not loaded or has invalid dimensions');\n    return;\n  }\n\n  // Draw the current frame to the canvas\n  const ctx = canvas.getContext('2d');\n  ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);\n\n  try {\n    // Save the canvas to global scope for direct access in the overlay\n    window.__snapshotCanvas = canvas;\n\n    // Generate a filename\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = `snapshot-${streamName.replace(/\\s+/g, '-')}-${timestamp}.jpg`;\n    window.__snapshotFileName = fileName;\n\n    // Show the standard preview\n    showSnapshotPreview(canvas.toDataURL('image/jpeg', 0.95), `Snapshot: ${streamName}`);\n\n    // Show success message\n    showStatusMessage('Snapshot taken successfully');\n  } catch (error) {\n    console.error('Error creating snapshot:', error);\n    showStatusMessage('Failed to create snapshot: ' + error.message);\n  }\n};\n\n  /**\n   * Toggle fullscreen mode for a specific stream\n   * @param {string} streamName - Stream name\n   */\n  const toggleStreamFullscreen = (streamName) => {\n    console.log(`Toggling fullscreen for stream: ${streamName}`);\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n\n    if (!videoCell) {\n      console.error('Stream not found:', streamName);\n      return;\n    }\n\n    if (!document.fullscreenElement) {\n      console.log('Entering fullscreen mode for video cell');\n      videoCell.requestFullscreen().catch(err => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n      });\n    } else {\n      console.log('Exiting fullscreen mode');\n      document.exitFullscreen();\n    }\n  };\n\n  return (\n    <section id=\"live-page\" className={`page ${isFullscreen ? 'fullscreen-mode' : ''}`}>\n      <div className=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\">\n        <div className=\"flex items-center space-x-2\">\n          <h2 className=\"text-xl font-bold mr-4\">Live View</h2>\n          <div className=\"flex space-x-2\">\n            <button\n              id=\"hls-toggle-btn\"\n              className=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick={() => window.location.href = '/hls.html'}\n            >\n              HLS View\n            </button>\n          </div>\n        </div>\n        <div className=\"controls flex items-center space-x-2\">\n          <div className=\"flex items-center\">\n            <label for=\"layout-selector\" className=\"mr-2\">Layout:</label>\n            <select\n                id=\"layout-selector\"\n                className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                value={layout}\n                onChange={(e) => {\n                  const newLayout = e.target.value;\n                  setLayout(newLayout);\n                  setCurrentPage(0); // Reset to first page when layout changes\n                  // URL will be updated by the useEffect hook\n                }}\n            >\n              <option value=\"1\">1 Stream</option>\n              <option value=\"2\">2 Streams</option>\n              <option value=\"4\" selected>4 Streams</option>\n              <option value=\"6\">6 Streams</option>\n              <option value=\"9\">9 Streams</option>\n              <option value=\"16\">16 Streams</option>\n            </select>\n          </div>\n\n          {layout === '1' && (\n              <div className=\"flex items-center\">\n                <label for=\"stream-selector\" className=\"mr-2\">Stream:</label>\n                <select\n                    id=\"stream-selector\"\n                    className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                    value={selectedStream}\n                    onChange={(e) => {\n                      const newStream = e.target.value;\n                      setSelectedStream(newStream);\n                      // URL will be updated by the useEffect hook\n                    }}\n                >\n                  {streams.map(stream =>\n                      <option key={stream.name} value={stream.name}>{stream.name}</option>\n                  )}\n                </select>\n              </div>\n          )}\n\n          <button\n              id=\"fullscreen-btn\"\n              className=\"p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 focus:outline-none\"\n              onClick={() => toggleFullscreen(isFullscreen, setIsFullscreen)}\n              title=\"Toggle Fullscreen\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\"\n                 stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n              <path\n                  d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path>\n            </svg>\n          </button>\n        </div>\n      </div>\n\n      <div className=\"flex flex-col space-y-4\">\n        <div\n            id=\"video-grid\"\n            className={`video-container layout-${layout}`}\n            ref={videoGridRef}\n        >\n          {isLoading ? (\n              <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n                <div className=\"flex flex-col items-center justify-center py-8\">\n                  <div\n                      className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                  <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : streams.length === 0 ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n              <a href=\"streams.html\" className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n            </div>\n          ) : null}\n          {/* Video cells will be dynamically added by the updateVideoGrid function */}\n        </div>\n\n        {layout !== '1' && streams.length > getMaxStreamsForLayout() ? (\n          <div className=\"pagination-controls flex justify-center items-center space-x-4 mt-4\">\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => setCurrentPage(Math.max(0, currentPage - 1))}\n              disabled={currentPage === 0}\n            >\n              Previous\n            </button>\n            <span className=\"text-gray-700 dark:text-gray-300\">\n              Page {currentPage + 1} of {Math.ceil(streams.length / getMaxStreamsForLayout())}\n            </span>\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => setCurrentPage(Math.min(Math.ceil(streams.length / getMaxStreamsForLayout()) - 1, currentPage + 1))}\n              disabled={currentPage >= Math.ceil(streams.length / getMaxStreamsForLayout()) - 1}\n            >\n              Next\n            </button>\n          </div>\n        ) : null}\n      </div>\n    </section>\n  );\n}\n","/**\n * LightNVR Web Interface Live View Page\n * Entry point for the live view page with WebRTC/HLS support\n */\n\nimport { render } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { LiveView } from '../components/preact/LiveView.jsx';\nimport { WebRTCView } from '../components/preact/WebRTCView.jsx';\nimport { QueryClientProvider, queryClient } from '../query-client.js';\nimport { Header } from \"../components/preact/Header.jsx\";\nimport { Footer } from \"../components/preact/Footer.jsx\";\n\n/**\n * Main App component that conditionally renders WebRTCView or LiveView\n * based on whether WebRTC is disabled in settings\n */\nfunction App() {\n    const [isWebRTCDisabled, setIsWebRTCDisabled] = useState(false);\n    const [isLoading, setIsLoading] = useState(true);\n\n    useEffect(() => {\n        // Check if WebRTC is disabled in settings\n        async function checkWebRTCStatus() {\n            try {\n                const response = await fetch('/api/settings');\n                if (!response.ok) {\n                    console.error('Failed to fetch settings:', response.status, response.statusText);\n                    setIsLoading(false);\n                    return;\n                }\n\n                const settings = await response.json();\n                \n                if (settings.webrtc_disabled) {\n                    console.log('WebRTC is disabled, using HLS view');\n                    setIsWebRTCDisabled(true);\n                } else {\n                    console.log('WebRTC is enabled, using WebRTC view');\n                    setIsWebRTCDisabled(false);\n                }\n            } catch (error) {\n                console.error('Error checking WebRTC status:', error);\n            } finally {\n                setIsLoading(false);\n            }\n        }\n\n        checkWebRTCStatus();\n    }, []);\n\n    if (isLoading) {\n        return <div className=\"loading\">Loading...</div>;\n    }\n\n    return (\n        <>\n            <Header />\n            {isWebRTCDisabled ? <LiveView isWebRTCDisabled={true} /> : <WebRTCView />}\n            <Footer />\n        </>\n    );\n}\n\n// Render the App component when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Get the container element\n    const container = document.getElementById('main-content');\n\n    if (container) {\n        render(\n            <QueryClientProvider client={queryClient}>\n                <App />\n            </QueryClientProvider>,\n            container\n        );\n    }\n});\n"],"names":["WebRTCView","streams","setStreams","useState","layout","setLayout","URLSearchParams","window","location","search","get","selectedStream","setSelectedStream","isFullscreen","setIsFullscreen","isLoading","setIsLoading","currentPage","setCurrentPage","pageParam","Math","max","parseInt","videoGridRef","useRef","webrtcConnections","detectionIntervals","useEffect","setupModals","addStatusMessageStyles","addModalStyles","connectionCheckInterval","setInterval","Object","keys","current","forEach","streamName","pc","console","debug","connectionState","iceConnectionState","warn","cleanupWebRTCPlayer","stream","find","s","name","log","initializeWebRTCPlayer","clearInterval","stopAllWebRTCStreams","timeoutId","setTimeout","showStatusMessage","loadStreams","then","streamData","clearTimeout","length","streamParam","some","catch","error","message","updateVideoGrid","async","timeoutPromise","Promise","_","reject","Error","fetchPromise","fetch","response","race","ok","jsonTimeoutPromise","jsonPromise","json","streamPromises","map","detailsTimeoutPromise","detailsFetchPromise","encodeURIComponent","id","detailedStreams","all","filteredStreams","filter","is_deleted","enabled","streaming_enabled","getMaxStreamsForLayout","placeholder","querySelector","innerHTML","appendChild","document","body","contains","preventClickOverlay","removeChild","streamsToShow","maxStreams","totalPages","ceil","startIdx","endIdx","min","slice","streamsToShowNames","includes","index","createVideoCell","streamId","videoCell","createElement","className","dataset","style","position","videoElement","replace","playsInline","autoplay","muted","pointerEvents","loadingIndicator","top","left","width","height","display","flexDirection","justifyContent","alignItems","backgroundColor","color","zIndex","errorIndicator","streamNameOverlay","textContent","padding","borderRadius","fontSize","streamControls","bottom","right","gap","canvasOverlay","querySelectorAll","button","cursor","border","transition","addEventListener","snapshotBtn","event","preventDefault","stopPropagation","takeSnapshot","fullscreenBtn","toggleStreamFullscreen","videoElementId","getElementById","closest","canvasId","RTCPeerConnection","iceServers","urls","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","sdpSemantics","ontrack","track","kind","srcObject","onloadeddata","onicecandidate","candidate","oniceconnectionstatechange","handleWebRTCError","addTransceiver","direction","setupTimeoutId","createOffer","offerToReceiveAudio","offerToReceiveVideo","offer","sdp","setLocalDescription","sendOffer","localDescription","answer","setRemoteDescription","RTCSessionDescription","detection_based_recording","detection_model","detection_threshold","startDetectionPolling","auth","localStorage","getItem","formattedOffer","type","controller","AbortController","signal","abort","method","headers","Authorization","JSON","stringify","status","statusText","jsonController","jsonTimeoutId","text","parse","jsonError","textError","fetchError","retryButton","streamInfo","errorMsg","close","cleanupDetectionPolling","streamElement","getAttribute","clickedButton","currentTarget","target","canvas","videoWidth","videoHeight","getContext","drawImage","__snapshotCanvas","timestamp","Date","toISOString","fileName","__snapshotFileName","showSnapshotPreview","toDataURL","fullscreenElement","exitFullscreen","requestFullscreen","err","jsxs","children","jsx","onClick","href","for","value","onChange","e","newLayout","selected","newStream","toggleFullscreen","title","xmlns","viewBox","fill","stroke","d","ref","disabled","App","isWebRTCDisabled","setIsWebRTCDisabled","webrtc_disabled","checkWebRTCStatus","Fragment","Header","LiveView","Footer","container","render","QueryClientProvider","client","queryClient"],"mappings":"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"}