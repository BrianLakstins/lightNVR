{"version":3,"file":"fetch-utils-legacy-DOz1-Xee.js","sources":["../../js/fetch-utils.js"],"sourcesContent":["/**\n * LightNVR Web Interface Fetch Utilities\n * Enhanced fetch API with timeout, cancellation, and retry capabilities\n */\n\n/**\n * Enhanced fetch function with timeout, cancellation, and retry capabilities\n * @param {string} url - The URL to fetch\n * @param {Object} options - Fetch options\n * @param {number} [options.timeout=30000] - Timeout in milliseconds\n * @param {number} [options.retries=1] - Number of retry attempts\n * @param {number} [options.retryDelay=1000] - Delay between retries in milliseconds\n * @param {AbortSignal} [options.signal] - AbortSignal to cancel the request\n * @returns {Promise<Response>} - Fetch response\n */\nexport async function enhancedFetch(url, options = {}) {\n  const {\n    timeout = 30000,\n    retries = 1,\n    retryDelay = 1000,\n    signal: externalSignal,\n    ...fetchOptions\n  } = options;\n\n  // Log the request details\n  console.log(`enhancedFetch: ${fetchOptions.method || 'GET'} ${url}`);\n  console.debug('enhancedFetch options:', {\n    timeout,\n    retries,\n    retryDelay,\n    ...fetchOptions\n  });\n\n  // Create a timeout controller if timeout is specified\n  const timeoutController = new AbortController();\n  let timeoutId;\n  \n  if (timeout) {\n    timeoutId = setTimeout(() => {\n      console.warn(`enhancedFetch: Timeout reached for ${url}, aborting request`);\n      timeoutController.abort();\n    }, timeout);\n  }\n\n  // Create a combined signal if an external signal is provided\n  const signal = externalSignal\n    ? combineSignals(externalSignal, timeoutController.signal)\n    : timeoutController.signal;\n\n  // Add the signal to fetch options\n  const optionsWithSignal = {\n    ...fetchOptions,\n    signal\n  };\n\n  let lastError;\n  let attempt = 0;\n\n  while (attempt <= retries) {\n    try {\n      console.debug(`enhancedFetch: Attempt ${attempt + 1}/${retries + 1} for ${url}`);\n      const response = await fetch(url, optionsWithSignal);\n      \n      // Clear the timeout\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      \n      // Log the response\n      console.log(`enhancedFetch response: ${response.status} ${response.statusText} for ${url}`);\n      \n      // Check if the response is ok\n      if (!response.ok) {\n        throw new Error(`HTTP error ${response.status}: ${response.statusText}`);\n      }\n      \n      return response;\n    } catch (error) {\n      lastError = error;\n      \n      // Clear the timeout\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      \n      // Log the error\n      console.error(`enhancedFetch error (attempt ${attempt + 1}/${retries + 1}):`, error);\n      \n      // If the request was aborted, don't retry\n      if (error.name === 'AbortError') {\n        if (externalSignal && externalSignal.aborted) {\n          console.warn(`enhancedFetch: Request was cancelled by external signal for ${url}`);\n          throw new Error('Request was cancelled');\n        } else {\n          console.warn(`enhancedFetch: Request timed out for ${url}`);\n          throw new Error('Request timed out');\n        }\n      }\n      \n      // If this was the last retry, throw the error\n      if (attempt >= retries) {\n        console.error(`enhancedFetch: All ${retries + 1} attempts failed for ${url}`);\n        break;\n      }\n      \n      // Wait before retrying\n      console.log(`enhancedFetch: Waiting ${retryDelay}ms before retry ${attempt + 1} for ${url}`);\n      await new Promise(resolve => setTimeout(resolve, retryDelay));\n      \n      // Reset the timeout for the next attempt\n      if (timeout) {\n        timeoutController.abort(); // Abort the previous timeout\n        const newTimeoutController = new AbortController();\n        timeoutId = setTimeout(() => {\n          newTimeoutController.abort();\n        }, timeout);\n      }\n      \n      attempt++;\n    }\n  }\n  \n  throw lastError;\n}\n\n/**\n * Combine multiple AbortSignals into one\n * @param {...AbortSignal} signals - Signals to combine\n * @returns {AbortSignal} - Combined signal\n */\nfunction combineSignals(...signals) {\n  const controller = new AbortController();\n  \n  const onAbort = () => {\n    controller.abort();\n    signals.forEach(signal => {\n      signal.removeEventListener('abort', onAbort);\n    });\n  };\n  \n  signals.forEach(signal => {\n    if (signal.aborted) {\n      onAbort();\n    } else {\n      signal.addEventListener('abort', onAbort);\n    }\n  });\n  \n  return controller.signal;\n}\n\n/**\n * Create a request controller for managing fetch requests\n * @returns {Object} - Request controller object\n */\nexport function createRequestController() {\n  const controller = new AbortController();\n  \n  return {\n    signal: controller.signal,\n    abort: () => controller.abort(),\n    isAborted: () => controller.signal.aborted\n  };\n}\n\n/**\n * Fetch JSON data with enhanced fetch\n * @param {string} url - The URL to fetch\n * @param {Object} options - Fetch options\n * @returns {Promise<any>} - Parsed JSON data\n */\nexport async function fetchJSON(url, options = {}) {\n  console.log(`fetchJSON: ${options.method || 'GET'} ${url}`);\n  try {\n    const response = await enhancedFetch(url, options);\n    console.log(`fetchJSON: Parsing JSON response from ${url}`);\n    const data = await response.json();\n    console.log(`fetchJSON: Successfully parsed JSON from ${url}`);\n    return data;\n  } catch (error) {\n    console.error(`fetchJSON: Error fetching or parsing JSON from ${url}:`, error);\n    throw error;\n  }\n}\n"],"names":["async","enhancedFetch","url","options","timeout","retries","retryDelay","signal","externalSignal","fetchOptions","console","log","method","debug","timeoutController","AbortController","timeoutId","setTimeout","warn","abort","signals","controller","onAbort","forEach","removeEventListener","aborted","addEventListener","combineSignals","optionsWithSignal","lastError","attempt","response","fetch","clearTimeout","status","statusText","ok","Error","error","name","Promise","resolve","newTimeoutController","isAborted","data","json"],"mappings":"yEAeOA,eAAeC,EAAcC,EAAKC,EAAU,IACjD,MAAMC,QACJA,EAAU,IAAKC,QACfA,EAAU,EAACC,WACXA,EAAa,IACbC,OAAQC,KACLC,GACDN,EAGJO,QAAQC,IAAI,kBAAkBF,EAAaG,QAAU,SAASV,KAC9DQ,QAAQG,MAAM,yBAA0B,CACtCT,UACAC,UACAC,gBACGG,IAIL,MAAMK,EAAoB,IAAIC,gBAC9B,IAAIC,EAEAZ,IACFY,EAAYC,YAAW,KACrBP,QAAQQ,KAAK,sCAAsChB,uBACnDY,EAAkBK,OAAO,GACxBf,IAIL,MAAMG,EAASC,EAqFjB,YAA2BY,GACzB,MAAMC,EAAa,IAAIN,gBAEjBO,EAAUA,KACdD,EAAWF,QACXC,EAAQG,SAAQhB,IACdA,EAAOiB,oBAAoB,QAASF,EAAQ,GAC5C,EAWJ,OARAF,EAAQG,SAAQhB,IACVA,EAAOkB,QACTH,IAEAf,EAAOmB,iBAAiB,QAASJ,EACvC,IAGSD,EAAWd,MACpB,CAvGMoB,CAAenB,EAAgBM,EAAkBP,QACjDO,EAAkBP,OAGhBqB,EAAoB,IACrBnB,EACHF,UAGF,IAAIsB,EACAC,EAAU,EAEd,KAAOA,GAAWzB,GAChB,IACEK,QAAQG,MAAM,0BAA0BiB,EAAU,KAAKzB,EAAU,SAASH,KAC1E,MAAM6B,QAAiBC,MAAM9B,EAAK0B,GAWlC,GARIZ,GACFiB,aAAajB,GAIfN,QAAQC,IAAI,2BAA2BoB,EAASG,UAAUH,EAASI,kBAAkBjC,MAGhF6B,EAASK,GACZ,MAAU,IAAAC,MAAM,cAAcN,EAASG,WAAWH,EAASI,cAG7D,OAAOJ,CACR,CAAC,MAAOO,GAYP,GAXAT,EAAYS,EAGRtB,GACFiB,aAAajB,GAIfN,QAAQ4B,MAAM,gCAAgCR,EAAU,KAAKzB,EAAU,MAAOiC,GAG3D,eAAfA,EAAMC,KACR,MAAI/B,GAAkBA,EAAeiB,SACnCf,QAAQQ,KAAK,+DAA+DhB,KACtE,IAAImC,MAAM,2BAEhB3B,QAAQQ,KAAK,wCAAwChB,KAC3C,IAAAmC,MAAM,sBAKpB,GAAIP,GAAWzB,EAAS,CACtBK,QAAQ4B,MAAM,sBAAsBjC,EAAU,yBAAyBH,KACvE,KACR,CAOM,GAJAQ,QAAQC,IAAI,0BAA0BL,oBAA6BwB,EAAU,SAAS5B,WAChF,IAAIsC,SAAQC,GAAWxB,WAAWwB,EAASnC,KAG7CF,EAAS,CACXU,EAAkBK,QAClB,MAAMuB,EAAuB,IAAI3B,gBACjCC,EAAYC,YAAW,KACrByB,EAAqBvB,OAAO,GAC3Bf,EACX,CAEM0B,GACN,CAGE,MAAMD,CACR,MAgCO,WACL,MAAMR,EAAa,IAAIN,gBAEvB,MAAO,CACLR,OAAQc,EAAWd,OACnBY,MAAOA,IAAME,EAAWF,QACxBwB,UAAWA,IAAMtB,EAAWd,OAAOkB,QAEvC,QAQOzB,eAAyBE,EAAKC,EAAU,IAC7CO,QAAQC,IAAI,cAAcR,EAAQS,QAAU,SAASV,KACrD,IACE,MAAM6B,QAAiB9B,EAAcC,EAAKC,GAC1CO,QAAQC,IAAI,yCAAyCT,KACrD,MAAM0C,QAAab,EAASc,OAE5B,OADAnC,QAAQC,IAAI,4CAA4CT,KACjD0C,CACR,CAAC,MAAON,GAEP,MADA5B,QAAQ4B,MAAM,kDAAkDpC,KAAQoC,GAClEA,CACV,CACA"}