{"version":3,"file":"timeline-legacy-Tuhdp675.js","sources":["../../js/components/preact/timeline/TimelineControls.jsx","../../js/components/preact/timeline/TimelineRuler.jsx","../../js/components/preact/timeline/TimelineSegments.jsx","../../js/components/preact/timeline/TimelineCursor.jsx","../../js/components/preact/timeline/SpeedControls.jsx","../../js/components/preact/timeline/TimelinePlayer.jsx","../../js/components/preact/timeline/TimelinePage.jsx","../../js/pages/timeline-page.jsx"],"sourcesContent":["/**\n * LightNVR Timeline Controls Component\n * Handles play/pause and zoom controls for the timeline\n */\n\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\nimport { showStatusMessage } from '../ToastContainer.jsx';\n\n/**\n * TimelineControls component\n * @returns {JSX.Element} TimelineControls component\n */\nexport function TimelineControls() {\n  // Local state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      setIsPlaying(state.isPlaying);\n      setZoomLevel(state.zoomLevel);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Toggle playback (play/pause)\n  const togglePlayback = () => {\n    console.log('TimelineControls: togglePlayback called');\n    console.log('TimelineControls: Current state before toggle:', {\n      isPlaying,\n      currentTime: timelineState.currentTime,\n      currentSegmentIndex: timelineState.currentSegmentIndex,\n      segmentsCount: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0\n    });\n\n    if (isPlaying) {\n      pausePlayback();\n    } else {\n      resumePlayback();\n    }\n  };\n\n  // Pause playback\n  const pausePlayback = () => {\n    timelineState.setState({ isPlaying: false });\n\n    // If there's a video player, pause it\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      videoPlayer.pause();\n    }\n  };\n\n  // Resume playback\n  const resumePlayback = () => {\n    // If no segments, show message and return\n    if (!timelineState.timelineSegments || timelineState.timelineSegments.length === 0) {\n      showStatusMessage('No recordings to play', 'warning');\n      return;\n    }\n\n    console.log('TimelineControls: resumePlayback called');\n    console.log('TimelineControls: Current state:', {\n      segments: timelineState.timelineSegments.length,\n      currentSegmentIndex: timelineState.currentSegmentIndex,\n      currentTime: timelineState.currentTime,\n      selectedDate: timelineState.selectedDate\n    });\n\n    // SIMPLIFIED APPROACH: Directly use the current time to find the appropriate segment\n    let segmentToPlay = null;\n    let segmentIndex = -1;\n    let relativeTime = 0;\n\n    // If we have a current time, find the segment that contains it\n    if (timelineState.currentTime !== null) {\n      console.log('TimelineControls: Using current time to find segment:', timelineState.currentTime);\n\n      // First try to find a segment that contains the current time\n      for (let i = 0; i < timelineState.timelineSegments.length; i++) {\n        const segment = timelineState.timelineSegments[i];\n        if (timelineState.currentTime >= segment.start_timestamp &&\n            timelineState.currentTime <= segment.end_timestamp) {\n          segmentToPlay = segment;\n          segmentIndex = i;\n          relativeTime = timelineState.currentTime - segment.start_timestamp;\n          console.log(`TimelineControls: Found segment ${i} containing current time, relative time: ${relativeTime}s`);\n          break;\n        }\n      }\n\n      // If no exact match, find the closest segment\n      if (!segmentToPlay) {\n        let closestIndex = 0;\n        let minDistance = Infinity;\n\n        for (let i = 0; i < timelineState.timelineSegments.length; i++) {\n          const segment = timelineState.timelineSegments[i];\n          const midpoint = (segment.start_timestamp + segment.end_timestamp) / 2;\n          const distance = Math.abs(timelineState.currentTime - midpoint);\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            closestIndex = i;\n          }\n        }\n\n        segmentToPlay = timelineState.timelineSegments[closestIndex];\n        segmentIndex = closestIndex;\n\n        // Calculate the appropriate relative time based on the cursor position\n        if (timelineState.currentTime < segmentToPlay.start_timestamp) {\n          // If cursor is before the segment, start at the beginning\n          relativeTime = 0;\n        } else if (timelineState.currentTime > segmentToPlay.end_timestamp) {\n          // If cursor is after the segment, start at the end\n          relativeTime = segmentToPlay.end_timestamp - segmentToPlay.start_timestamp;\n        } else {\n          // If cursor is within the segment's time range but not exactly matching,\n          // calculate the relative position within the segment\n          relativeTime = timelineState.currentTime - segmentToPlay.start_timestamp;\n        }\n\n        console.log(`TimelineControls: Using closest segment ${closestIndex}, relative time: ${relativeTime}s`);\n      }\n    }\n    // If no current time but we have a valid segment index, use that\n    else if (timelineState.currentSegmentIndex >= 0 &&\n             timelineState.currentSegmentIndex < timelineState.timelineSegments.length) {\n      segmentIndex = timelineState.currentSegmentIndex;\n      segmentToPlay = timelineState.timelineSegments[segmentIndex];\n      relativeTime = 0;\n      console.log(`TimelineControls: Using current segment index ${segmentIndex}`);\n    }\n    // Fall back to the first segment\n    else {\n      segmentIndex = 0;\n      segmentToPlay = timelineState.timelineSegments[0];\n      relativeTime = 0;\n      console.log('TimelineControls: Falling back to first segment');\n    }\n\n    // DIRECT APPROACH: Manually load and play the video\n    console.log(`TimelineControls: Playing segment ${segmentIndex} (ID: ${segmentToPlay.id}) at time ${relativeTime}s`);\n\n    // First update the state\n    timelineState.currentSegmentIndex = segmentIndex;\n\n    // Check if we should preserve the cursor position\n    if (timelineState.preserveCursorPosition) {\n      // If the cursor position is locked, don't change the current time at all\n      console.log(`TimelineControls: Cursor position is locked, keeping current time ${timelineState.currentTime}`);\n    } else {\n      // Make sure we preserve the current time if it's within the segment\n      // This ensures the cursor stays where the user positioned it\n      if (timelineState.currentTime !== null &&\n          timelineState.currentTime >= segmentToPlay.start_timestamp &&\n          timelineState.currentTime <= segmentToPlay.end_timestamp) {\n        // Keep the current time as is - don't reset it\n        console.log(`TimelineControls: Keeping current time ${timelineState.currentTime} within segment`);\n      } else {\n        // Otherwise, set the time based on the calculated relative time\n        timelineState.currentTime = segmentToPlay.start_timestamp + relativeTime;\n        console.log(`TimelineControls: Setting current time to ${timelineState.currentTime} (segment start + ${relativeTime}s)`);\n      }\n    }\n\n    timelineState.isPlaying = true;\n    timelineState.directVideoControl = true; // Set flag to prevent TimelinePlayer interference\n\n    // Notify listeners\n    timelineState.setState({});\n\n    // Keep the directVideoControl flag active longer to ensure no interference\n    const resetDirectControl = () => {\n      console.log('TimelineControls: Resetting directVideoControl flag');\n      timelineState.directVideoControl = false;\n      timelineState.setState({});\n    };\n\n    // Reset the flag after a longer delay\n    setTimeout(resetDirectControl, 3000);\n\n    // Now directly control the video element\n    const videoElement = document.querySelector('#video-player video');\n    if (videoElement) {\n      // Pause any current playback\n      videoElement.pause();\n\n      // Set up event listener for when metadata is loaded\n      const handleMetadataLoaded = () => {\n        console.log(`TimelineControls: Video metadata loaded, setting time to ${relativeTime}s`);\n\n        try {\n          // Log the video duration\n          console.log('TimelineControls: Video metadata', {\n            duration: videoElement.duration,\n            width: videoElement.videoWidth,\n            height: videoElement.videoHeight,\n            segment: segmentToPlay.id,\n            segmentDuration: segmentToPlay.end_timestamp - segmentToPlay.start_timestamp\n          });\n\n          // Set the current time based on the cursor position\n          let timeToSet = relativeTime;\n\n          // Check if we should preserve the cursor position\n          if (timelineState.preserveCursorPosition && timelineState.currentTime !== null) {\n            // Calculate the relative time within the segment\n            if (timelineState.currentTime >= segmentToPlay.start_timestamp &&\n                timelineState.currentTime <= segmentToPlay.end_timestamp) {\n              // If the cursor is within this segment, use its position\n              timeToSet = timelineState.currentTime - segmentToPlay.start_timestamp;\n              console.log(`TimelineControls: Using locked cursor position for playback: ${timeToSet}s`);\n            } else {\n              // If the cursor is outside this segment but we want to preserve its position,\n              // use the beginning or end of the segment based on which is closer\n              const distanceToStart = Math.abs(timelineState.currentTime - segmentToPlay.start_timestamp);\n              const distanceToEnd = Math.abs(timelineState.currentTime - segmentToPlay.end_timestamp);\n\n              if (distanceToStart <= distanceToEnd) {\n                timeToSet = 0; // Use start of segment\n                console.log(`TimelineControls: Cursor outside segment, using start of segment`);\n              } else {\n                timeToSet = segmentToPlay.end_timestamp - segmentToPlay.start_timestamp; // Use end of segment\n                console.log(`TimelineControls: Cursor outside segment, using end of segment`);\n              }\n            }\n          } else if (timelineState.currentTime !== null &&\n                     timelineState.currentTime >= segmentToPlay.start_timestamp &&\n                     timelineState.currentTime <= segmentToPlay.end_timestamp) {\n            // If not preserving cursor position but the current time is within this segment,\n            // still use the relative position from the cursor\n            timeToSet = timelineState.currentTime - segmentToPlay.start_timestamp;\n            console.log(`TimelineControls: Using cursor position for playback: ${timeToSet}s`);\n          }\n\n          // Ensure the time is within valid bounds\n          let validTime = Math.max(0, Math.min(timeToSet, videoElement.duration || 0));\n\n          // If we're very close to the start of the segment but not exactly at the start,\n          // add a small offset to prevent snapping to the start\n          if (validTime > 0 && validTime < 1.0) {\n            // Ensure we're at least 1 second into the segment\n            validTime = 1.0;\n            console.log(`TimelineControls: Adjusting video time to ${validTime}s to prevent snapping to segment start`);\n          }\n\n          console.log(`TimelineControls: Setting video time to ${validTime}s`);\n          videoElement.currentTime = validTime;\n\n          // Start playback with a small delay to avoid conflicts\n          setTimeout(() => {\n            if (timelineState.isPlaying) {\n              console.log('TimelineControls: Starting video playback');\n              videoElement.play().then(() => {\n                console.log('TimelineControls: Video playback started successfully');\n\n                // Set up multiple checks to ensure playback continues\n                const checkPlayback = (attempt = 1) => {\n                  if (attempt > 5) return; // Limit to 5 attempts\n\n                  setTimeout(() => {\n                    if (videoElement.paused && timelineState.isPlaying) {\n                      console.log(`TimelineControls: Video paused unexpectedly (attempt ${attempt}), trying to resume`);\n                      videoElement.play().catch(e => {\n                        console.error(`Error resuming video (attempt ${attempt}):`, e);\n                      });\n\n                      // Try again after a delay\n                      checkPlayback(attempt + 1);\n                    }\n                  }, 500 * attempt); // Increasing delays between attempts\n                };\n\n                // Start the playback checks\n                checkPlayback();\n\n                // Set up a check to ensure the video plays for the full segment duration\n                const segmentDuration = segmentToPlay.end_timestamp - segmentToPlay.start_timestamp;\n                console.log(`TimelineControls: Segment duration: ${segmentDuration}s, video duration: ${videoElement.duration}s`);\n\n                // If the video duration is significantly shorter than the segment duration,\n                // we need to ensure the video plays for the full segment duration\n                if (videoElement.duration < segmentDuration - 1) { // Allow 1 second tolerance\n                  console.log('TimelineControls: Video duration is shorter than segment duration, will monitor playback');\n\n                  // Monitor playback to ensure it continues for the full segment duration\n                  const monitorInterval = setInterval(() => {\n                    if (!timelineState.isPlaying || !videoElement) {\n                      clearInterval(monitorInterval);\n                      return;\n                    }\n\n                    // If we're near the end of the video but not the end of the segment,\n                    // reset to the beginning and continue playing\n                    if (videoElement.currentTime > videoElement.duration - 0.5 &&\n                        relativeTime + videoElement.currentTime < segmentDuration) {\n                      console.log('TimelineControls: Reached end of video but not end of segment, restarting video');\n                      videoElement.currentTime = 0;\n                      videoElement.play().catch(e => {\n                        console.error('Error restarting video:', e);\n                      });\n                    }\n                  }, 500);\n                }\n              }).catch(e => {\n                console.error('Error playing video:', e);\n                showStatusMessage('Error playing video: ' + e.message, 'error');\n              });\n            }\n          }, 100);\n        } catch (error) {\n          console.error('TimelineControls: Error in handleMetadataLoaded:', error);\n        } finally {\n          // Remove the event listener\n          videoElement.removeEventListener('loadedmetadata', handleMetadataLoaded);\n        }\n      };\n\n      // Add the event listener\n      videoElement.addEventListener('loadedmetadata', handleMetadataLoaded);\n\n      // Set the new source\n      console.log(`TimelineControls: Loading video from segment ${segmentToPlay.id}`);\n      videoElement.src = `/api/recordings/play/${segmentToPlay.id}?t=${Date.now()}`;\n      videoElement.load();\n    } else {\n      console.error('TimelineControls: No video element found');\n      showStatusMessage('Error: Video player not found', 'error');\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index) => {\n    // This function will be implemented in the TimelinePlayer component\n    // Here we just update the state\n    timelineState.setState({\n      currentSegmentIndex: index,\n      isPlaying: true\n    });\n  };\n\n  // Zoom in on timeline\n  const zoomIn = () => {\n    if (zoomLevel < 8) {\n      const newZoomLevel = zoomLevel * 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed in: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  // Zoom out on timeline\n  const zoomOut = () => {\n    if (zoomLevel > 1) {\n      const newZoomLevel = zoomLevel / 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed out: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  return (\n    <div className=\"timeline-controls flex justify-between items-center mb-2\">\n      <div className=\"flex items-center\">\n        <button\n          id=\"play-button\"\n          className=\"w-10 h-10 rounded-full bg-green-600 hover:bg-green-700 text-white flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-offset-1 transition-colors shadow-sm mr-2\"\n          onClick={togglePlayback}\n          title={isPlaying ? 'Pause' : 'Play from current position'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            {isPlaying ? (\n              <>\n                {/* Pause icon - two vertical bars */}\n                <rect x=\"6\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n                <rect x=\"14\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n              </>\n            ) : (\n              <>\n                {/* Play icon - triangle */}\n                <path d=\"M8 5.14v14l11-7-11-7z\" fill=\"white\" />\n              </>\n            )}\n          </svg>\n        </button>\n        <span className=\"text-xs text-gray-600 dark:text-gray-300\">Play from current position</span>\n      </div>\n\n      <div className=\"flex items-center gap-1\">\n        <span className=\"text-xs text-gray-600 dark:text-gray-300 mr-1\">Zoom:</span>\n        <button\n          id=\"zoom-out-button\"\n          className=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick={zoomOut}\n          title=\"Zoom Out (Show more time)\"\n          disabled={zoomLevel <= 1}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n        <button\n          id=\"zoom-in-button\"\n          className=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick={zoomIn}\n          title=\"Zoom In (Show less time)\"\n          disabled={zoomLevel >= 8}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n      </div>\n    </div>\n  );\n}\n","/**\n * LightNVR Timeline Ruler Component\n * Displays the time ruler with hour markers\n */\n\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\n\n/**\n * TimelineRuler component\n * @returns {JSX.Element} TimelineRuler component\n */\nexport function TimelineRuler() {\n  // Local state\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineRuler: State update received', {\n        zoomLevel: state.zoomLevel,\n        segmentsCount: state.timelineSegments ? state.timelineSegments.length : 0,\n        currentTime: state.currentTime\n      });\n\n      // Calculate time range based on zoom level\n      const hoursPerView = 24 / state.zoomLevel;\n\n      // Calculate the center hour based on current time or segments\n      let centerHour = 12; // Default to noon\n\n      if (state.currentTime !== null) {\n        // If we have a current time, use it as the center\n        const currentDate = new Date(state.currentTime * 1000);\n        centerHour = currentDate.getHours() + (currentDate.getMinutes() / 60) + (currentDate.getSeconds() / 3600);\n      } else if (state.timelineSegments && state.timelineSegments.length > 0) {\n        // If we have segments but no current time, use the middle of the segments\n        let earliestHour = 24;\n        let latestHour = 0;\n\n        state.timelineSegments.forEach(segment => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n\n          const startHour = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n          const endHour = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n          earliestHour = Math.min(earliestHour, startHour);\n          latestHour = Math.max(latestHour, endHour);\n        });\n\n        centerHour = (earliestHour + latestHour) / 2;\n        console.log('TimelineRuler: Calculated center from segments', { earliestHour, latestHour, centerHour });\n      }\n\n      // Calculate start and end hours based on center and zoom level\n      let newStartHour = Math.max(0, centerHour - (hoursPerView / 2));\n      let newEndHour = Math.min(24, newStartHour + hoursPerView);\n\n      // Adjust start hour if end hour is at the limit\n      if (newEndHour === 24 && hoursPerView < 24) {\n        newStartHour = Math.max(0, 24 - hoursPerView);\n        newEndHour = 24;\n      } else if (newStartHour === 0 && hoursPerView < 24) {\n        newEndHour = Math.min(24, hoursPerView);\n      }\n\n      // Update local state\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setZoomLevel(state.zoomLevel);\n\n      console.log('TimelineRuler: Calculated time range', {\n        newStartHour,\n        newEndHour,\n        hoursPerView,\n        centerHour\n      });\n\n      // Only update global state if the values have actually changed\n      // to prevent infinite recursion\n      if (timelineState.timelineStartHour !== newStartHour ||\n          timelineState.timelineEndHour !== newEndHour) {\n        console.log('TimelineRuler: Updating global state with new time range');\n        timelineState.setState({\n          timelineStartHour: newStartHour,\n          timelineEndHour: newEndHour\n        });\n      }\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Generate hour markers and labels\n  const generateHourMarkers = () => {\n    const markers = [];\n    const hourWidth = 100 / (endHour - startHour);\n\n    // Add hour markers and labels\n    for (let hour = Math.floor(startHour); hour <= Math.ceil(endHour); hour++) {\n      if (hour >= 0 && hour <= 24) {\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n\n        // Add hour marker\n        markers.push(\n          <div\n            key={`tick-${hour}`}\n            className=\"absolute top-0 w-px h-5 bg-gray-500 dark:bg-gray-400\"\n            style={{ left: `${position}%` }}\n          ></div>\n        );\n\n        // Add hour label\n        markers.push(\n          <div\n            key={`label-${hour}`}\n            className=\"absolute top-0 text-xs text-gray-600 dark:text-gray-300 transform -translate-x-1/2\"\n            style={{ left: `${position}%` }}\n          >\n            {hour}:00\n          </div>\n        );\n\n        // Add half-hour marker if not the last hour and we're zoomed in enough\n        if (hour < 24 && zoomLevel >= 2) {\n          const halfHourPosition = ((hour + 0.5 - startHour) / (endHour - startHour)) * 100;\n          markers.push(\n            <div\n              key={`tick-${hour}-30`}\n              className=\"absolute top-2 w-px h-3 bg-gray-400 dark:bg-gray-500\"\n              style={{ left: `${halfHourPosition}%` }}\n            ></div>\n          );\n\n          // Add 15-minute markers if zoomed in even more\n          if (zoomLevel >= 4) {\n            const quarterHourPosition1 = ((hour + 0.25 - startHour) / (endHour - startHour)) * 100;\n            const quarterHourPosition3 = ((hour + 0.75 - startHour) / (endHour - startHour)) * 100;\n\n            markers.push(\n              <div\n                key={`tick-${hour}-15`}\n                className=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\"\n                style={{ left: `${quarterHourPosition1}%` }}\n              ></div>\n            );\n\n            markers.push(\n              <div\n                key={`tick-${hour}-45`}\n                className=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\"\n                style={{ left: `${quarterHourPosition3}%` }}\n              ></div>\n            );\n          }\n        }\n      }\n    }\n\n    return markers;\n  };\n\n  return (\n    <div className=\"timeline-ruler relative w-full h-8 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-600\">\n      {generateHourMarkers()}\n      <div className=\"absolute bottom-0 left-0 text-xs text-gray-500 px-1\">\n        Zoom: {zoomLevel}x ({Math.round(24 / zoomLevel)} hours)\n      </div>\n    </div>\n  );\n}\n","/**\n * LightNVR Timeline Segments Component\n * Displays recording segments on the timeline\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\n\n/**\n * TimelineSegments component\n * @param {Object} props Component props\n * @param {Array} props.segments Array of timeline segments\n * @returns {JSX.Element} TimelineSegments component\n */\nexport function TimelineSegments({ segments: propSegments }) {\n  // Local state\n  const [segments, setSegments] = useState(propSegments || []);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n\n  // Update segments when props change\n  useEffect(() => {\n    console.log(`TimelineSegments: Received segments from props: ${propSegments ? propSegments.length : 0}`);\n    if (propSegments && propSegments.length > 0) {\n      setSegments(propSegments);\n    }\n  }, [propSegments]);\n\n  // Refs\n  const containerRef = useRef(null);\n  const isDragging = useRef(false);\n\n  // Track the last time segments were updated to prevent too frequent updates\n  const lastSegmentsUpdateRef = useRef(0);\n  const lastSegmentsRef = useRef([]);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log(`TimelineSegments: State update received, segments: ${state.timelineSegments ? state.timelineSegments.length : 0}`);\n\n      // Always update segments when they change\n      if (state.timelineSegments) {\n        // Check if segments have changed\n        const segmentsChanged = !lastSegmentsRef.current ||\n                               state.timelineSegments.length !== lastSegmentsRef.current.length ||\n                               JSON.stringify(state.timelineSegments) !== JSON.stringify(lastSegmentsRef.current) ||\n                               state.forceReload;\n\n        if (segmentsChanged) {\n          console.log(`TimelineSegments: Updating segments (${state.timelineSegments.length})`);\n          setSegments(state.timelineSegments);\n          lastSegmentsRef.current = [...state.timelineSegments]; // Create a copy\n          lastSegmentsUpdateRef.current = Date.now();\n        }\n      }\n\n      // Always update these lightweight properties\n      const newStartHour = state.timelineStartHour !== undefined ? state.timelineStartHour : 0;\n      const newEndHour = state.timelineEndHour !== undefined ? state.timelineEndHour : 24;\n\n      console.log(`TimelineSegments: Time range update - startHour: ${newStartHour}, endHour: ${newEndHour}`);\n\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setCurrentSegmentIndex(state.currentSegmentIndex || -1);\n    });\n\n    // Initial load of segments\n    if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n      console.log(`TimelineSegments: Initial load of segments (${timelineState.timelineSegments.length})`);\n      setSegments(timelineState.timelineSegments);\n      lastSegmentsRef.current = [...timelineState.timelineSegments];\n      setCurrentSegmentIndex(timelineState.currentSegmentIndex || 0);\n\n      // Also set the time range\n      if (timelineState.timelineStartHour !== undefined) {\n        setStartHour(timelineState.timelineStartHour);\n      }\n      if (timelineState.timelineEndHour !== undefined) {\n        setEndHour(timelineState.timelineEndHour);\n      }\n\n      lastSegmentsUpdateRef.current = Date.now();\n    }\n\n    return () => unsubscribe();\n  }, []);\n\n  // Set up drag handling\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const handleMouseDown = (e) => {\n      // Only handle clicks on the container itself, not on segments\n      if (e.target === container || e.target.classList.contains('timeline-clickable-area')) {\n        isDragging.current = true;\n        handleTimelineClick(e);\n\n        // Add event listeners for drag\n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n      }\n    };\n\n    const handleMouseMove = (e) => {\n      if (!isDragging.current) return;\n      handleTimelineClick(e);\n    };\n\n    const handleMouseUp = () => {\n      isDragging.current = false;\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n\n    container.addEventListener('mousedown', handleMouseDown);\n\n    return () => {\n      container.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [startHour, endHour, segments]);\n\n  // Handle click on timeline for seeking\n  const handleTimelineClick = (event) => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    // Get click position relative to container\n    const rect = container.getBoundingClientRect();\n    const clickX = event.clientX - rect.left;\n    const containerWidth = rect.width;\n\n    // Calculate time based on click position\n    const clickPercent = clickX / containerWidth;\n    const clickHour = startHour + (clickPercent * (endHour - startHour));\n\n    // Find the segment that contains this time\n    const clickDate = new Date(timelineState.selectedDate);\n    clickDate.setHours(Math.floor(clickHour));\n    clickDate.setMinutes(Math.floor((clickHour % 1) * 60));\n    clickDate.setSeconds(Math.floor(((clickHour % 1) * 60) % 1 * 60));\n\n    const clickTimestamp = clickDate.getTime() / 1000;\n\n    // Always update the current time to where the user clicked\n    // This allows the user to position the cursor anywhere on the timeline\n    timelineState.setState({\n      currentTime: clickTimestamp,\n      prevCurrentTime: timelineState.currentTime,\n      // Don't automatically start playing\n      isPlaying: false\n    });\n\n    // Find segment that contains this timestamp\n    let foundSegment = false;\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n\n      if (clickTimestamp >= startTimestamp && clickTimestamp <= endTimestamp) {\n        console.log(`TimelineSegments: Found segment ${i} containing timestamp`);\n\n        // Update current segment index without starting playback\n        timelineState.setState({\n          currentSegmentIndex: i\n        });\n\n        // Only if the user clicked directly on a segment (not the background),\n        // play that segment starting at the clicked time\n        if (event.target.classList.contains('timeline-segment')) {\n          // Calculate relative time within the segment\n          const relativeTime = clickTimestamp - startTimestamp;\n\n          // Play this segment starting at the clicked time\n          playSegment(i, relativeTime);\n        }\n\n        foundSegment = true;\n        break;\n      }\n    }\n\n    if (!foundSegment) {\n      // If no segment found, don't automatically jump to a different segment\n      // Just leave the cursor where the user clicked\n      timelineState.setState({\n        currentSegmentIndex: -1\n      });\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index, relativeTime = null) => {\n    console.log(`TimelineSegments: playSegment(${index}, ${relativeTime})`);\n\n    if (index < 0 || index >= segments.length) {\n      console.warn(`TimelineSegments: Invalid segment index: ${index}`);\n      return;\n    }\n\n    const segment = segments[index];\n\n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n\n    // Calculate absolute timestamp for currentTime\n    const absoluteTime = relativeTime !== null\n      ? startTimestamp + relativeTime\n      : startTimestamp;\n\n    // First, pause any current playback and reset the segment index\n    timelineState.setState({\n      isPlaying: false,\n      currentSegmentIndex: -1\n    });\n\n    // Force a synchronous DOM update\n    document.body.offsetHeight;\n\n    // Now set the new segment index and start playing\n    setTimeout(() => {\n      timelineState.setState({\n        currentSegmentIndex: index,\n        currentTime: absoluteTime,\n        isPlaying: true,\n        forceReload: true\n      });\n\n      // Force the video player to reload\n      setTimeout(() => {\n        const videoElement = document.querySelector('#video-player video');\n        if (videoElement) {\n          // Pause any current playback\n          videoElement.pause();\n\n          // Clear the source and reload\n          videoElement.removeAttribute('src');\n          videoElement.load();\n\n          // Set the new source\n          videoElement.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n\n          // Set the current time and play\n          videoElement.onloadedmetadata = () => {\n            const seekTime = relativeTime !== null ? relativeTime : 0;\n            videoElement.currentTime = seekTime;\n            videoElement.play().catch(e => console.error('Error playing video:', e));\n          };\n        }\n      }, 50);\n    }, 50);\n  };\n\n  // Render segments\n  const renderSegments = () => {\n    console.log('TimelineSegments: renderSegments called');\n    console.log('TimelineSegments: segments:', segments);\n    console.log('TimelineSegments: startHour:', startHour, 'endHour:', endHour);\n\n    if (!segments || segments.length === 0) {\n      console.log('TimelineSegments: No segments to render');\n      return html`<div class=\"text-center text-red-500 font-bold\">No segments to display</div>`;\n    }\n\n    console.log('TimelineSegments: Rendering segments:', segments.length);\n\n    const visibleSegments = [];\n    const hourMap = new Map();\n\n    // First pass: collect all segments by hour\n    console.log('TimelineSegments: Starting to process segments');\n    let visibleCount = 0;\n    let skippedCount = 0;\n\n    segments.forEach((segment, index) => {\n      // Always use regular timestamps for consistency\n      const startTimestamp = segment.start_timestamp;\n      const endTimestamp = segment.end_timestamp;\n\n      // Convert timestamps to Date objects\n      const startTime = new Date(startTimestamp * 1000);\n      const endTime = new Date(endTimestamp * 1000);\n\n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        skippedCount++;\n        if (index < 5) {\n          console.log(`TimelineSegments: Skipping segment ${index}, startHour=${startHourFloat}, endHour=${endHourFloat}, visible range=${startHour}-${endHour}`);\n        }\n        return;\n      }\n      visibleCount++;\n\n      // Mark each hour that this segment spans\n      const startFloorHour = Math.floor(startHourFloat);\n      const endCeilHour = Math.min(Math.ceil(endHourFloat), 24);\n\n      for (let h = startFloorHour; h < endCeilHour; h++) {\n        if (h >= startHour && h <= endHour) {\n          if (!hourMap.has(h)) {\n            hourMap.set(h, []);\n          }\n          hourMap.get(h).push(index);\n        }\n      }\n    });\n\n    // Preprocess segments to merge adjacent ones\n    const mergedSegments = [];\n    let currentMergedSegment = null;\n\n    // Sort segments by start time\n    const sortedSegments = [...segments].sort((a, b) => {\n      return a.start_timestamp - b.start_timestamp;\n    });\n\n    // Merge adjacent segments (no gap or very small gap)\n    sortedSegments.forEach((segment, index) => {\n      if (!currentMergedSegment) {\n        // First segment\n        currentMergedSegment = { ...segment, originalIndices: [index] };\n      } else {\n        // Check if this segment is adjacent to the current merged segment\n        const segmentStart = segment.start_timestamp;\n        const mergedEnd = currentMergedSegment.end_timestamp;\n\n        // Allow a small gap (1 second) to account for rounding errors\n        const gap = segmentStart - mergedEnd;\n\n        if (gap <= 1) {\n          // Merge with current segment\n          currentMergedSegment.end_timestamp = segment.end_timestamp;\n          currentMergedSegment.originalIndices.push(index);\n\n          // If this segment has detection, mark the merged segment as having detection\n          if (segment.has_detection) {\n            currentMergedSegment.has_detection = true;\n          }\n        } else {\n          // Gap is too large, start a new merged segment\n          mergedSegments.push(currentMergedSegment);\n          currentMergedSegment = { ...segment, originalIndices: [index] };\n        }\n      }\n    });\n\n    // Add the last merged segment\n    if (currentMergedSegment) {\n      mergedSegments.push(currentMergedSegment);\n    }\n\n    // Second pass: add visible segments\n    mergedSegments.forEach((segment, mergedIndex) => {\n      const segStartTimestamp = segment.start_timestamp;\n      const segEndTimestamp = segment.end_timestamp;\n\n      // Convert timestamps to timeline hours using the utility function\n      const startHourFloat = timelineState.timestampToTimelineHour(segStartTimestamp);\n      const endHourFloat = timelineState.timestampToTimelineHour(segEndTimestamp);\n\n      // Log the timestamps and hours for debugging\n      console.log('TimelineSegments: Segment timestamps', {\n        segmentId: segment.id,\n        startTimestamp: segStartTimestamp,\n        endTimestamp: segEndTimestamp,\n        startTimeLocal: new Date(segStartTimestamp * 1000).toLocaleString(),\n        endTimeLocal: new Date(segEndTimestamp * 1000).toLocaleString(),\n        startHourFloat,\n        endHourFloat\n      });\n\n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n\n      // Adjust start and end to fit within visible range\n      const visibleStartHour = Math.max(startHourFloat, startHour);\n      const visibleEndHour = Math.min(endHourFloat, endHour);\n\n      // Calculate position and width as percentages\n      const startPercent = ((visibleStartHour - startHour) / (endHour - startHour)) * 100;\n      const widthPercent = ((visibleEndHour - visibleStartHour) / (endHour - startHour)) * 100;\n\n      // Format duration for tooltip\n      const duration = Math.round(segEndTimestamp - segStartTimestamp);\n      const durationStr = `${duration}s`;\n\n      // Format times for tooltip\n      const startTimeStr = new Date(segStartTimestamp * 1000).toLocaleTimeString();\n      const endTimeStr = new Date(segEndTimestamp * 1000).toLocaleTimeString();\n\n      // Use a consistent height for all segments\n      const heightPercent = 80; // 80% height for all segments\n\n      visibleSegments.push(\n        <div\n          key={`segment-${mergedIndex}`}\n          className={`timeline-segment absolute rounded-sm transition-all duration-200 ${segment.has_detection ? 'bg-red-500' : 'bg-blue-500'}`}\n          style={{\n            left: `${startPercent}%`,\n            width: `${widthPercent}%`,\n            height: `${heightPercent}%`,\n            top: '50%',\n            transform: 'translateY(-50%)'\n          }}\n          title={`${startTimeStr} - ${endTimeStr} (${durationStr})`}\n        ></div>\n      );\n    });\n\n    // Third pass: fill in gaps with clickable areas\n    for (let hour = Math.floor(startHour); hour < Math.ceil(endHour); hour++) {\n      if (!hourMap.has(hour)) {\n        // No segments in this hour, create a clickable area\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        const width = 100 / (endHour - startHour);\n\n        visibleSegments.push(\n          <div\n            key={`clickable-${hour}`}\n            className=\"timeline-clickable-area absolute h-full cursor-pointer\"\n            style={{\n              left: `${position}%`,\n              width: `${width}%`\n            }}\n            data-hour={hour}\n          ></div>\n        );\n      }\n    }\n\n    console.log(`TimelineSegments: Rendering complete. Total: ${segments.length}, Visible: ${visibleCount}, Skipped: ${skippedCount}, Final rendered: ${visibleSegments.length}`);\n    return visibleSegments;\n  };\n\n  return (\n    <div\n      className=\"timeline-segments relative w-full h-16 pt-2\"\n      ref={containerRef}\n    >\n      {renderSegments()}\n    </div>\n  );\n}\n","/**\n * LightNVR Timeline Cursor Component\n * Displays the playback cursor on the timeline\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\n\n/**\n * TimelineCursor component\n * @returns {JSX.Element} TimelineCursor component\n */\nexport function TimelineCursor() {\n  // Local state\n  const [position, setPosition] = useState(0);\n  const [visible, setVisible] = useState(false);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentTime, setCurrentTime] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n\n  // Refs\n  const cursorRef = useRef(null);\n  const containerRef = useRef(null);\n  const dragStartXRef = useRef(0);\n\n  // Debounce function to limit how often a function can be called\n  const debounce = (func, delay) => {\n    let timeoutId;\n    return function(...args) {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      timeoutId = setTimeout(() => {\n        func.apply(this, args);\n      }, delay);\n    };\n  };\n\n  // Create debounced version of updateCursorPosition\n  const debouncedUpdateCursorPosition = useRef(\n    debounce((time, startHr, endHr) => {\n      updateCursorPosition(time, startHr, endHr);\n    }, 100)\n  ).current;\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineCursor: State update received', {\n        currentTime: state.currentTime,\n        startHour: state.timelineStartHour,\n        endHour: state.timelineEndHour,\n        segmentsCount: state.timelineSegments ? state.timelineSegments.length : 0,\n        isDragging: isDragging,\n        userControllingCursor: state.userControllingCursor\n      });\n\n      // Update local state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n\n      // Only update current time if not dragging\n      if (!isDragging && !state.userControllingCursor) {\n        setCurrentTime(state.currentTime);\n        updateTimeDisplay(state.currentTime);\n\n        // Use debounced update for smoother performance\n        debouncedUpdateCursorPosition(state.currentTime, state.timelineStartHour || 0, state.timelineEndHour || 24);\n      }\n    });\n\n    return () => unsubscribe();\n  }, [isDragging, debouncedUpdateCursorPosition]);\n\n  // Set up drag handling\n  useEffect(() => {\n    const cursor = cursorRef.current;\n    if (!cursor) return;\n\n    const handleMouseDown = (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      console.log('TimelineCursor: Mouse down event');\n\n      // Store the starting X position\n      dragStartXRef.current = e.clientX;\n\n      // Set dragging state\n      setIsDragging(true);\n\n      // Set global flags to prevent other components from updating cursor\n      timelineState.userControllingCursor = true;\n      timelineState.preserveCursorPosition = true;\n      timelineState.cursorPositionLocked = true;\n      timelineState.setState({});\n\n      // Add event listeners for drag\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    };\n\n    const handleMouseMove = (e) => {\n      if (!isDragging) return;\n\n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n\n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      setPosition(positionPercent);\n\n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n\n      // Convert hour to timestamp using the utility function\n      const timestamp = timelineState.timelineHourToTimestamp(hour, timelineState.selectedDate);\n\n      // Store the current time locally but don't update the global state yet\n      setCurrentTime(timestamp);\n\n      // Update time display\n      updateTimeDisplay(timestamp);\n    };\n\n    const handleMouseUp = (e) => {\n      if (!isDragging) return;\n\n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n\n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      console.log('TimelineCursor: Mouse up at position', { positionPercent, clickX, containerWidth });\n\n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      console.log('TimelineCursor: Calculated hour', { hour, startHour, endHour, hourRange });\n\n      // Convert hour to timestamp using the utility function\n      const timestamp = timelineState.timelineHourToTimestamp(hour, timelineState.selectedDate);\n\n      console.log('TimelineCursor: Converted hour to timestamp', {\n        hour,\n        localDate: new Date(timestamp * 1000).toLocaleString(),\n        timestamp\n      });\n      console.log('TimelineCursor: Converted to timestamp', {\n        timestamp,\n        dateTime: new Date(timestamp * 1000).toLocaleString(),\n        selectedDate: timelineState.selectedDate\n      });\n\n      console.log('TimelineCursor: Mouse up event');\n\n      // Reset dragging state FIRST\n      setIsDragging(false);\n\n      // Remove event listeners\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n\n      // Reset some flags but keep preserveCursorPosition true\n      // This allows the current update to complete before other components can update the cursor\n      setTimeout(() => {\n        console.log('TimelineCursor: Releasing cursor control but preserving position');\n        timelineState.userControllingCursor = false;\n        // Keep preserveCursorPosition true to prevent position resets\n        // Keep cursorPositionLocked true to prevent automatic updates\n        timelineState.setState({});\n      }, 100);\n\n      // Always update the current time to where the user placed the cursor\n      // This allows the user to position the cursor anywhere on the timeline\n      timelineState.currentTime = timestamp;\n\n      // Add a small buffer to prevent cursor from snapping to segment start\n      // This is especially important for positions near the beginning of segments\n      if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n        // Find the segment that contains this timestamp\n        const segment = timelineState.timelineSegments.find(seg =>\n          timestamp >= seg.start_timestamp && timestamp <= seg.end_timestamp\n        );\n\n        if (segment) {\n          // If we're very close to the start of the segment (within 1 second),\n          // add a small offset to prevent snapping to the start\n          const distanceFromStart = timestamp - segment.start_timestamp;\n          if (distanceFromStart < 1.0) {\n            // Add a small offset (0.5 seconds) to prevent snapping to start\n            const adjustedTime = segment.start_timestamp + 1.0;\n            console.log(`TimelineCursor: Adjusting cursor position from ${timestamp} to ${adjustedTime} to prevent snapping to segment start`);\n            timelineState.currentTime = adjustedTime;\n          }\n        }\n      }\n      timelineState.prevCurrentTime = timelineState.currentTime;\n      timelineState.isPlaying = false;\n\n      // Notify listeners\n      timelineState.setState({});\n\n      // Find segment that contains this timestamp\n      const segments = timelineState.timelineSegments || [];\n      console.log('TimelineCursor: Searching for segment containing timestamp', {\n        timestamp,\n        segmentsCount: segments.length\n      });\n\n      let foundSegment = false;\n      let closestSegment = -1;\n      let minDistance = Infinity;\n\n      // First try to find an exact match\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n        const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n\n        // Log the first few segments for debugging\n        if (i < 3) {\n          console.log(`TimelineCursor: Segment ${i}`, {\n            startTimestamp,\n            endTimestamp,\n            startTime: new Date(startTimestamp * 1000).toLocaleTimeString(),\n            endTime: new Date(endTimestamp * 1000).toLocaleTimeString()\n          });\n        }\n\n        // Check if timestamp is within this segment\n        if (timestamp >= startTimestamp && timestamp <= endTimestamp) {\n          console.log(`TimelineCursor: Found exact match at segment ${i}`);\n          // Update current segment index without changing the time or starting playback\n          timelineState.currentSegmentIndex = i;\n          timelineState.setState({});\n          foundSegment = true;\n          break;\n        }\n\n        // Calculate distance to this segment (for finding closest if no exact match)\n        const midpoint = (startTimestamp + endTimestamp) / 2;\n        const distance = Math.abs(timestamp - midpoint);\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestSegment = i;\n        }\n      }\n\n      // If no exact match found, use the closest segment\n      if (!foundSegment) {\n        if (closestSegment >= 0) {\n          console.log(`TimelineCursor: No exact match, using closest segment ${closestSegment}`);\n          timelineState.currentSegmentIndex = closestSegment;\n          timelineState.setState({});\n        } else {\n          console.log('TimelineCursor: No segments found at all');\n          // Reset current segment index\n          timelineState.currentSegmentIndex = -1;\n          timelineState.setState({});\n        }\n      }\n    };\n\n    // Add event listeners\n    cursor.addEventListener('mousedown', handleMouseDown);\n\n    return () => {\n      cursor.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [cursorRef.current, startHour, endHour, isDragging]);\n\n  // Update cursor position\n  const updateCursorPosition = (time, startHr, endHr) => {\n    console.log('TimelineCursor: updateCursorPosition called', { time, startHr, endHr });\n\n    if (time === null) {\n      console.log('TimelineCursor: No current time, hiding cursor');\n      setVisible(false);\n      return;\n    }\n\n    // Calculate cursor position\n    const date = new Date(time * 1000);\n    const hour = date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n    console.log('TimelineCursor: Calculated hour', { hour, timeString: date.toLocaleTimeString() });\n\n    // Check if the current time is within the visible range\n    if (hour < startHr || hour > endHr) {\n      console.log('TimelineCursor: Time outside visible range, hiding cursor');\n      setVisible(false);\n      return;\n    }\n\n    // Calculate position as percentage\n    const position = ((hour - startHr) / (endHr - startHr)) * 100;\n    console.log('TimelineCursor: Calculated position', { position, hour, startHr, endHr });\n\n    // Update cursor position\n    setPosition(position);\n    setVisible(true);\n  };\n\n  // Update time display\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n\n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n\n    const date = new Date(time * 1000);\n\n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n\n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  // Force the cursor to be visible on initial render\n  useEffect(() => {\n    console.log('TimelineCursor: Initializing cursor position');\n    console.log('TimelineCursor: Initial state', {\n      currentTime: timelineState.currentTime,\n      startHour: timelineState.timelineStartHour,\n      endHour: timelineState.timelineEndHour,\n      segments: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0\n    });\n\n    // Function to initialize cursor\n    const initCursor = () => {\n      console.log('TimelineCursor: Checking timelineState directly', {\n        currentTime: timelineState.currentTime,\n        segmentsLength: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0,\n        currentSegmentIndex: timelineState.currentSegmentIndex\n      });\n\n      if (timelineState.currentTime) {\n        console.log('TimelineCursor: Setting initial cursor position with current time');\n        setVisible(true);\n        updateCursorPosition(\n          timelineState.currentTime,\n          timelineState.timelineStartHour || 0,\n          timelineState.timelineEndHour || 24\n        );\n        return true;\n      } else if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n        // If no current time but we have segments, use the first segment's start time\n        console.log('TimelineCursor: Using first segment start time for cursor');\n        const firstSegment = timelineState.timelineSegments[0];\n        const segmentStartTime = firstSegment.start_timestamp;\n\n        // Update the timeline state with this time - DIRECT ASSIGNMENT\n        console.log('TimelineCursor: Directly setting timelineState properties');\n        timelineState.currentTime = segmentStartTime;\n        timelineState.currentSegmentIndex = 0;\n\n        // Now call setState to notify listeners\n        timelineState.setState({\n          // Empty object just to trigger notification\n        });\n\n        setVisible(true);\n        updateCursorPosition(\n          segmentStartTime,\n          timelineState.timelineStartHour || 0,\n          timelineState.timelineEndHour || 24\n        );\n        return true;\n      }\n      return false;\n    };\n\n    // Try to initialize immediately\n    const initialized = initCursor();\n\n    // If not initialized, try again after a delay\n    if (!initialized) {\n      console.log('TimelineCursor: Initial initialization failed, will retry after delay');\n\n      // Set up multiple attempts with increasing delays\n      const delays = [100, 300, 500, 1000];\n\n      delays.forEach((delay, index) => {\n        setTimeout(() => {\n          if (!visible) {\n            console.log(`TimelineCursor: Retry initialization attempt ${index + 1}`);\n            initCursor();\n          }\n        }, delay);\n      });\n    }\n  }, []);\n\n  return (\n    <div\n      ref={cursorRef}\n      className=\"timeline-cursor absolute top-0 h-full z-50 transition-all duration-100 cursor-ew-resize\"\n      style={{\n        left: `${position}%`,\n        display: visible ? 'block' : 'none',\n        pointerEvents: 'auto',\n        width: '7px',\n        marginLeft: '-3.5px'\n      }}\n    >\n      {/* Invisible wider clickable area */}\n      <div className=\"absolute top-0 bottom-0 left-0 w-full\"></div>\n\n      {/* Skinnier needle with no middle chunk */}\n      <div className=\"absolute top-0 bottom-0 w-0.5 bg-orange-500 left-1/2 transform -translate-x-1/2 pointer-events-none\"></div>\n\n      {/* Top handle (black) */}\n      <div className=\"absolute top-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 -translate-y-1/2 shadow-md pointer-events-none\"></div>\n\n      {/* Bottom handle (black) */}\n      <div className=\"absolute bottom-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 translate-y-1/2 shadow-md pointer-events-none\"></div>\n    </div>\n  );\n}\n","/**\n * LightNVR Speed Controls Component\n * Handles playback speed controls for the timeline\n */\n\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\nimport { showStatusMessage } from '../ToastContainer.jsx';\n\n/**\n * SpeedControls component\n * @returns {JSX.Element} SpeedControls component\n */\nexport function SpeedControls() {\n  // Local state\n  const [currentSpeed, setCurrentSpeed] = useState(1.0);\n\n  // Available speeds\n  const speeds = [0.25, 0.5, 1.0, 1.5, 2.0, 4.0];\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      setCurrentSpeed(state.playbackSpeed);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Set playback speed\n  const setPlaybackSpeed = (speed) => {\n    // Update video playback rate\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      // Set the new playback rate\n      videoPlayer.playbackRate = speed;\n    }\n\n    // Update timeline state\n    timelineState.setState({ playbackSpeed: speed });\n\n    // Show status message\n    showStatusMessage(`Playback speed: ${speed}x`, 'info');\n  };\n\n  return (\n    <div className=\"mt-2 mb-4 p-2 border border-green-500 rounded-lg bg-white dark:bg-gray-800 shadow-sm\">\n      <div className=\"flex flex-col items-center\">\n        <div className=\"text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300\">Playback Speed</div>\n\n        <div className=\"flex flex-wrap justify-center gap-1\">\n          {speeds.map(speed => (\n            <button\n              key={`speed-${speed}`}\n              className={`speed-btn px-2 py-1 text-sm rounded-full ${speed === currentSpeed\n                ? 'bg-green-500 text-white'\n                : 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600'}\n                font-medium transition-all focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-opacity-50`}\n              data-speed={speed}\n              onClick={() => setPlaybackSpeed(speed)}\n            >\n              {speed === 1.0 ? '1× (Normal)' : `${speed}×`}\n            </button>\n          ))}\n        </div>\n\n        <div className=\"mt-1 text-xs font-medium text-green-600 dark:text-green-400\">\n          Current: {currentSpeed}× {currentSpeed === 1.0 ? '(Normal)' : ''}\n        </div>\n      </div>\n    </div>\n  );\n}\n","/**\n * LightNVR Timeline Player Component\n * Handles video playback for the timeline\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\nimport { SpeedControls } from './SpeedControls.jsx';\nimport { showStatusMessage } from '../ToastContainer.jsx';\n\n/**\n * TimelinePlayer component\n * @returns {JSX.Element} TimelinePlayer component\n */\nexport function TimelinePlayer() {\n  // Local state\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [segments, setSegments] = useState([]);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n\n  // Refs\n  const videoRef = useRef(null);\n  const lastTimeUpdateRef = useRef(null);\n  const lastSegmentIdRef = useRef(null);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setCurrentSegmentIndex(state.currentSegmentIndex);\n      setIsPlaying(state.isPlaying);\n      setSegments(state.timelineSegments || []);\n      setPlaybackSpeed(state.playbackSpeed);\n\n      // Handle video playback\n      handleVideoPlayback(state);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Handle video playback based on state changes\n  const handleVideoPlayback = (state) => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    // Check if we have valid segments and segment index\n    if (!state.timelineSegments ||\n        state.timelineSegments.length === 0 ||\n        state.currentSegmentIndex < 0 ||\n        state.currentSegmentIndex >= state.timelineSegments.length) {\n      return;\n    }\n\n    // Get current segment\n    const segment = state.timelineSegments[state.currentSegmentIndex];\n    if (!segment) return;\n\n    // Check if we need to load a new segment\n    const segmentChanged = lastSegmentIdRef.current !== segment.id;\n\n    // IMPORTANT: Only reload if the segment has actually changed\n    // This prevents constant reloading\n    const needsReload = segmentChanged;\n\n    // Calculate relative time within the segment\n    let relativeTime = 0;\n\n    if (state.currentTime !== null) {\n      if (state.currentTime >= segment.start_timestamp && state.currentTime <= segment.end_timestamp) {\n        // If current time is within this segment, calculate the relative position\n        relativeTime = state.currentTime - segment.start_timestamp;\n        console.log(`Current time ${state.currentTime} is within segment ${segment.id}, relative time: ${relativeTime}s`);\n      } else if (state.currentTime < segment.start_timestamp) {\n        // If current time is before this segment, start at the beginning\n        relativeTime = 0;\n        console.log(`Current time ${state.currentTime} is before segment ${segment.id}, starting at beginning`);\n      } else {\n        // If current time is after this segment, start at the end\n        relativeTime = segment.end_timestamp - segment.start_timestamp;\n        console.log(`Current time ${state.currentTime} is after segment ${segment.id}, starting at end`);\n      }\n    }\n\n    // Only update the video if:\n    // 1. We need to load a new segment, OR\n    // 2. The user is dragging the cursor (indicated by a significant time change)\n    const timeChanged = state.prevCurrentTime !== null &&\n                        Math.abs(state.currentTime - state.prevCurrentTime) > 1;\n\n    // Update last segment ID\n    if (segmentChanged) {\n      console.log(`Segment changed from ${lastSegmentIdRef.current} to ${segment.id}`);\n      lastSegmentIdRef.current = segment.id;\n    }\n\n    // Handle playback\n    if (needsReload) {\n      // Load new segment\n      console.log(`Loading new segment ${segment.id} (segmentChanged: ${segmentChanged})`);\n      loadSegment(segment, relativeTime, state.isPlaying);\n    } else if (timeChanged) {\n      // User is dragging the cursor, just update the current time\n      console.log(`Seeking to ${relativeTime}s within current segment`);\n      video.currentTime = relativeTime;\n    } else if (state.isPlaying && video.paused) {\n      // Resume playback if needed\n      video.play().catch(error => {\n        console.error('Error playing video:', error);\n      });\n    } else if (!state.isPlaying && !video.paused) {\n      // Pause playback if needed\n      video.pause();\n    }\n\n    // Update playback speed if needed\n    if (video.playbackRate !== state.playbackSpeed) {\n      video.playbackRate = state.playbackSpeed;\n    }\n  };\n\n  // Load a segment\n  const loadSegment = (segment, seekTime = 0, autoplay = false) => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    console.log(`Loading segment ${segment.id} at time ${seekTime}s, autoplay: ${autoplay}`);\n\n    // Pause current playback\n    video.pause();\n\n    // Set new source with timestamp to prevent caching\n    const recordingUrl = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n\n    // Set up event listeners for the new video\n    const onLoadedMetadata = () => {\n      console.log('Video metadata loaded');\n\n      // Check if the current time is within this segment\n      // If so, use the relative position from the cursor\n      let timeToSet = seekTime;\n\n      // Check if we should preserve the cursor position\n      if (timelineState.preserveCursorPosition && timelineState.currentTime !== null) {\n        // Calculate the relative time within the segment\n        if (timelineState.currentTime >= segment.start_timestamp &&\n            timelineState.currentTime <= segment.end_timestamp) {\n          // If the cursor is within this segment, use its position\n          timeToSet = timelineState.currentTime - segment.start_timestamp;\n          console.log(`TimelinePlayer: Using locked cursor position for playback: ${timeToSet}s`);\n        } else {\n          // If the cursor is outside this segment but we want to preserve its position,\n          // use the beginning or end of the segment based on which is closer\n          const distanceToStart = Math.abs(timelineState.currentTime - segment.start_timestamp);\n          const distanceToEnd = Math.abs(timelineState.currentTime - segment.end_timestamp);\n\n          if (distanceToStart <= distanceToEnd) {\n            timeToSet = 0; // Use start of segment\n            console.log(`TimelinePlayer: Cursor outside segment, using start of segment`);\n          } else {\n            timeToSet = segment.end_timestamp - segment.start_timestamp; // Use end of segment\n            console.log(`TimelinePlayer: Cursor outside segment, using end of segment`);\n          }\n        }\n      } else if (timelineState.currentTime !== null &&\n                 timelineState.currentTime >= segment.start_timestamp &&\n                 timelineState.currentTime <= segment.end_timestamp) {\n        // If not preserving cursor position but the current time is within this segment,\n        // still use the relative position from the cursor\n        timeToSet = timelineState.currentTime - segment.start_timestamp;\n        console.log(`TimelinePlayer: Using cursor position for playback: ${timeToSet}s`);\n      }\n\n      // Set current time, ensuring it's within valid bounds\n      const segmentDuration = segment.end_timestamp - segment.start_timestamp;\n\n      // Add a small buffer for positions near the beginning of the segment\n      // This prevents the cursor from snapping to the start\n      let validSeekTime = Math.min(Math.max(0, timeToSet), segmentDuration);\n\n      // If we're very close to the start of the segment but not exactly at the start,\n      // add a small offset to prevent snapping to the start\n      if (validSeekTime > 0 && validSeekTime < 1.0) {\n        // Ensure we're at least 1 second into the segment\n        validSeekTime = 1.0;\n        console.log(`TimelinePlayer: Adjusting seek time to ${validSeekTime}s to prevent snapping to segment start`);\n      }\n\n      console.log(`TimelinePlayer: Setting video time to ${validSeekTime}s (requested: ${timeToSet}s, segment duration: ${segmentDuration}s)`);\n      video.currentTime = validSeekTime;\n\n      // Set playback speed\n      video.playbackRate = playbackSpeed;\n\n      // Play if needed\n      if (autoplay) {\n        video.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      }\n\n      // Remove event listener\n      video.removeEventListener('loadedmetadata', onLoadedMetadata);\n    };\n\n    // Add event listener for metadata loaded\n    video.addEventListener('loadedmetadata', onLoadedMetadata);\n\n    // Set new source\n    video.src = recordingUrl;\n    video.load();\n  };\n\n  // Handle video ended event\n  const handleEnded = () => {\n    console.log('Video ended');\n\n    // Check if we have a next segment\n    if (currentSegmentIndex < segments.length - 1) {\n      // Play next segment\n      const nextIndex = currentSegmentIndex + 1;\n      console.log(`Playing next segment ${nextIndex}`);\n\n      // Store the current cursor position\n      const wasUserControllingCursor = timelineState.userControllingCursor;\n\n      // Set a flag to indicate we're handling the segment transition\n      // This prevents other components from interfering\n      timelineState.directVideoControl = true;\n\n      // Update timeline state\n      timelineState.setState({\n        currentSegmentIndex: nextIndex,\n        // Only set the current time to the start of the next segment if the user wasn't controlling the cursor\n        // This preserves the cursor position if the user had manually positioned it\n        currentTime: wasUserControllingCursor ? timelineState.currentTime : segments[nextIndex].start_timestamp,\n        isPlaying: true,\n        forceReload: true\n      });\n\n      // Reset the directVideoControl flag after a delay\n      setTimeout(() => {\n        timelineState.directVideoControl = false;\n        timelineState.setState({});\n      }, 1000);\n    } else {\n      // End of all segments\n      console.log('End of all segments');\n\n      // Update timeline state\n      timelineState.setState({\n        isPlaying: false\n      });\n    }\n  };\n\n  // Handle video time update event\n  const handleTimeUpdate = () => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    // Check if we have a valid segment\n    if (currentSegmentIndex < 0 ||\n        !segments ||\n        segments.length === 0 ||\n        currentSegmentIndex >= segments.length) {\n      return;\n    }\n\n    const segment = segments[currentSegmentIndex];\n    if (!segment) return;\n\n    // Calculate current timestamp, handling timezone correctly\n    const currentTime = segment.start_timestamp + video.currentTime;\n\n    // Log the current time for debugging\n    console.log('TimelinePlayer: Current time', {\n      videoTime: video.currentTime,\n      segmentStart: segment.start_timestamp,\n      calculatedTime: currentTime,\n      localTime: new Date(currentTime * 1000).toLocaleString()\n    });\n\n    // Directly update the time display as well\n    updateTimeDisplay(currentTime);\n\n    // Check if the user is controlling the cursor\n    // If so, don't update the timeline state to avoid overriding the user's position\n    if (timelineState.userControllingCursor) {\n      console.log('TimelinePlayer: User is controlling cursor, not updating timeline state');\n      return;\n    }\n\n    // Check if cursor position is locked\n    // If so, don't update the timeline state to preserve the cursor position\n    if (timelineState.cursorPositionLocked) {\n      console.log('TimelinePlayer: Cursor position is locked, not updating timeline state');\n      return;\n    }\n\n    // Check if directVideoControl flag is set\n    // If so, don't update the timeline state to avoid conflicts with TimelineControls\n    if (timelineState.directVideoControl) {\n      console.log('TimelinePlayer: Direct video control active, not updating timeline state');\n      return;\n    }\n\n    // Update timeline state with the current time\n    timelineState.setState({\n      currentTime: currentTime,\n      prevCurrentTime: lastTimeUpdateRef.current\n    });\n\n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n  };\n\n  // Add a direct time display update function\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n\n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n\n    // Convert timestamp to timeline hour\n    const hour = timelineState.timestampToTimelineHour(time);\n\n    // Format time\n    const hours = Math.floor(hour).toString().padStart(2, '0');\n    const minutes = Math.floor((hour % 1) * 60).toString().padStart(2, '0');\n    const seconds = Math.floor(((hour % 1) * 60) % 1 * 60).toString().padStart(2, '0');\n\n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n\n    console.log('TimelinePlayer: Updated time display', {\n      timestamp: time,\n      hour,\n      formatted: `${hours}:${minutes}:${seconds}`,\n      localTime: new Date(time * 1000).toLocaleString()\n    });\n  };\n\n  return (\n    <>\n      <div className=\"timeline-player-container mb-2\" id=\"video-player\">\n        <div className=\"relative w-full bg-black rounded-lg shadow-md\" style={{ aspectRatio: '16/9' }}>\n          <video\n              ref={videoRef}\n              className=\"w-full h-full object-contain\"\n              controls\n              autoPlay={false}\n              muted={false}\n              playsInline\n              onEnded={handleEnded}\n              onTimeUpdate={handleTimeUpdate}\n          ></video>\n\n          {/* Add a message for invalid segments */}\n          <div\n            className={`absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-center p-4 ${currentSegmentIndex >= 0 && segments.length > 0 ? 'hidden' : ''}`}\n          >\n            <div>\n              <p className=\"mb-2\">No valid segment selected.</p>\n              <p className=\"text-sm\">Click on a segment in the timeline or use the play button to start playback.</p>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Playback speed controls */}\n      <SpeedControls />\n    </>\n  );\n}\n","/**\n * LightNVR Timeline Page Component\n * Main component for the timeline view\n */\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { TimelineControls } from './TimelineControls.jsx';\nimport { TimelineRuler } from './TimelineRuler.jsx';\nimport { TimelineSegments } from './TimelineSegments.jsx';\nimport { TimelineCursor } from './TimelineCursor.jsx';\nimport { TimelinePlayer } from './TimelinePlayer.jsx';\nimport { showStatusMessage } from '../ToastContainer.jsx';\nimport { LoadingIndicator } from '../LoadingIndicator.jsx';\nimport { useQuery } from '../../../query-client.js';\n\n// Utility function to convert between timeline hour and timestamp\nfunction timelineHourToTimestamp(hour, selectedDate) {\n  // Get the selected date or today\n  const date = selectedDate ? new Date(selectedDate) : new Date();\n\n  // Reset time components\n  date.setHours(0, 0, 0, 0);\n\n  // Add the hour component (this is in local time)\n  const milliseconds = date.getTime() + (hour * 60 * 60 * 1000);\n\n  // Convert to timestamp (seconds)\n  return Math.floor(milliseconds / 1000);\n}\n\n// Utility function to convert timestamp to timeline hour\nfunction timestampToTimelineHour(timestamp) {\n  const date = new Date(timestamp * 1000);\n  return date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n}\n\n// Global timeline state for child components\nconst timelineState = {\n  streams: [],\n  timelineSegments: [],\n  selectedStream: null,\n  selectedDate: null,\n  isPlaying: false,\n  currentSegmentIndex: -1,\n  zoomLevel: 1, // 1 = 1 hour, 2 = 30 minutes, 4 = 15 minutes\n  timelineStartHour: 0,\n  timelineEndHour: 24,\n  currentTime: null,\n  prevCurrentTime: null,\n  playbackSpeed: 1.0,\n  showOnlySegments: true,\n  forceReload: false,\n  userControllingCursor: false, // New flag to track if user is controlling cursor\n  preserveCursorPosition: false, // New flag to explicitly preserve cursor position\n  cursorPositionLocked: false, // New flag to lock the cursor position during playback\n  // Utility functions for time conversion\n  timelineHourToTimestamp,\n  timestampToTimelineHour,\n  listeners: new Set(),\n\n  // Last time state was updated\n  lastUpdateTime: 0,\n\n  // Pending state updates\n  pendingUpdates: {},\n\n  // Update state and notify listeners\n  setState(newState) {\n    const now = Date.now();\n\n    console.log('timelineState: setState called with', newState);\n    console.log('timelineState: current state before update', {\n      currentTime: this.currentTime,\n      currentSegmentIndex: this.currentSegmentIndex,\n      segmentsLength: this.timelineSegments.length\n    });\n\n    // For time-sensitive updates (like currentTime), we want to batch them\n    // to prevent too many updates in a short period\n    if (newState.currentTime !== undefined &&\n        !newState.currentSegmentIndex &&\n        !newState.isPlaying &&\n        now - this.lastUpdateTime < 250) {\n      // Skip frequent time updates that don't change playback state\n      console.log('timelineState: Skipping frequent time update');\n      return;\n    }\n\n    // Apply the new state\n    Object.assign(this, newState);\n\n    // Reset forceReload flag immediately\n    if (newState.forceReload) {\n      this.forceReload = false;\n    }\n\n    this.lastUpdateTime = now;\n\n    console.log('timelineState: state after update', {\n      currentTime: this.currentTime,\n      currentSegmentIndex: this.currentSegmentIndex,\n      segmentsLength: this.timelineSegments.length\n    });\n\n    this.notifyListeners();\n  },\n\n  // Subscribe to state changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  },\n\n  // Notify all listeners of state change\n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this));\n  },\n\n  // Flush any pending updates\n  flushPendingUpdates() {\n    if (Object.keys(this.pendingUpdates).length > 0) {\n      Object.assign(this, this.pendingUpdates);\n      this.pendingUpdates = {};\n      this.lastUpdateTime = Date.now();\n      this.notifyListeners();\n    }\n  }\n};\n\n/**\n * Format date for input element\n */\nfunction formatDateForInput(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/**\n * Parse URL parameters\n */\nfunction parseUrlParams() {\n  const params = new URLSearchParams(window.location.search);\n  return {\n    stream: params.get('stream') || '',\n    date: params.get('date') || formatDateForInput(new Date())\n  };\n}\n\n/**\n * Update URL parameters\n */\nfunction updateUrlParams(stream, date) {\n  if (!stream) return;\n  const url = new URL(window.location.href);\n  url.searchParams.set('stream', stream);\n  url.searchParams.set('date', date);\n  window.history.replaceState({}, '', url);\n}\n\n/**\n * TimelinePage component\n */\nexport function TimelinePage() {\n  // Get initial values from URL parameters\n  const urlParams = parseUrlParams();\n\n  // State\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamsList, setStreamsList] = useState([]);\n  const [selectedStream, setSelectedStream] = useState(urlParams.stream);\n  const [selectedDate, setSelectedDate] = useState(urlParams.date);\n  const [segments, setSegments] = useState([]);\n\n  // Refs\n  const timelineContainerRef = useRef(null);\n  const initialLoadRef = useRef(false);\n  const flushIntervalRef = useRef(null);\n\n  // Set up periodic flush of pending updates\n  useEffect(() => {\n    // Set up interval to flush pending updates every 200ms\n    flushIntervalRef.current = setInterval(() => {\n      timelineState.flushPendingUpdates();\n    }, 200);\n\n    // Clean up interval on unmount\n    return () => {\n      if (flushIntervalRef.current) {\n        clearInterval(flushIntervalRef.current);\n      }\n    };\n  }, []);\n\n  // Load streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery('streams', '/api/streams', {\n    timeout: 15000, // 15 second timeout\n    retries: 2,     // Retry twice\n    retryDelay: 1000 // 1 second between retries\n  });\n\n  // Handle initial data load when streams are available\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData) && streamsData.length > 0 && !initialLoadRef.current) {\n      console.log('TimelinePage: Streams loaded, initializing data');\n      initialLoadRef.current = true;\n\n      // Update streamsList state\n      setStreamsList(streamsData);\n\n      // Update global state for child components\n      timelineState.setState({ streams: streamsData });\n\n      // Check if the selected stream from URL exists\n      const streamExists = streamsData.some(s => s.name === selectedStream);\n\n      if (streamExists && selectedStream) {\n        console.log(`TimelinePage: Using stream from URL: ${selectedStream}`);\n      } else if (streamsData.length > 0) {\n        // Use first stream if URL stream doesn't exist\n        const firstStream = streamsData[0].name;\n        console.log(`TimelinePage: Using first stream: ${firstStream}`);\n        setSelectedStream(firstStream);\n      }\n    }\n  }, [streamsData]);\n\n  // Handle streams error\n  useEffect(() => {\n    if (streamsError) {\n      console.error('TimelinePage: Error loading streams:', streamsError);\n      showStatusMessage('Error loading streams: ' + streamsError.message, 'error');\n    }\n  }, [streamsError]);\n\n  // Calculate time range for timeline data\n  const getTimeRange = (date) => {\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n\n    const endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n\n    // Format dates for API in ISO format\n    const startTime = startDate.toISOString();\n    const endTime = endDate.toISOString();\n\n    console.log('TimelinePage: Generated time range:', {\n      date,\n      startDate: startDate.toString(),\n      endDate: endDate.toString(),\n      startTime,\n      endTime\n    });\n\n    return {\n      startTime,\n      endTime\n    };\n  };\n\n  // Update URL and global state when stream or date changes\n  useEffect(() => {\n    if (selectedStream) {\n      // Update URL\n      updateUrlParams(selectedStream, selectedDate);\n\n      // Update global state\n      timelineState.setState({\n        selectedStream,\n        selectedDate\n      });\n    }\n  }, [selectedStream, selectedDate]);\n\n  // Get time range for current date\n  const timeRange = getTimeRange(selectedDate);\n  const startTime = timeRange.startTime;\n  const endTime = timeRange.endTime;\n\n  // Construct the URL for the API call\n  const timelineUrl = selectedStream ?\n    `/api/timeline/segments?stream=${encodeURIComponent(selectedStream)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}` :\n    null;\n\n  // Debug the URL being used\n  console.log('TimelinePage: Timeline URL:', timelineUrl);\n\n  // Fetch timeline segments using preact-query\n  const {\n    data: timelineData,\n    isLoading: isLoadingTimeline,\n    error: timelineError,\n    refetch: refetchTimeline\n  } = useQuery(\n    ['timeline-segments', selectedStream, selectedDate],\n    timelineUrl,\n    {\n      timeout: 30000, // 30 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    },\n    {\n      enabled: !!selectedStream, // Only run query if we have a selected stream\n      onSuccess: (data) => {\n        console.log('TimelinePage: Timeline data received:', data);\n        const timelineSegments = data.segments || [];\n        console.log(`TimelinePage: Received ${timelineSegments.length} segments`);\n\n        if (timelineSegments.length === 0) {\n          console.log('TimelinePage: No segments found');\n          setSegments([]);\n\n          // Update global state\n          timelineState.setState({\n            timelineSegments: [],\n            currentSegmentIndex: -1,\n            currentTime: null,\n            isPlaying: false\n          });\n\n          showStatusMessage('No recordings found for the selected date', 'warning');\n          return;\n        }\n\n        // IMPORTANT: Make a deep copy of the segments to avoid reference issues\n        const segmentsCopy = JSON.parse(JSON.stringify(timelineSegments));\n\n        // Log the first few segments for debugging\n        segmentsCopy.slice(0, 3).forEach((segment, i) => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n          console.log(`TimelinePage: Segment ${i} - Start: ${startTime.toLocaleTimeString()}, End: ${endTime.toLocaleTimeString()}`);\n        });\n\n        console.log('TimelinePage: Setting segments');\n        setSegments(segmentsCopy);\n\n        // Force a synchronous DOM update\n        document.body.offsetHeight;\n\n        // Directly update the global state with the segments\n        const firstSegmentStartTime = segmentsCopy[0].start_timestamp;\n\n        console.log('TimelinePage: Setting initial segment and time', {\n          firstSegmentId: segmentsCopy[0].id,\n          startTime: new Date(firstSegmentStartTime * 1000).toLocaleTimeString()\n        });\n\n        // DIRECT ASSIGNMENT to ensure state is properly set\n        console.log('TimelinePage: Directly setting timelineState properties');\n        timelineState.timelineSegments = segmentsCopy;\n        timelineState.currentSegmentIndex = 0;\n        timelineState.currentTime = firstSegmentStartTime;\n        timelineState.prevCurrentTime = firstSegmentStartTime;\n        timelineState.isPlaying = false;\n        timelineState.forceReload = true;\n        timelineState.zoomLevel = 1;\n        timelineState.selectedDate = selectedDate; // Make sure the date is set\n\n        // Now call setState to notify listeners\n        timelineState.setState({\n          // Empty object just to trigger notification\n        });\n\n        console.log('TimelinePage: Updated timelineState with segments');\n\n        // Wait a moment to ensure state is updated, then log the current state\n        setTimeout(() => {\n          console.log('TimelinePage: State after update (delayed check):', {\n            segmentsLength: timelineState.timelineSegments.length,\n            currentSegmentIndex: timelineState.currentSegmentIndex,\n            currentTime: timelineState.currentTime\n          });\n\n          // Force a state update if the state wasn't properly updated\n          if (!timelineState.currentTime || timelineState.currentSegmentIndex === -1) {\n            console.log('TimelinePage: State not properly updated, forcing update');\n            timelineState.setState({\n              currentSegmentIndex: 0,\n              currentTime: firstSegmentStartTime,\n              prevCurrentTime: firstSegmentStartTime\n            });\n          }\n        }, 100);\n\n        // Preload the first segment's video\n        const videoPlayer = document.querySelector('#video-player video');\n        if (videoPlayer) {\n          videoPlayer.src = `/api/recordings/play/${segmentsCopy[0].id}?t=${Date.now()}`;\n          videoPlayer.load();\n        }\n\n        showStatusMessage(`Loaded ${segmentsCopy.length} recording segments`, 'success');\n      },\n      onError: (error) => {\n        console.error('TimelinePage: Error loading timeline data:', error);\n        console.error('TimelinePage: Error details:', {\n          message: error.message,\n          status: error.status,\n          statusText: error.statusText,\n          response: error.response\n        });\n        showStatusMessage('Error loading timeline data: ' + error.message, 'error');\n        setSegments([]);\n      }\n    }\n  );\n\n  // Handle stream selection change\n  const handleStreamChange = (e) => {\n    const newStream = e.target.value;\n    console.log(`TimelinePage: Stream changed to ${newStream}`);\n    setSelectedStream(newStream);\n  };\n\n  // Handle date selection change\n  const handleDateChange = (e) => {\n    const newDate = e.target.value;\n    console.log(`TimelinePage: Date changed to ${newDate}`);\n    setSelectedDate(newDate);\n  };\n\n  // Render content based on state\n  const renderContent = () => {\n    if (isLoadingTimeline) {\n      return <LoadingIndicator message=\"Loading timeline data...\" />;\n    }\n\n    if (segments.length === 0) {\n      return (\n        <div className=\"flex flex-col items-center justify-center py-12 text-center\">\n          <svg className=\"w-16 h-16 text-gray-400 dark:text-gray-600 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path>\n          </svg>\n          <p className=\"text-gray-600 dark:text-gray-400 text-lg\">No recordings found for the selected date and stream</p>\n        </div>\n      );\n    }\n\n    return (\n      <>\n        {/* Video player */}\n        <TimelinePlayer />\n\n        {/* Playback controls */}\n        <TimelineControls />\n\n        {/* Timeline */}\n        <div\n          id=\"timeline-container\"\n          className=\"relative w-full h-24 bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg mb-6 overflow-hidden\"\n          ref={timelineContainerRef}\n        >\n          <TimelineRuler />\n          <TimelineSegments segments={segments} />\n          <TimelineCursor />\n\n          {/* Instructions for cursor */}\n          <div className=\"absolute bottom-1 right-2 text-xs text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 px-2 py-1 rounded\">\n            Drag the orange dial to navigate\n          </div>\n        </div>\n      </>\n    );\n  };\n\n  return (\n    <div className=\"timeline-page\">\n      <div className=\"flex items-center mb-4\">\n        <h1 className=\"text-2xl font-bold\">Timeline Playback</h1>\n        <div className=\"ml-4 flex\">\n          <a href=\"recordings.html\" className=\"px-3 py-1 bg-gray-300 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-l-md\">Table View</a>\n          <a href=\"timeline.html\" className=\"px-3 py-1 bg-blue-500 text-white rounded-r-md\">Timeline View</a>\n        </div>\n      </div>\n\n      {/* Stream selector and date picker */}\n      <div className=\"flex flex-wrap gap-4 mb-2\">\n        <div className=\"stream-selector flex-grow\">\n          <div className=\"flex justify-between items-center mb-2\">\n            <label htmlFor=\"stream-selector\">Stream</label>\n            <button\n              className=\"text-xs bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 px-2 py-1 rounded\"\n              onClick={() => refetchTimeline()}\n            >\n              Reload Data\n            </button>\n          </div>\n          <select\n            id=\"stream-selector\"\n            className=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n            value={selectedStream || ''}\n            onChange={handleStreamChange}\n          >\n            <option value=\"\" disabled>Select a stream ({streamsList.length} available)</option>\n            {streamsList.map(stream => (\n              <option key={stream.name} value={stream.name}>{stream.name}</option>\n            ))}\n          </select>\n        </div>\n\n        <div className=\"date-selector flex-grow\">\n          <label htmlFor=\"timeline-date\" className=\"block mb-2\">Date</label>\n          <input\n            type=\"date\"\n            id=\"timeline-date\"\n            className=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n            value={selectedDate}\n            onChange={handleDateChange}\n          />\n        </div>\n      </div>\n\n      {/* Auto-load message */}\n      <div className=\"mb-4 text-sm text-gray-500 dark:text-gray-400 italic\">\n        {isLoadingTimeline ? 'Loading...' : 'Recordings auto-load when stream or date changes'}\n      </div>\n\n      {/* Current time display */}\n      <div className=\"flex justify-between items-center mb-2\">\n        <div id=\"time-display\" className=\"timeline-time-display bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded font-mono text-base\">00:00:00</div>\n      </div>\n\n      {/* Debug info */}\n      <div className=\"mb-2 text-xs text-gray-500\">\n        Debug - isLoading: {isLoadingTimeline ? 'true' : 'false'},\n        Streams: {streamsList.length},\n        Segments: {segments.length}\n      </div>\n\n      {/* Content */}\n      {renderContent()}\n\n      {/* Instructions */}\n      <div className=\"mt-6 p-4 bg-gray-200 dark:bg-gray-800 rounded\">\n        <h3 className=\"text-lg font-semibold mb-2\">How to use the timeline:</h3>\n        <ul className=\"list-disc pl-5\">\n          <li>Select a stream and date to load recordings</li>\n          <li>Click on the timeline to position the cursor at a specific time</li>\n          <li>Drag the orange cursor to navigate precisely</li>\n          <li>Click on a segment (blue bar) to play that recording</li>\n          <li>Use the play button to start playback from the current cursor position</li>\n          <li>Use the zoom buttons to adjust the timeline scale</li>\n        </ul>\n      </div>\n    </div>\n  );\n}\n\n// Export the timeline state for use in other components\nexport { timelineState };\n","/**\n * LightNVR Web Interface Users Page\n * Entry point for the users page\n */\n\nimport { render } from 'preact';\nimport { TimelinePage } from '../components/preact/timeline/TimelinePage.jsx';\nimport { QueryClientProvider, queryClient } from '../query-client.js';\nimport {Header} from \"../components/preact/Header.jsx\";\nimport {Footer} from \"../components/preact/Footer.jsx\";\nimport { ToastContainer } from \"../components/preact/ToastContainer.jsx\";\n\n// Render the UsersView component when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Get the container element\n    const container = document.getElementById('main-content');\n\n    if (container) {\n        render(\n            <QueryClientProvider client={queryClient}>\n                <Header />\n                <ToastContainer />\n                <TimelinePage />\n                <Footer />\n            </QueryClientProvider>,\n            container\n        );\n    }\n});\n"],"names":["TimelineControls","isPlaying","setIsPlaying","useState","zoomLevel","setZoomLevel","useEffect","unsubscribe","timelineState","subscribe","state","pausePlayback","setState","videoPlayer","document","querySelector","pause","resumePlayback","timelineSegments","length","showStatusMessage","console","log","segments","currentSegmentIndex","currentTime","selectedDate","segmentToPlay","segmentIndex","relativeTime","i","segment","start_timestamp","end_timestamp","closestIndex","minDistance","Infinity","midpoint","distance","Math","abs","id","preserveCursorPosition","directVideoControl","setTimeout","resetDirectControl","videoElement","handleMetadataLoaded","duration","width","videoWidth","height","videoHeight","segmentDuration","timeToSet","distanceToStart","validTime","max","min","play","then","checkPlayback","attempt","paused","catch","e","error","monitorInterval","setInterval","clearInterval","message","removeEventListener","addEventListener","src","Date","now","load","jsxs","className","children","jsx","onClick","togglePlayback","segmentsCount","title","xmlns","fill","viewBox","stroke","Fragment","x","y","rx","d","zoomOut","newZoomLevel","disabled","strokeLinecap","strokeLinejoin","strokeWidth","zoomIn","TimelineRuler","startHour","setStartHour","endHour","setEndHour","hoursPerView","centerHour","currentDate","getHours","getMinutes","getSeconds","earliestHour","latestHour","forEach","startTime","endTime","newStartHour","newEndHour","timelineStartHour","timelineEndHour","generateHourMarkers","markers","hour","floor","ceil","position","push","style","left","halfHourPosition","quarterHourPosition1","quarterHourPosition3","round","TimelineSegments","propSegments","setSegments","setCurrentSegmentIndex","containerRef","useRef","isDragging","lastSegmentsUpdateRef","lastSegmentsRef","current","JSON","stringify","forceReload","container","handleMouseDown","target","classList","contains","handleTimelineClick","handleMouseMove","handleMouseUp","event","rect","getBoundingClientRect","clickX","clientX","containerWidth","clickHour","clickDate","setHours","setMinutes","setSeconds","clickTimestamp","getTime","prevCurrentTime","foundSegment","startTimestamp","local_start_timestamp","endTimestamp","local_end_timestamp","playSegment","index","warn","absoluteTime","body","offsetHeight","removeAttribute","onloadedmetadata","seekTime","ref","renderSegments","html","visibleSegments","hourMap","Map","visibleCount","skippedCount","startHourFloat","endHourFloat","startFloorHour","endCeilHour","h","has","set","get","mergedSegments","currentMergedSegment","sort","a","b","originalIndices","has_detection","mergedIndex","segStartTimestamp","segEndTimestamp","timestampToTimelineHour","segmentId","startTimeLocal","toLocaleString","endTimeLocal","visibleStartHour","visibleEndHour","startPercent","widthPercent","durationStr","startTimeStr","toLocaleTimeString","endTimeStr","top","transform","TimelineCursor","setPosition","visible","setVisible","setCurrentTime","setIsDragging","cursorRef","dragStartXRef","debouncedUpdateCursorPosition","debounce","func","delay","timeoutId","args","clearTimeout","apply","this","time","startHr","endHr","updateCursorPosition","userControllingCursor","updateTimeDisplay","cursor","preventDefault","stopPropagation","cursorPositionLocked","parentElement","positionPercent","timestamp","timelineHourToTimestamp","hourRange","localDate","dateTime","find","seg","adjustedTime","closestSegment","date","timeString","timeDisplay","getElementById","hours","toString","padStart","minutes","seconds","textContent","initCursor","segmentsLength","segmentStartTime","display","pointerEvents","marginLeft","SpeedControls","currentSpeed","setCurrentSpeed","playbackSpeed","map","speed","playbackRate","setPlaybackSpeed","TimelinePlayer","videoRef","lastTimeUpdateRef","lastSegmentIdRef","handleVideoPlayback","video","segmentChanged","needsReload","timeChanged","loadSegment","autoplay","recordingUrl","onLoadedMetadata","validSeekTime","formatted","localTime","aspectRatio","controls","autoPlay","muted","playsInline","onEnded","handleEnded","nextIndex","wasUserControllingCursor","onTimeUpdate","handleTimeUpdate","videoTime","segmentStart","calculatedTime","streams","selectedStream","showOnlySegments","milliseconds","listeners","Set","lastUpdateTime","pendingUpdates","newState","Object","assign","notifyListeners","listener","add","delete","flushPendingUpdates","keys","TimelinePage","urlParams","params","URLSearchParams","window","location","search","stream","getFullYear","String","getMonth","getDate","parseUrlParams","isLoading","setIsLoading","streamsList","setStreamsList","setSelectedStream","setSelectedDate","timelineContainerRef","initialLoadRef","flushIntervalRef","data","streamsData","isLoadingStreams","streamsError","useQuery","timeout","retries","retryDelay","Array","isArray","some","s","name","firstStream","url","URL","href","searchParams","history","replaceState","updateUrlParams","timeRange","startDate","endDate","toISOString","getTimeRange","timelineUrl","encodeURIComponent","timelineData","isLoadingTimeline","timelineError","refetch","refetchTimeline","enabled","onSuccess","segmentsCopy","parse","slice","firstSegmentStartTime","firstSegmentId","onError","status","statusText","response","htmlFor","value","onChange","newStream","type","newDate","LoadingIndicator","render","QueryClientProvider","client","queryClient","Header","ToastContainer","Footer"],"mappings":"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"}