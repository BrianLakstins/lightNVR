{"version":3,"file":"TimelineView-BrBbQ2FD.js","sources":["../../js/components/preact/timeline/TimelineControls.js","../../js/components/preact/timeline/TimelineRuler.js","../../js/components/preact/timeline/TimelineSegments.js","../../js/components/preact/timeline/TimelineCursor.js","../../js/components/preact/timeline/SpeedControls.js","../../js/components/preact/timeline/TimelinePlayer.js","../../js/components/preact/timeline/TimelinePage.js","../../js/components/preact/timeline/TimelineView.js"],"sourcesContent":["/**\n * LightNVR Timeline Controls Component\n * Handles play/pause and zoom controls for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelineControls component\n * @returns {JSX.Element} TimelineControls component\n */\nexport function TimelineControls() {\n  // Local state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      setIsPlaying(state.isPlaying);\n      setZoomLevel(state.zoomLevel);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Toggle playback (play/pause)\n  const togglePlayback = () => {\n    console.log('TimelineControls: togglePlayback called');\n    console.log('TimelineControls: Current state before toggle:', {\n      isPlaying,\n      currentTime: timelineState.currentTime,\n      currentSegmentIndex: timelineState.currentSegmentIndex,\n      segmentsCount: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0\n    });\n\n    if (isPlaying) {\n      pausePlayback();\n    } else {\n      resumePlayback();\n    }\n  };\n\n  // Pause playback\n  const pausePlayback = () => {\n    timelineState.setState({ isPlaying: false });\n\n    // If there's a video player, pause it\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      videoPlayer.pause();\n    }\n  };\n\n  // Resume playback\n  const resumePlayback = () => {\n    // If no segments, show message and return\n    if (!timelineState.timelineSegments || timelineState.timelineSegments.length === 0) {\n      showStatusMessage('No recordings to play', 'warning');\n      return;\n    }\n\n    console.log('TimelineControls: resumePlayback called');\n    console.log('TimelineControls: Current state:', {\n      segments: timelineState.timelineSegments.length,\n      currentSegmentIndex: timelineState.currentSegmentIndex,\n      currentTime: timelineState.currentTime,\n      selectedDate: timelineState.selectedDate\n    });\n\n    // SIMPLIFIED APPROACH: Directly use the current time to find the appropriate segment\n    let segmentToPlay = null;\n    let segmentIndex = -1;\n    let relativeTime = 0;\n\n    // If we have a current time, find the segment that contains it\n    if (timelineState.currentTime !== null) {\n      console.log('TimelineControls: Using current time to find segment:', timelineState.currentTime);\n\n      // First try to find a segment that contains the current time\n      for (let i = 0; i < timelineState.timelineSegments.length; i++) {\n        const segment = timelineState.timelineSegments[i];\n        if (timelineState.currentTime >= segment.start_timestamp &&\n            timelineState.currentTime <= segment.end_timestamp) {\n          segmentToPlay = segment;\n          segmentIndex = i;\n          relativeTime = timelineState.currentTime - segment.start_timestamp;\n          console.log(`TimelineControls: Found segment ${i} containing current time, relative time: ${relativeTime}s`);\n          break;\n        }\n      }\n\n      // If no exact match, find the closest segment\n      if (!segmentToPlay) {\n        let closestIndex = 0;\n        let minDistance = Infinity;\n\n        for (let i = 0; i < timelineState.timelineSegments.length; i++) {\n          const segment = timelineState.timelineSegments[i];\n          const midpoint = (segment.start_timestamp + segment.end_timestamp) / 2;\n          const distance = Math.abs(timelineState.currentTime - midpoint);\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            closestIndex = i;\n          }\n        }\n\n        segmentToPlay = timelineState.timelineSegments[closestIndex];\n        segmentIndex = closestIndex;\n        // If the current time is after the segment, start at the beginning\n        if (timelineState.currentTime < segmentToPlay.start_timestamp) {\n          relativeTime = 0;\n        } else {\n          // Otherwise, start at the end\n          relativeTime = 0;\n        }\n\n        console.log(`TimelineControls: Using closest segment ${closestIndex}, relative time: ${relativeTime}s`);\n      }\n    }\n    // If no current time but we have a valid segment index, use that\n    else if (timelineState.currentSegmentIndex >= 0 &&\n             timelineState.currentSegmentIndex < timelineState.timelineSegments.length) {\n      segmentIndex = timelineState.currentSegmentIndex;\n      segmentToPlay = timelineState.timelineSegments[segmentIndex];\n      relativeTime = 0;\n      console.log(`TimelineControls: Using current segment index ${segmentIndex}`);\n    }\n    // Fall back to the first segment\n    else {\n      segmentIndex = 0;\n      segmentToPlay = timelineState.timelineSegments[0];\n      relativeTime = 0;\n      console.log('TimelineControls: Falling back to first segment');\n    }\n\n    // DIRECT APPROACH: Manually load and play the video\n    console.log(`TimelineControls: Playing segment ${segmentIndex} (ID: ${segmentToPlay.id}) at time ${relativeTime}s`);\n\n    // First update the state\n    timelineState.currentSegmentIndex = segmentIndex;\n    timelineState.currentTime = segmentToPlay.start_timestamp + relativeTime;\n    timelineState.isPlaying = true;\n    timelineState.directVideoControl = true; // Set flag to prevent TimelinePlayer interference\n\n    // Notify listeners\n    timelineState.setState({});\n\n    // Keep the directVideoControl flag active longer to ensure no interference\n    const resetDirectControl = () => {\n      console.log('TimelineControls: Resetting directVideoControl flag');\n      timelineState.directVideoControl = false;\n      timelineState.setState({});\n    };\n\n    // Reset the flag after a longer delay\n    setTimeout(resetDirectControl, 3000);\n\n    // Now directly control the video element\n    const videoElement = document.querySelector('#video-player video');\n    if (videoElement) {\n      // Pause any current playback\n      videoElement.pause();\n\n      // Set up event listener for when metadata is loaded\n      const handleMetadataLoaded = () => {\n        console.log(`TimelineControls: Video metadata loaded, setting time to ${relativeTime}s`);\n\n        try {\n          // Log the video duration\n          console.log('TimelineControls: Video metadata', {\n            duration: videoElement.duration,\n            width: videoElement.videoWidth,\n            height: videoElement.videoHeight,\n            segment: segmentToPlay.id,\n            segmentDuration: segmentToPlay.end_timestamp - segmentToPlay.start_timestamp\n          });\n\n          // Set the current time\n          const validTime = Math.max(0, Math.min(relativeTime, videoElement.duration || 0));\n          videoElement.currentTime = validTime;\n\n          // Start playback with a small delay to avoid conflicts\n          setTimeout(() => {\n            if (timelineState.isPlaying) {\n              console.log('TimelineControls: Starting video playback');\n              videoElement.play().then(() => {\n                console.log('TimelineControls: Video playback started successfully');\n\n                // Set up multiple checks to ensure playback continues\n                const checkPlayback = (attempt = 1) => {\n                  if (attempt > 5) return; // Limit to 5 attempts\n\n                  setTimeout(() => {\n                    if (videoElement.paused && timelineState.isPlaying) {\n                      console.log(`TimelineControls: Video paused unexpectedly (attempt ${attempt}), trying to resume`);\n                      videoElement.play().catch(e => {\n                        console.error(`Error resuming video (attempt ${attempt}):`, e);\n                      });\n\n                      // Try again after a delay\n                      checkPlayback(attempt + 1);\n                    }\n                  }, 500 * attempt); // Increasing delays between attempts\n                };\n\n                // Start the playback checks\n                checkPlayback();\n\n                // Set up a check to ensure the video plays for the full segment duration\n                const segmentDuration = segmentToPlay.end_timestamp - segmentToPlay.start_timestamp;\n                console.log(`TimelineControls: Segment duration: ${segmentDuration}s, video duration: ${videoElement.duration}s`);\n\n                // If the video duration is significantly shorter than the segment duration,\n                // we need to ensure the video plays for the full segment duration\n                if (videoElement.duration < segmentDuration - 1) { // Allow 1 second tolerance\n                  console.log('TimelineControls: Video duration is shorter than segment duration, will monitor playback');\n\n                  // Monitor playback to ensure it continues for the full segment duration\n                  const monitorInterval = setInterval(() => {\n                    if (!timelineState.isPlaying || !videoElement) {\n                      clearInterval(monitorInterval);\n                      return;\n                    }\n\n                    // If we're near the end of the video but not the end of the segment,\n                    // reset to the beginning and continue playing\n                    if (videoElement.currentTime > videoElement.duration - 0.5 &&\n                        relativeTime + videoElement.currentTime < segmentDuration) {\n                      console.log('TimelineControls: Reached end of video but not end of segment, restarting video');\n                      videoElement.currentTime = 0;\n                      videoElement.play().catch(e => {\n                        console.error('Error restarting video:', e);\n                      });\n                    }\n                  }, 500);\n                }\n              }).catch(e => {\n                console.error('Error playing video:', e);\n                showStatusMessage('Error playing video: ' + e.message, 'error');\n              });\n            }\n          }, 100);\n        } catch (error) {\n          console.error('TimelineControls: Error in handleMetadataLoaded:', error);\n        } finally {\n          // Remove the event listener\n          videoElement.removeEventListener('loadedmetadata', handleMetadataLoaded);\n        }\n      };\n\n      // Add the event listener\n      videoElement.addEventListener('loadedmetadata', handleMetadataLoaded);\n\n      // Set the new source\n      console.log(`TimelineControls: Loading video from segment ${segmentToPlay.id}`);\n      videoElement.src = `/api/recordings/play/${segmentToPlay.id}?t=${Date.now()}`;\n      videoElement.load();\n    } else {\n      console.error('TimelineControls: No video element found');\n      showStatusMessage('Error: Video player not found', 'error');\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index) => {\n    // This function will be implemented in the TimelinePlayer component\n    // Here we just update the state\n    timelineState.setState({\n      currentSegmentIndex: index,\n      isPlaying: true\n    });\n  };\n\n  // Zoom in on timeline\n  const zoomIn = () => {\n    if (zoomLevel < 8) {\n      const newZoomLevel = zoomLevel * 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed in: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  // Zoom out on timeline\n  const zoomOut = () => {\n    if (zoomLevel > 1) {\n      const newZoomLevel = zoomLevel / 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed out: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  return html`\n    <div class=\"timeline-controls flex justify-between items-center mb-2\">\n      <div class=\"flex items-center\">\n        <button\n          id=\"play-button\"\n          class=\"w-10 h-10 rounded-full bg-green-600 hover:bg-green-700 text-white flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-offset-1 transition-colors shadow-sm mr-2\"\n          onClick=${togglePlayback}\n          title=${isPlaying ? 'Pause' : 'Play from current position'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            ${isPlaying\n              ? html`\n                <!-- Pause icon - two vertical bars -->\n                <rect x=\"6\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n                <rect x=\"14\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n              `\n              : html`\n                <!-- Play icon - triangle -->\n                <path d=\"M8 5.14v14l11-7-11-7z\" fill=\"white\" />\n              `\n            }\n          </svg>\n        </button>\n        <span class=\"text-xs text-gray-600 dark:text-gray-300\">Play from current position</span>\n      </div>\n\n      <div class=\"flex items-center gap-1\">\n        <span class=\"text-xs text-gray-600 dark:text-gray-300 mr-1\">Zoom:</span>\n        <button\n          id=\"zoom-out-button\"\n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomOut}\n          title=\"Zoom Out (Show more time)\"\n          disabled=${zoomLevel <= 1}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n        <button\n          id=\"zoom-in-button\"\n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomIn}\n          title=\"Zoom In (Show less time)\"\n          disabled=${zoomLevel >= 8}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Ruler Component\n * Displays the time ruler with hour markers\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineRuler component\n * @returns {JSX.Element} TimelineRuler component\n */\nexport function TimelineRuler() {\n  // Local state\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineRuler: State update received', {\n        zoomLevel: state.zoomLevel,\n        segmentsCount: state.timelineSegments ? state.timelineSegments.length : 0,\n        currentTime: state.currentTime\n      });\n\n      // Calculate time range based on zoom level\n      const hoursPerView = 24 / state.zoomLevel;\n\n      // Calculate the center hour based on current time or segments\n      let centerHour = 12; // Default to noon\n\n      if (state.currentTime !== null) {\n        // If we have a current time, use it as the center\n        const currentDate = new Date(state.currentTime * 1000);\n        centerHour = currentDate.getHours() + (currentDate.getMinutes() / 60) + (currentDate.getSeconds() / 3600);\n      } else if (state.timelineSegments && state.timelineSegments.length > 0) {\n        // If we have segments but no current time, use the middle of the segments\n        let earliestHour = 24;\n        let latestHour = 0;\n\n        state.timelineSegments.forEach(segment => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n\n          const startHour = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n          const endHour = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n          earliestHour = Math.min(earliestHour, startHour);\n          latestHour = Math.max(latestHour, endHour);\n        });\n\n        centerHour = (earliestHour + latestHour) / 2;\n        console.log('TimelineRuler: Calculated center from segments', { earliestHour, latestHour, centerHour });\n      }\n\n      // Calculate start and end hours based on center and zoom level\n      let newStartHour = Math.max(0, centerHour - (hoursPerView / 2));\n      let newEndHour = Math.min(24, newStartHour + hoursPerView);\n\n      // Adjust start hour if end hour is at the limit\n      if (newEndHour === 24 && hoursPerView < 24) {\n        newStartHour = Math.max(0, 24 - hoursPerView);\n        newEndHour = 24;\n      } else if (newStartHour === 0 && hoursPerView < 24) {\n        newEndHour = Math.min(24, hoursPerView);\n      }\n\n      // Update local state\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setZoomLevel(state.zoomLevel);\n\n      console.log('TimelineRuler: Calculated time range', {\n        newStartHour,\n        newEndHour,\n        hoursPerView,\n        centerHour\n      });\n\n      // Only update global state if the values have actually changed\n      // to prevent infinite recursion\n      if (timelineState.timelineStartHour !== newStartHour ||\n          timelineState.timelineEndHour !== newEndHour) {\n        console.log('TimelineRuler: Updating global state with new time range');\n        timelineState.setState({\n          timelineStartHour: newStartHour,\n          timelineEndHour: newEndHour\n        });\n      }\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Generate hour markers and labels\n  const generateHourMarkers = () => {\n    const markers = [];\n    const hourWidth = 100 / (endHour - startHour);\n\n    // Add hour markers and labels\n    for (let hour = Math.floor(startHour); hour <= Math.ceil(endHour); hour++) {\n      if (hour >= 0 && hour <= 24) {\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n\n        // Add hour marker\n        markers.push(html`\n          <div\n            key=\"tick-${hour}\"\n            class=\"absolute top-0 w-px h-5 bg-gray-500 dark:bg-gray-400\"\n            style=\"left: ${position}%;\"\n          ></div>\n        `);\n\n        // Add hour label\n        markers.push(html`\n          <div\n            key=\"label-${hour}\"\n            class=\"absolute top-0 text-xs text-gray-600 dark:text-gray-300 transform -translate-x-1/2\"\n            style=\"left: ${position}%;\"\n          >\n            ${hour}:00\n          </div>\n        `);\n\n        // Add half-hour marker if not the last hour and we're zoomed in enough\n        if (hour < 24 && zoomLevel >= 2) {\n          const halfHourPosition = ((hour + 0.5 - startHour) / (endHour - startHour)) * 100;\n          markers.push(html`\n            <div\n              key=\"tick-${hour}-30\"\n              class=\"absolute top-2 w-px h-3 bg-gray-400 dark:bg-gray-500\"\n              style=\"left: ${halfHourPosition}%;\"\n            ></div>\n          `);\n\n          // Add 15-minute markers if zoomed in even more\n          if (zoomLevel >= 4) {\n            const quarterHourPosition1 = ((hour + 0.25 - startHour) / (endHour - startHour)) * 100;\n            const quarterHourPosition3 = ((hour + 0.75 - startHour) / (endHour - startHour)) * 100;\n\n            markers.push(html`\n              <div\n                key=\"tick-${hour}-15\"\n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\"\n                style=\"left: ${quarterHourPosition1}%;\"\n              ></div>\n            `);\n\n            markers.push(html`\n              <div\n                key=\"tick-${hour}-45\"\n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\"\n                style=\"left: ${quarterHourPosition3}%;\"\n              ></div>\n            `);\n          }\n        }\n      }\n    }\n\n    return markers;\n  };\n\n  return html`\n    <div class=\"timeline-ruler relative w-full h-8 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-600\">\n      ${generateHourMarkers()}\n      <div class=\"absolute bottom-0 left-0 text-xs text-gray-500 px-1\">\n        Zoom: ${zoomLevel}x (${Math.round(24 / zoomLevel)} hours)\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Segments Component\n * Displays recording segments on the timeline\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineSegments component\n * @param {Object} props Component props\n * @param {Array} props.segments Array of timeline segments\n * @returns {JSX.Element} TimelineSegments component\n */\nexport function TimelineSegments({ segments: propSegments }) {\n  // Local state\n  const [segments, setSegments] = useState(propSegments || []);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n\n  // Update segments when props change\n  useEffect(() => {\n    console.log(`TimelineSegments: Received segments from props: ${propSegments ? propSegments.length : 0}`);\n    if (propSegments && propSegments.length > 0) {\n      setSegments(propSegments);\n    }\n  }, [propSegments]);\n\n  // Refs\n  const containerRef = useRef(null);\n  const isDragging = useRef(false);\n\n  // Track the last time segments were updated to prevent too frequent updates\n  const lastSegmentsUpdateRef = useRef(0);\n  const lastSegmentsRef = useRef([]);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log(`TimelineSegments: State update received, segments: ${state.timelineSegments ? state.timelineSegments.length : 0}`);\n\n      // Always update segments when they change\n      if (state.timelineSegments) {\n        // Check if segments have changed\n        const segmentsChanged = !lastSegmentsRef.current ||\n                               state.timelineSegments.length !== lastSegmentsRef.current.length ||\n                               JSON.stringify(state.timelineSegments) !== JSON.stringify(lastSegmentsRef.current) ||\n                               state.forceReload;\n\n        if (segmentsChanged) {\n          console.log(`TimelineSegments: Updating segments (${state.timelineSegments.length})`);\n          setSegments(state.timelineSegments);\n          lastSegmentsRef.current = [...state.timelineSegments]; // Create a copy\n          lastSegmentsUpdateRef.current = Date.now();\n        }\n      }\n\n      // Always update these lightweight properties\n      const newStartHour = state.timelineStartHour !== undefined ? state.timelineStartHour : 0;\n      const newEndHour = state.timelineEndHour !== undefined ? state.timelineEndHour : 24;\n\n      console.log(`TimelineSegments: Time range update - startHour: ${newStartHour}, endHour: ${newEndHour}`);\n\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setCurrentSegmentIndex(state.currentSegmentIndex || -1);\n    });\n\n    // Initial load of segments\n    if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n      console.log(`TimelineSegments: Initial load of segments (${timelineState.timelineSegments.length})`);\n      setSegments(timelineState.timelineSegments);\n      lastSegmentsRef.current = [...timelineState.timelineSegments];\n      setCurrentSegmentIndex(timelineState.currentSegmentIndex || 0);\n\n      // Also set the time range\n      if (timelineState.timelineStartHour !== undefined) {\n        setStartHour(timelineState.timelineStartHour);\n      }\n      if (timelineState.timelineEndHour !== undefined) {\n        setEndHour(timelineState.timelineEndHour);\n      }\n\n      lastSegmentsUpdateRef.current = Date.now();\n    }\n\n    return () => unsubscribe();\n  }, []);\n\n  // Set up drag handling\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const handleMouseDown = (e) => {\n      // Only handle clicks on the container itself, not on segments\n      if (e.target === container || e.target.classList.contains('timeline-clickable-area')) {\n        isDragging.current = true;\n        handleTimelineClick(e);\n\n        // Add event listeners for drag\n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n      }\n    };\n\n    const handleMouseMove = (e) => {\n      if (!isDragging.current) return;\n      handleTimelineClick(e);\n    };\n\n    const handleMouseUp = () => {\n      isDragging.current = false;\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n\n    container.addEventListener('mousedown', handleMouseDown);\n\n    return () => {\n      container.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [startHour, endHour, segments]);\n\n  // Handle click on timeline for seeking\n  const handleTimelineClick = (event) => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    // Get click position relative to container\n    const rect = container.getBoundingClientRect();\n    const clickX = event.clientX - rect.left;\n    const containerWidth = rect.width;\n\n    // Calculate time based on click position\n    const clickPercent = clickX / containerWidth;\n    const clickHour = startHour + (clickPercent * (endHour - startHour));\n\n    // Find the segment that contains this time\n    const clickDate = new Date(timelineState.selectedDate);\n    clickDate.setHours(Math.floor(clickHour));\n    clickDate.setMinutes(Math.floor((clickHour % 1) * 60));\n    clickDate.setSeconds(Math.floor(((clickHour % 1) * 60) % 1 * 60));\n\n    const clickTimestamp = clickDate.getTime() / 1000;\n\n    // Always update the current time to where the user clicked\n    // This allows the user to position the cursor anywhere on the timeline\n    timelineState.setState({\n      currentTime: clickTimestamp,\n      prevCurrentTime: timelineState.currentTime,\n      // Don't automatically start playing\n      isPlaying: false\n    });\n\n    // Find segment that contains this timestamp\n    let foundSegment = false;\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n\n      if (clickTimestamp >= startTimestamp && clickTimestamp <= endTimestamp) {\n        console.log(`TimelineSegments: Found segment ${i} containing timestamp`);\n\n        // Update current segment index without starting playback\n        timelineState.setState({\n          currentSegmentIndex: i\n        });\n\n        // Only if the user clicked directly on a segment (not the background),\n        // play that segment starting at the clicked time\n        if (event.target.classList.contains('timeline-segment')) {\n          // Calculate relative time within the segment\n          const relativeTime = clickTimestamp - startTimestamp;\n\n          // Play this segment starting at the clicked time\n          playSegment(i, relativeTime);\n        }\n\n        foundSegment = true;\n        break;\n      }\n    }\n\n    if (!foundSegment) {\n      // If no segment found, don't automatically jump to a different segment\n      // Just leave the cursor where the user clicked\n      timelineState.setState({\n        currentSegmentIndex: -1\n      });\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index, relativeTime = null) => {\n    console.log(`TimelineSegments: playSegment(${index}, ${relativeTime})`);\n\n    if (index < 0 || index >= segments.length) {\n      console.warn(`TimelineSegments: Invalid segment index: ${index}`);\n      return;\n    }\n\n    const segment = segments[index];\n\n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n\n    // Calculate absolute timestamp for currentTime\n    const absoluteTime = relativeTime !== null\n      ? startTimestamp + relativeTime\n      : startTimestamp;\n\n    // First, pause any current playback and reset the segment index\n    timelineState.setState({\n      isPlaying: false,\n      currentSegmentIndex: -1\n    });\n\n    // Force a synchronous DOM update\n    document.body.offsetHeight;\n\n    // Now set the new segment index and start playing\n    setTimeout(() => {\n      timelineState.setState({\n        currentSegmentIndex: index,\n        currentTime: absoluteTime,\n        isPlaying: true,\n        forceReload: true\n      });\n\n      // Force the video player to reload\n      setTimeout(() => {\n        const videoElement = document.querySelector('#video-player video');\n        if (videoElement) {\n          // Pause any current playback\n          videoElement.pause();\n\n          // Clear the source and reload\n          videoElement.removeAttribute('src');\n          videoElement.load();\n\n          // Set the new source\n          videoElement.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n\n          // Set the current time and play\n          videoElement.onloadedmetadata = () => {\n            const seekTime = relativeTime !== null ? relativeTime : 0;\n            videoElement.currentTime = seekTime;\n            videoElement.play().catch(e => console.error('Error playing video:', e));\n          };\n        }\n      }, 50);\n    }, 50);\n  };\n\n  // Render segments\n  const renderSegments = () => {\n    console.log('TimelineSegments: renderSegments called');\n    console.log('TimelineSegments: segments:', segments);\n    console.log('TimelineSegments: startHour:', startHour, 'endHour:', endHour);\n\n    if (!segments || segments.length === 0) {\n      console.log('TimelineSegments: No segments to render');\n      return html`<div class=\"text-center text-red-500 font-bold\">No segments to display</div>`;\n    }\n\n    console.log('TimelineSegments: Rendering segments:', segments.length);\n\n    const visibleSegments = [];\n    const hourMap = new Map();\n\n    // First pass: collect all segments by hour\n    console.log('TimelineSegments: Starting to process segments');\n    let visibleCount = 0;\n    let skippedCount = 0;\n\n    segments.forEach((segment, index) => {\n      // Always use regular timestamps for consistency\n      const startTimestamp = segment.start_timestamp;\n      const endTimestamp = segment.end_timestamp;\n\n      // Convert timestamps to Date objects\n      const startTime = new Date(startTimestamp * 1000);\n      const endTime = new Date(endTimestamp * 1000);\n\n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        skippedCount++;\n        if (index < 5) {\n          console.log(`TimelineSegments: Skipping segment ${index}, startHour=${startHourFloat}, endHour=${endHourFloat}, visible range=${startHour}-${endHour}`);\n        }\n        return;\n      }\n      visibleCount++;\n\n      // Mark each hour that this segment spans\n      const startFloorHour = Math.floor(startHourFloat);\n      const endCeilHour = Math.min(Math.ceil(endHourFloat), 24);\n\n      for (let h = startFloorHour; h < endCeilHour; h++) {\n        if (h >= startHour && h <= endHour) {\n          if (!hourMap.has(h)) {\n            hourMap.set(h, []);\n          }\n          hourMap.get(h).push(index);\n        }\n      }\n    });\n\n    // Preprocess segments to merge adjacent ones\n    const mergedSegments = [];\n    let currentMergedSegment = null;\n\n    // Sort segments by start time\n    const sortedSegments = [...segments].sort((a, b) => {\n      return a.start_timestamp - b.start_timestamp;\n    });\n\n    // Merge adjacent segments (no gap or very small gap)\n    sortedSegments.forEach((segment, index) => {\n      if (!currentMergedSegment) {\n        // First segment\n        currentMergedSegment = { ...segment, originalIndices: [index] };\n      } else {\n        // Check if this segment is adjacent to the current merged segment\n        const segmentStart = segment.start_timestamp;\n        const mergedEnd = currentMergedSegment.end_timestamp;\n\n        // Allow a small gap (1 second) to account for rounding errors\n        const gap = segmentStart - mergedEnd;\n\n        if (gap <= 1) {\n          // Merge with current segment\n          currentMergedSegment.end_timestamp = segment.end_timestamp;\n          currentMergedSegment.originalIndices.push(index);\n\n          // If this segment has detection, mark the merged segment as having detection\n          if (segment.has_detection) {\n            currentMergedSegment.has_detection = true;\n          }\n        } else {\n          // Gap is too large, start a new merged segment\n          mergedSegments.push(currentMergedSegment);\n          currentMergedSegment = { ...segment, originalIndices: [index] };\n        }\n      }\n    });\n\n    // Add the last merged segment\n    if (currentMergedSegment) {\n      mergedSegments.push(currentMergedSegment);\n    }\n\n    // Second pass: add visible segments\n    mergedSegments.forEach((segment, mergedIndex) => {\n      const segStartTimestamp = segment.start_timestamp;\n      const segEndTimestamp = segment.end_timestamp;\n\n      // Convert timestamps to Date objects\n      const startTime = new Date(segStartTimestamp * 1000);\n      const endTime = new Date(segEndTimestamp * 1000);\n\n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n\n      // Adjust start and end to fit within visible range\n      const visibleStartHour = Math.max(startHourFloat, startHour);\n      const visibleEndHour = Math.min(endHourFloat, endHour);\n\n      // Calculate position and width as percentages\n      const startPercent = ((visibleStartHour - startHour) / (endHour - startHour)) * 100;\n      const widthPercent = ((visibleEndHour - visibleStartHour) / (endHour - startHour)) * 100;\n\n      // Format duration for tooltip\n      const duration = Math.round(segEndTimestamp - segStartTimestamp);\n      const durationStr = `${duration}s`;\n\n      // Format times for tooltip\n      const startTimeStr = startTime.toLocaleTimeString();\n      const endTimeStr = endTime.toLocaleTimeString();\n\n      // Use a consistent height for all segments\n      const heightPercent = 80; // 80% height for all segments\n\n      visibleSegments.push(html`\n        <div\n          key=\"segment-${mergedIndex}\"\n          class=\"timeline-segment absolute rounded-sm transition-all duration-200 ${segment.has_detection ? 'bg-red-500' : 'bg-blue-500'}\"\n          style=\"left: ${startPercent}%; width: ${widthPercent}%; height: ${heightPercent}%; top: 50%; transform: translateY(-50%);\"\n          title=\"${startTimeStr} - ${endTimeStr} (${durationStr})\"\n        ></div>\n      `);\n    });\n\n    // Third pass: fill in gaps with clickable areas\n    for (let hour = Math.floor(startHour); hour < Math.ceil(endHour); hour++) {\n      if (!hourMap.has(hour)) {\n        // No segments in this hour, create a clickable area\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        const width = 100 / (endHour - startHour);\n\n        visibleSegments.push(html`\n          <div\n            key=\"clickable-${hour}\"\n            class=\"timeline-clickable-area absolute h-full cursor-pointer\"\n            style=\"left: ${position}%; width: ${width}%;\"\n            data-hour=${hour}\n          ></div>\n        `);\n      }\n    }\n\n    console.log(`TimelineSegments: Rendering complete. Total: ${segments.length}, Visible: ${visibleCount}, Skipped: ${skippedCount}, Final rendered: ${visibleSegments.length}`);\n    return visibleSegments;\n  };\n\n  return html`\n    <div\n      class=\"timeline-segments relative w-full h-16 pt-2\"\n      ref=${containerRef}\n    >\n      ${renderSegments()}\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Cursor Component\n * Displays the playback cursor on the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineCursor component\n * @returns {JSX.Element} TimelineCursor component\n */\nexport function TimelineCursor() {\n  // Local state\n  const [position, setPosition] = useState(0);\n  const [visible, setVisible] = useState(false);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentTime, setCurrentTime] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n\n  // Refs\n  const cursorRef = useRef(null);\n  const containerRef = useRef(null);\n  const dragStartXRef = useRef(0);\n\n  // Debounce function to limit how often a function can be called\n  const debounce = (func, delay) => {\n    let timeoutId;\n    return function(...args) {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      timeoutId = setTimeout(() => {\n        func.apply(this, args);\n      }, delay);\n    };\n  };\n\n  // Create debounced version of updateCursorPosition\n  const debouncedUpdateCursorPosition = useRef(\n    debounce((time, startHr, endHr) => {\n      updateCursorPosition(time, startHr, endHr);\n    }, 100)\n  ).current;\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineCursor: State update received', {\n        currentTime: state.currentTime,\n        startHour: state.timelineStartHour,\n        endHour: state.timelineEndHour,\n        segmentsCount: state.timelineSegments ? state.timelineSegments.length : 0,\n        isDragging: isDragging,\n        userControllingCursor: state.userControllingCursor\n      });\n\n      // Update local state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n\n      // Only update current time if not dragging\n      if (!isDragging && !state.userControllingCursor) {\n        setCurrentTime(state.currentTime);\n        updateTimeDisplay(state.currentTime);\n\n        // Use debounced update for smoother performance\n        debouncedUpdateCursorPosition(state.currentTime, state.timelineStartHour || 0, state.timelineEndHour || 24);\n      }\n    });\n\n    return () => unsubscribe();\n  }, [isDragging, debouncedUpdateCursorPosition]);\n\n  // Set up drag handling\n  useEffect(() => {\n    const cursor = cursorRef.current;\n    if (!cursor) return;\n\n    const handleMouseDown = (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      console.log('TimelineCursor: Mouse down event');\n\n      // Store the starting X position\n      dragStartXRef.current = e.clientX;\n\n      // Set dragging state\n      setIsDragging(true);\n\n      // Set global flag to prevent other components from updating cursor\n      timelineState.userControllingCursor = true;\n      timelineState.setState({});\n\n      // Add event listeners for drag\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    };\n\n    const handleMouseMove = (e) => {\n      if (!isDragging) return;\n\n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n\n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      setPosition(positionPercent);\n\n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n\n      // Convert hour to timestamp\n      const date = new Date();\n      if (timelineState.selectedDate) {\n        date.setTime(new Date(timelineState.selectedDate).getTime());\n      }\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      date.setMilliseconds(0);\n\n      const timestamp = date.getTime() / 1000;\n\n      // Store the current time locally but don't update the global state yet\n      setCurrentTime(timestamp);\n\n      // Update time display\n      updateTimeDisplay(timestamp);\n    };\n\n    const handleMouseUp = (e) => {\n      if (!isDragging) return;\n\n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n\n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      console.log('TimelineCursor: Mouse up at position', { positionPercent, clickX, containerWidth });\n\n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      console.log('TimelineCursor: Calculated hour', { hour, startHour, endHour, hourRange });\n\n      // Convert hour to timestamp\n      const date = new Date();\n      if (timelineState.selectedDate) {\n        date.setTime(new Date(timelineState.selectedDate).getTime());\n      }\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      date.setMilliseconds(0);\n\n      const timestamp = date.getTime() / 1000;\n      console.log('TimelineCursor: Converted to timestamp', {\n        timestamp,\n        dateTime: date.toLocaleString(),\n        selectedDate: timelineState.selectedDate\n      });\n\n      console.log('TimelineCursor: Mouse up event');\n\n      // Reset dragging state FIRST\n      setIsDragging(false);\n\n      // Remove event listeners\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n\n      // Reset the user controlling cursor flag AFTER a short delay\n      // This allows the current update to complete before other components can update the cursor\n      setTimeout(() => {\n        console.log('TimelineCursor: Releasing cursor control');\n        timelineState.userControllingCursor = false;\n        timelineState.setState({});\n      }, 100);\n\n      // Always update the current time to where the user placed the cursor\n      // This allows the user to position the cursor anywhere on the timeline\n      timelineState.currentTime = timestamp;\n      timelineState.prevCurrentTime = timelineState.currentTime;\n      timelineState.isPlaying = false;\n\n      // Notify listeners\n      timelineState.setState({});\n\n      // Find segment that contains this timestamp\n      const segments = timelineState.timelineSegments || [];\n      console.log('TimelineCursor: Searching for segment containing timestamp', {\n        timestamp,\n        segmentsCount: segments.length\n      });\n\n      let foundSegment = false;\n      let closestSegment = -1;\n      let minDistance = Infinity;\n\n      // First try to find an exact match\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n        const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n\n        // Log the first few segments for debugging\n        if (i < 3) {\n          console.log(`TimelineCursor: Segment ${i}`, {\n            startTimestamp,\n            endTimestamp,\n            startTime: new Date(startTimestamp * 1000).toLocaleTimeString(),\n            endTime: new Date(endTimestamp * 1000).toLocaleTimeString()\n          });\n        }\n\n        // Check if timestamp is within this segment\n        if (timestamp >= startTimestamp && timestamp <= endTimestamp) {\n          console.log(`TimelineCursor: Found exact match at segment ${i}`);\n          // Update current segment index without changing the time or starting playback\n          timelineState.currentSegmentIndex = i;\n          timelineState.setState({});\n          foundSegment = true;\n          break;\n        }\n\n        // Calculate distance to this segment (for finding closest if no exact match)\n        const midpoint = (startTimestamp + endTimestamp) / 2;\n        const distance = Math.abs(timestamp - midpoint);\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestSegment = i;\n        }\n      }\n\n      // If no exact match found, use the closest segment\n      if (!foundSegment) {\n        if (closestSegment >= 0) {\n          console.log(`TimelineCursor: No exact match, using closest segment ${closestSegment}`);\n          timelineState.currentSegmentIndex = closestSegment;\n          timelineState.setState({});\n        } else {\n          console.log('TimelineCursor: No segments found at all');\n          // Reset current segment index\n          timelineState.currentSegmentIndex = -1;\n          timelineState.setState({});\n        }\n      }\n    };\n\n    // Add event listeners\n    cursor.addEventListener('mousedown', handleMouseDown);\n\n    return () => {\n      cursor.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [cursorRef.current, startHour, endHour, isDragging]);\n\n  // Update cursor position\n  const updateCursorPosition = (time, startHr, endHr) => {\n    console.log('TimelineCursor: updateCursorPosition called', { time, startHr, endHr });\n\n    if (time === null) {\n      console.log('TimelineCursor: No current time, hiding cursor');\n      setVisible(false);\n      return;\n    }\n\n    // Calculate cursor position\n    const date = new Date(time * 1000);\n    const hour = date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n    console.log('TimelineCursor: Calculated hour', { hour, timeString: date.toLocaleTimeString() });\n\n    // Check if the current time is within the visible range\n    if (hour < startHr || hour > endHr) {\n      console.log('TimelineCursor: Time outside visible range, hiding cursor');\n      setVisible(false);\n      return;\n    }\n\n    // Calculate position as percentage\n    const position = ((hour - startHr) / (endHr - startHr)) * 100;\n    console.log('TimelineCursor: Calculated position', { position, hour, startHr, endHr });\n\n    // Update cursor position\n    setPosition(position);\n    setVisible(true);\n  };\n\n  // Update time display\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n\n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n\n    const date = new Date(time * 1000);\n\n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n\n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  // Force the cursor to be visible on initial render\n  useEffect(() => {\n    console.log('TimelineCursor: Initializing cursor position');\n    console.log('TimelineCursor: Initial state', {\n      currentTime: timelineState.currentTime,\n      startHour: timelineState.timelineStartHour,\n      endHour: timelineState.timelineEndHour,\n      segments: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0\n    });\n\n    // Function to initialize cursor\n    const initCursor = () => {\n      console.log('TimelineCursor: Checking timelineState directly', {\n        currentTime: timelineState.currentTime,\n        segmentsLength: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0,\n        currentSegmentIndex: timelineState.currentSegmentIndex\n      });\n\n      if (timelineState.currentTime) {\n        console.log('TimelineCursor: Setting initial cursor position with current time');\n        setVisible(true);\n        updateCursorPosition(\n          timelineState.currentTime,\n          timelineState.timelineStartHour || 0,\n          timelineState.timelineEndHour || 24\n        );\n        return true;\n      } else if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n        // If no current time but we have segments, use the first segment's start time\n        console.log('TimelineCursor: Using first segment start time for cursor');\n        const firstSegment = timelineState.timelineSegments[0];\n        const startTime = firstSegment.start_timestamp;\n\n        // Update the timeline state with this time - DIRECT ASSIGNMENT\n        console.log('TimelineCursor: Directly setting timelineState properties');\n        timelineState.currentTime = startTime;\n        timelineState.currentSegmentIndex = 0;\n\n        // Now call setState to notify listeners\n        timelineState.setState({\n          // Empty object just to trigger notification\n        });\n\n        setVisible(true);\n        updateCursorPosition(\n          startTime,\n          timelineState.timelineStartHour || 0,\n          timelineState.timelineEndHour || 24\n        );\n        return true;\n      }\n      return false;\n    };\n\n    // Try to initialize immediately\n    const initialized = initCursor();\n\n    // If not initialized, try again after a delay\n    if (!initialized) {\n      console.log('TimelineCursor: Initial initialization failed, will retry after delay');\n\n      // Set up multiple attempts with increasing delays\n      const delays = [100, 300, 500, 1000];\n\n      delays.forEach((delay, index) => {\n        setTimeout(() => {\n          if (!visible) {\n            console.log(`TimelineCursor: Retry initialization attempt ${index + 1}`);\n            initCursor();\n          }\n        }, delay);\n      });\n    }\n  }, []);\n\n  return html`\n    <div\n      ref=${cursorRef}\n      class=\"timeline-cursor absolute top-0 h-full z-50 transition-all duration-100 cursor-ew-resize\"\n      style=\"left: ${position}%; display: ${visible ? 'block' : 'none'}; pointer-events: auto; width: 7px; margin-left: -3.5px;\"\n    >\n      <!-- Invisible wider clickable area -->\n      <div class=\"absolute top-0 bottom-0 left-0 w-full\"></div>\n\n      <!-- Skinnier needle with no middle chunk -->\n      <div class=\"absolute top-0 bottom-0 w-0.5 bg-orange-500 left-1/2 transform -translate-x-1/2 pointer-events-none\"></div>\n\n      <!-- Top handle (black) -->\n      <div class=\"absolute top-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 -translate-y-1/2 shadow-md pointer-events-none\"></div>\n\n      <!-- Bottom handle (black) -->\n      <div class=\"absolute bottom-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 translate-y-1/2 shadow-md pointer-events-none\"></div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Speed Controls Component\n * Handles playback speed controls for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * SpeedControls component\n * @returns {JSX.Element} SpeedControls component\n */\nexport function SpeedControls() {\n  // Local state\n  const [currentSpeed, setCurrentSpeed] = useState(1.0);\n  \n  // Available speeds\n  const speeds = [0.25, 0.5, 1.0, 1.5, 2.0, 4.0];\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      setCurrentSpeed(state.playbackSpeed);\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set playback speed\n  const setPlaybackSpeed = (speed) => {\n    // Update video playback rate\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      // Set the new playback rate\n      videoPlayer.playbackRate = speed;\n    }\n    \n    // Update timeline state\n    timelineState.setState({ playbackSpeed: speed });\n    \n    // Show status message\n    showStatusMessage(`Playback speed: ${speed}x`, 'info');\n  };\n\n  return html`\n    <div class=\"mt-2 mb-4 p-2 border border-green-500 rounded-lg bg-white dark:bg-gray-800 shadow-sm\">\n      <div class=\"flex flex-col items-center\">\n        <div class=\"text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300\">Playback Speed</div>\n        \n        <div class=\"flex flex-wrap justify-center gap-1\">\n          ${speeds.map(speed => html`\n            <button \n              key=${`speed-${speed}`}\n              class=${`speed-btn px-2 py-1 text-sm rounded-full ${speed === currentSpeed \n                ? 'bg-green-500 text-white' \n                : 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600'} \n                font-medium transition-all focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-opacity-50`}\n              data-speed=${speed}\n              onClick=${() => setPlaybackSpeed(speed)}\n            >\n              ${speed === 1.0 ? '1× (Normal)' : `${speed}×`}\n            </button>\n          `)}\n        </div>\n        \n        <div class=\"mt-1 text-xs font-medium text-green-600 dark:text-green-400\">\n          Current: ${currentSpeed}× ${currentSpeed === 1.0 ? '(Normal)' : ''}\n        </div>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Player Component\n * Handles video playback for the timeline\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelinePlayer component\n * @returns {JSX.Element} TimelinePlayer component\n */\nexport function TimelinePlayer() {\n  // Local state\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [segments, setSegments] = useState([]);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n\n  // Refs\n  const videoRef = useRef(null);\n  const lastTimeUpdateRef = useRef(null);\n  const lastSegmentIdRef = useRef(null);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setCurrentSegmentIndex(state.currentSegmentIndex);\n      setIsPlaying(state.isPlaying);\n      setSegments(state.timelineSegments || []);\n      setPlaybackSpeed(state.playbackSpeed);\n\n      // Handle video playback\n      handleVideoPlayback(state);\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Handle video playback based on state changes\n  const handleVideoPlayback = (state) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have valid segments and segment index\n    if (!state.timelineSegments || \n        state.timelineSegments.length === 0 || \n        state.currentSegmentIndex < 0 || \n        state.currentSegmentIndex >= state.timelineSegments.length) {\n      return;\n    }\n    \n    // Get current segment\n    const segment = state.timelineSegments[state.currentSegmentIndex];\n    if (!segment) return;\n    \n    // Check if we need to load a new segment\n    const segmentChanged = lastSegmentIdRef.current !== segment.id;\n    \n    // IMPORTANT: Only reload if the segment has actually changed\n    // This prevents constant reloading\n    const needsReload = segmentChanged;\n    \n    // Calculate relative time within the segment\n    const relativeTime = state.currentTime !== null && \n                         state.currentTime >= segment.start_timestamp\n      ? state.currentTime - segment.start_timestamp\n      : 0;\n    \n    // Only update the video if:\n    // 1. We need to load a new segment, OR\n    // 2. The user is dragging the cursor (indicated by a significant time change)\n    const timeChanged = state.prevCurrentTime !== null && \n                        Math.abs(state.currentTime - state.prevCurrentTime) > 1;\n    \n    // Update last segment ID\n    if (segmentChanged) {\n      console.log(`Segment changed from ${lastSegmentIdRef.current} to ${segment.id}`);\n      lastSegmentIdRef.current = segment.id;\n    }\n    \n    // Handle playback\n    if (needsReload) {\n      // Load new segment\n      console.log(`Loading new segment ${segment.id} (segmentChanged: ${segmentChanged})`);\n      loadSegment(segment, relativeTime, state.isPlaying);\n    } else if (timeChanged) {\n      // User is dragging the cursor, just update the current time\n      console.log(`Seeking to ${relativeTime}s within current segment`);\n      video.currentTime = relativeTime;\n    } else if (state.isPlaying && video.paused) {\n      // Resume playback if needed\n      video.play().catch(error => {\n        console.error('Error playing video:', error);\n      });\n    } else if (!state.isPlaying && !video.paused) {\n      // Pause playback if needed\n      video.pause();\n    }\n    \n    // Update playback speed if needed\n    if (video.playbackRate !== state.playbackSpeed) {\n      video.playbackRate = state.playbackSpeed;\n    }\n  };\n\n  // Load a segment\n  const loadSegment = (segment, seekTime = 0, autoplay = false) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    console.log(`Loading segment ${segment.id} at time ${seekTime}s, autoplay: ${autoplay}`);\n    \n    // Pause current playback\n    video.pause();\n    \n    // Set new source with timestamp to prevent caching\n    const recordingUrl = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n    \n    // Set up event listeners for the new video\n    const onLoadedMetadata = () => {\n      console.log('Video metadata loaded');\n      \n      // Set current time\n      video.currentTime = seekTime;\n      \n      // Set playback speed\n      video.playbackRate = playbackSpeed;\n      \n      // Play if needed\n      if (autoplay) {\n        video.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      }\n      \n      // Remove event listener\n      video.removeEventListener('loadedmetadata', onLoadedMetadata);\n    };\n    \n    // Add event listener for metadata loaded\n    video.addEventListener('loadedmetadata', onLoadedMetadata);\n    \n    // Set new source\n    video.src = recordingUrl;\n    video.load();\n  };\n\n  // Handle video ended event\n  const handleEnded = () => {\n    console.log('Video ended');\n    \n    // Check if we have a next segment\n    if (currentSegmentIndex < segments.length - 1) {\n      // Play next segment\n      const nextIndex = currentSegmentIndex + 1;\n      console.log(`Playing next segment ${nextIndex}`);\n      \n      // Update timeline state\n      timelineState.setState({\n        currentSegmentIndex: nextIndex,\n        currentTime: segments[nextIndex].start_timestamp,\n        isPlaying: true,\n        forceReload: true\n      });\n    } else {\n      // End of all segments\n      console.log('End of all segments');\n      \n      // Update timeline state\n      timelineState.setState({\n        isPlaying: false\n      });\n    }\n  };\n\n  // Handle video time update event\n  const handleTimeUpdate = () => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have a valid segment\n    if (currentSegmentIndex < 0 || \n        !segments || \n        segments.length === 0 || \n        currentSegmentIndex >= segments.length) {\n      return;\n    }\n    \n    const segment = segments[currentSegmentIndex];\n    if (!segment) return;\n    \n    // Calculate current timestamp\n    const currentTime = segment.start_timestamp + video.currentTime;\n    \n    // Directly update the time display as well\n    updateTimeDisplay(currentTime);\n    \n    // Update timeline state with the current time\n    timelineState.setState({\n      currentTime: currentTime,\n      prevCurrentTime: lastTimeUpdateRef.current\n    });\n    \n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n  };\n\n  // Add a direct time display update function\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  return html`\n    <div class=\"timeline-player-container mb-2\" id=\"video-player\">\n      <div class=\"relative w-full bg-black rounded-lg shadow-md\" style=\"aspect-ratio: 16/9;\">\n        <video\n            ref=${videoRef}\n            class=\"w-full h-full object-contain\"\n            controls\n            autoplay=${false}\n            muted=${false}\n            playsInline\n            onended=${handleEnded}\n            ontimeupdate=${handleTimeUpdate}\n        ></video>\n        \n        <!-- Add a message for invalid segments -->\n        <div \n          class=\"absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-center p-4 ${currentSegmentIndex >= 0 && segments.length > 0 ? 'hidden' : ''}\"\n        >\n          <div>\n            <p class=\"mb-2\">No valid segment selected.</p>\n            <p class=\"text-sm\">Click on a segment in the timeline or use the play button to start playback.</p>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Playback speed controls -->\n    <${SpeedControls} />\n  `;\n}\n","/**\n * LightNVR Timeline Page Component\n * Main component for the timeline view\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { TimelineControls } from './TimelineControls.js';\nimport { TimelineRuler } from './TimelineRuler.js';\nimport { TimelineSegments } from './TimelineSegments.js';\nimport { TimelineCursor } from './TimelineCursor.js';\nimport { TimelinePlayer } from './TimelinePlayer.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\nimport { LoadingIndicator } from '../LoadingIndicator.js';\nimport { useQuery } from '../../../query-client.js';\n\n// Global timeline state for child components\nconst timelineState = {\n  streams: [],\n  timelineSegments: [],\n  selectedStream: null,\n  selectedDate: null,\n  isPlaying: false,\n  currentSegmentIndex: -1,\n  zoomLevel: 1, // 1 = 1 hour, 2 = 30 minutes, 4 = 15 minutes\n  timelineStartHour: 0,\n  timelineEndHour: 24,\n  currentTime: null,\n  prevCurrentTime: null,\n  playbackSpeed: 1.0,\n  showOnlySegments: true,\n  forceReload: false,\n  userControllingCursor: false, // New flag to track if user is controlling cursor\n  listeners: new Set(),\n\n  // Last time state was updated\n  lastUpdateTime: 0,\n\n  // Pending state updates\n  pendingUpdates: {},\n\n  // Update state and notify listeners\n  setState(newState) {\n    const now = Date.now();\n\n    console.log('timelineState: setState called with', newState);\n    console.log('timelineState: current state before update', {\n      currentTime: this.currentTime,\n      currentSegmentIndex: this.currentSegmentIndex,\n      segmentsLength: this.timelineSegments.length\n    });\n\n    // For time-sensitive updates (like currentTime), we want to batch them\n    // to prevent too many updates in a short period\n    if (newState.currentTime !== undefined &&\n        !newState.currentSegmentIndex &&\n        !newState.isPlaying &&\n        now - this.lastUpdateTime < 250) {\n      // Skip frequent time updates that don't change playback state\n      console.log('timelineState: Skipping frequent time update');\n      return;\n    }\n\n    // Apply the new state\n    Object.assign(this, newState);\n\n    // Reset forceReload flag immediately\n    if (newState.forceReload) {\n      this.forceReload = false;\n    }\n\n    this.lastUpdateTime = now;\n\n    console.log('timelineState: state after update', {\n      currentTime: this.currentTime,\n      currentSegmentIndex: this.currentSegmentIndex,\n      segmentsLength: this.timelineSegments.length\n    });\n\n    this.notifyListeners();\n  },\n\n  // Subscribe to state changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  },\n\n  // Notify all listeners of state change\n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this));\n  },\n\n  // Flush any pending updates\n  flushPendingUpdates() {\n    if (Object.keys(this.pendingUpdates).length > 0) {\n      Object.assign(this, this.pendingUpdates);\n      this.pendingUpdates = {};\n      this.lastUpdateTime = Date.now();\n      this.notifyListeners();\n    }\n  }\n};\n\n/**\n * Format date for input element\n */\nfunction formatDateForInput(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/**\n * Parse URL parameters\n */\nfunction parseUrlParams() {\n  const params = new URLSearchParams(window.location.search);\n  return {\n    stream: params.get('stream') || '',\n    date: params.get('date') || formatDateForInput(new Date())\n  };\n}\n\n/**\n * Update URL parameters\n */\nfunction updateUrlParams(stream, date) {\n  if (!stream) return;\n  const url = new URL(window.location.href);\n  url.searchParams.set('stream', stream);\n  url.searchParams.set('date', date);\n  window.history.replaceState({}, '', url);\n}\n\n/**\n * TimelinePage component\n */\nexport function TimelinePage() {\n  // Get initial values from URL parameters\n  const urlParams = parseUrlParams();\n\n  // State\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamsList, setStreamsList] = useState([]);\n  const [selectedStream, setSelectedStream] = useState(urlParams.stream);\n  const [selectedDate, setSelectedDate] = useState(urlParams.date);\n  const [segments, setSegments] = useState([]);\n\n  // Refs\n  const timelineContainerRef = useRef(null);\n  const initialLoadRef = useRef(false);\n  const flushIntervalRef = useRef(null);\n\n  // Set up periodic flush of pending updates\n  useEffect(() => {\n    // Set up interval to flush pending updates every 200ms\n    flushIntervalRef.current = setInterval(() => {\n      timelineState.flushPendingUpdates();\n    }, 200);\n\n    // Clean up interval on unmount\n    return () => {\n      if (flushIntervalRef.current) {\n        clearInterval(flushIntervalRef.current);\n      }\n    };\n  }, []);\n\n  // Load streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery('streams', '/api/streams', {\n    timeout: 15000, // 15 second timeout\n    retries: 2,     // Retry twice\n    retryDelay: 1000 // 1 second between retries\n  });\n\n  // Handle initial data load when streams are available\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData) && streamsData.length > 0 && !initialLoadRef.current) {\n      console.log('TimelinePage: Streams loaded, initializing data');\n      initialLoadRef.current = true;\n\n      // Update streamsList state\n      setStreamsList(streamsData);\n\n      // Update global state for child components\n      timelineState.setState({ streams: streamsData });\n\n      // Check if the selected stream from URL exists\n      const streamExists = streamsData.some(s => s.name === selectedStream);\n\n      if (streamExists && selectedStream) {\n        console.log(`TimelinePage: Using stream from URL: ${selectedStream}`);\n      } else if (streamsData.length > 0) {\n        // Use first stream if URL stream doesn't exist\n        const firstStream = streamsData[0].name;\n        console.log(`TimelinePage: Using first stream: ${firstStream}`);\n        setSelectedStream(firstStream);\n      }\n    }\n  }, [streamsData]);\n\n  // Handle streams error\n  useEffect(() => {\n    if (streamsError) {\n      console.error('TimelinePage: Error loading streams:', streamsError);\n      showStatusMessage('Error loading streams: ' + streamsError.message, 'error');\n    }\n  }, [streamsError]);\n\n  // Calculate time range for timeline data\n  const getTimeRange = (date) => {\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n\n    const endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n\n    return {\n      startTime: startDate.toISOString(),\n      endTime: endDate.toISOString()\n    };\n  };\n\n  // Update URL and global state when stream or date changes\n  useEffect(() => {\n    if (selectedStream) {\n      // Update URL\n      updateUrlParams(selectedStream, selectedDate);\n\n      // Update global state\n      timelineState.setState({\n        selectedStream,\n        selectedDate\n      });\n    }\n  }, [selectedStream, selectedDate]);\n\n  // Get time range for current date\n  const { startTime, endTime } = getTimeRange(selectedDate);\n\n  // Fetch timeline segments using preact-query\n  const {\n    data: timelineData,\n    isLoading: isLoadingTimeline,\n    error: timelineError,\n    refetch: refetchTimeline\n  } = useQuery(\n    ['timeline-segments', selectedStream, selectedDate],\n    selectedStream ? `/api/timeline/segments?stream=${encodeURIComponent(selectedStream)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}` : null,\n    {\n      timeout: 30000, // 30 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    },\n    {\n      enabled: !!selectedStream, // Only run query if we have a selected stream\n      onSuccess: (data) => {\n        console.log('TimelinePage: Timeline data received:', data);\n        const timelineSegments = data.segments || [];\n        console.log(`TimelinePage: Received ${timelineSegments.length} segments`);\n\n        if (timelineSegments.length === 0) {\n          console.log('TimelinePage: No segments found');\n          setSegments([]);\n\n          // Update global state\n          timelineState.setState({\n            timelineSegments: [],\n            currentSegmentIndex: -1,\n            currentTime: null,\n            isPlaying: false\n          });\n\n          showStatusMessage('No recordings found for the selected date', 'warning');\n          return;\n        }\n\n        // IMPORTANT: Make a deep copy of the segments to avoid reference issues\n        const segmentsCopy = JSON.parse(JSON.stringify(timelineSegments));\n\n        // Log the first few segments for debugging\n        segmentsCopy.slice(0, 3).forEach((segment, i) => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n          console.log(`TimelinePage: Segment ${i} - Start: ${startTime.toLocaleTimeString()}, End: ${endTime.toLocaleTimeString()}`);\n        });\n\n        console.log('TimelinePage: Setting segments');\n        setSegments(segmentsCopy);\n\n        // Force a synchronous DOM update\n        document.body.offsetHeight;\n\n        // Directly update the global state with the segments\n        const firstSegmentStartTime = segmentsCopy[0].start_timestamp;\n\n        console.log('TimelinePage: Setting initial segment and time', {\n          firstSegmentId: segmentsCopy[0].id,\n          startTime: new Date(firstSegmentStartTime * 1000).toLocaleTimeString()\n        });\n\n        // DIRECT ASSIGNMENT to ensure state is properly set\n        console.log('TimelinePage: Directly setting timelineState properties');\n        timelineState.timelineSegments = segmentsCopy;\n        timelineState.currentSegmentIndex = 0;\n        timelineState.currentTime = firstSegmentStartTime;\n        timelineState.prevCurrentTime = firstSegmentStartTime;\n        timelineState.isPlaying = false;\n        timelineState.forceReload = true;\n        timelineState.zoomLevel = 1;\n        timelineState.selectedDate = selectedDate; // Make sure the date is set\n\n        // Now call setState to notify listeners\n        timelineState.setState({\n          // Empty object just to trigger notification\n        });\n\n        console.log('TimelinePage: Updated timelineState with segments');\n\n        // Wait a moment to ensure state is updated, then log the current state\n        setTimeout(() => {\n          console.log('TimelinePage: State after update (delayed check):', {\n            segmentsLength: timelineState.timelineSegments.length,\n            currentSegmentIndex: timelineState.currentSegmentIndex,\n            currentTime: timelineState.currentTime\n          });\n\n          // Force a state update if the state wasn't properly updated\n          if (!timelineState.currentTime || timelineState.currentSegmentIndex === -1) {\n            console.log('TimelinePage: State not properly updated, forcing update');\n            timelineState.setState({\n              currentSegmentIndex: 0,\n              currentTime: firstSegmentStartTime,\n              prevCurrentTime: firstSegmentStartTime\n            });\n          }\n        }, 100);\n\n        // Preload the first segment's video\n        const videoPlayer = document.querySelector('#video-player video');\n        if (videoPlayer) {\n          videoPlayer.src = `/api/recordings/play/${segmentsCopy[0].id}?t=${Date.now()}`;\n          videoPlayer.load();\n        }\n\n        showStatusMessage(`Loaded ${segmentsCopy.length} recording segments`, 'success');\n      },\n      onError: (error) => {\n        console.error('TimelinePage: Error loading timeline data:', error);\n        showStatusMessage('Error loading timeline data: ' + error.message, 'error');\n        setSegments([]);\n      }\n    }\n  );\n\n  // Handle stream selection change\n  const handleStreamChange = (e) => {\n    const newStream = e.target.value;\n    console.log(`TimelinePage: Stream changed to ${newStream}`);\n    setSelectedStream(newStream);\n  };\n\n  // Handle date selection change\n  const handleDateChange = (e) => {\n    const newDate = e.target.value;\n    console.log(`TimelinePage: Date changed to ${newDate}`);\n    setSelectedDate(newDate);\n  };\n\n  // Render content based on state\n  const renderContent = () => {\n    if (isLoadingTimeline) {\n      return html`<${LoadingIndicator} message=\"Loading timeline data...\" />`;\n    }\n\n    if (segments.length === 0) {\n      return html`\n        <div class=\"flex flex-col items-center justify-center py-12 text-center\">\n          <svg class=\"w-16 h-16 text-gray-400 dark:text-gray-600 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path>\n          </svg>\n          <p class=\"text-gray-600 dark:text-gray-400 text-lg\">No recordings found for the selected date and stream</p>\n        </div>\n      `;\n    }\n\n    return html`\n      <!-- Video player -->\n      <${TimelinePlayer} />\n\n      <!-- Playback controls -->\n      <${TimelineControls} />\n\n        <!-- Timeline -->\n        <div\n            id=\"timeline-container\"\n            class=\"relative w-full h-24 bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg mb-6 overflow-hidden\"\n            ref=${timelineContainerRef}\n        >\n          <${TimelineRuler} />\n          <${TimelineSegments} segments=${segments} />\n          <${TimelineCursor} />\n\n          <!-- Instructions for cursor -->\n          <div class=\"absolute bottom-1 right-2 text-xs text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 px-2 py-1 rounded\">\n            Drag the orange dial to navigate\n          </div>\n        </div>\n    `;\n  };\n\n  return html`\n    <div class=\"timeline-page\">\n      <div class=\"flex items-center mb-4\">\n        <h1 class=\"text-2xl font-bold\">Timeline Playback</h1>\n        <div class=\"ml-4 flex\">\n          <a href=\"recordings.html\" class=\"px-3 py-1 bg-gray-300 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-l-md\">Table View</a>\n          <a href=\"timeline.html\" class=\"px-3 py-1 bg-blue-500 text-white rounded-r-md\">Timeline View</a>\n        </div>\n      </div>\n\n      <!-- Stream selector and date picker -->\n      <div class=\"flex flex-wrap gap-4 mb-2\">\n        <div class=\"stream-selector flex-grow\">\n          <div class=\"flex justify-between items-center mb-2\">\n            <label for=\"stream-selector\">Stream</label>\n            <button\n              class=\"text-xs bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 px-2 py-1 rounded\"\n              onClick=${() => refetchTimeline()}\n            >\n              Reload Data\n            </button>\n          </div>\n          <select\n              id=\"stream-selector\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedStream || ''}\n              onChange=${handleStreamChange}\n          >\n            <option value=\"\" disabled>Select a stream (${streamsList.length} available)</option>\n            ${streamsList.map(stream => html`\n              <option key=${stream.name} value=${stream.name}>${stream.name}</option>\n            `)}\n          </select>\n        </div>\n\n        <div class=\"date-selector flex-grow\">\n          <label for=\"timeline-date\" class=\"block mb-2\">Date</label>\n          <input\n              type=\"date\"\n              id=\"timeline-date\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedDate}\n              onChange=${handleDateChange}\n          />\n        </div>\n      </div>\n\n      <!-- Auto-load message -->\n      <div class=\"mb-4 text-sm text-gray-500 dark:text-gray-400 italic\">\n        ${isLoadingTimeline ? 'Loading...' : 'Recordings auto-load when stream or date changes'}\n      </div>\n\n      <!-- Current time display -->\n      <div class=\"flex justify-between items-center mb-2\">\n        <div id=\"time-display\" class=\"timeline-time-display bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded font-mono text-base\">00:00:00</div>\n      </div>\n\n      <!-- Debug info -->\n      <div class=\"mb-2 text-xs text-gray-500\">\n        Debug - isLoading: ${isLoadingTimeline ? 'true' : 'false'},\n        Streams: ${streamsList.length},\n        Segments: ${segments.length}\n      </div>\n\n      <!-- Content -->\n      ${renderContent()}\n\n      <!-- Instructions -->\n      <div class=\"mt-6 p-4 bg-gray-200 dark:bg-gray-800 rounded\">\n        <h3 class=\"text-lg font-semibold mb-2\">How to use the timeline:</h3>\n        <ul class=\"list-disc pl-5\">\n          <li>Select a stream and date to load recordings</li>\n          <li>Click on the timeline to position the cursor at a specific time</li>\n          <li>Drag the orange cursor to navigate precisely</li>\n          <li>Click on a segment (blue bar) to play that recording</li>\n          <li>Use the play button to start playback from the current cursor position</li>\n          <li>Use the zoom buttons to adjust the timeline scale</li>\n        </ul>\n      </div>\n    </div>\n  `;\n}\n\n// Export the timeline state for use in other components\nexport { timelineState };\n","/**\n * LightNVR Timeline View Component\n * Loads the Timeline page component into the main content area\n */\n\nimport { render } from 'preact';\nimport { html } from '../../../html-helper.js';\nimport { TimelinePage } from './TimelinePage.js';\nimport { QueryClientProvider, queryClient } from '../../../query-client.js';\n\n/**\n * Load TimelineView component\n */\nexport function loadTimelineView() {\n  const mainContent = document.getElementById('main-content');\n  if (!mainContent) return;\n\n  // Clear any existing content\n  mainContent.innerHTML = '';\n\n  // Render the TimelinePage component to the container wrapped with QueryClientProvider\n  render(\n    html`<${QueryClientProvider} client=${queryClient}>\n      <${TimelinePage} />\n    <//>`,\n    mainContent\n  );\n}"],"names":["TimelineControls","isPlaying","setIsPlaying","useState","zoomLevel","setZoomLevel","useEffect","unsubscribe","timelineState","state","togglePlayback","pausePlayback","resumePlayback","videoPlayer","showStatusMessage","segmentToPlay","segmentIndex","relativeTime","i","segment","closestIndex","minDistance","midpoint","distance","videoElement","handleMetadataLoaded","validTime","checkPlayback","attempt","e","segmentDuration","monitorInterval","error","zoomIn","newZoomLevel","zoomOut","html","_c","__template","_a","_b","TimelineRuler","startHour","setStartHour","endHour","setEndHour","hoursPerView","centerHour","currentDate","earliestHour","latestHour","startTime","endTime","newStartHour","newEndHour","generateHourMarkers","markers","hour","position","_d","_e","halfHourPosition","_f","quarterHourPosition1","quarterHourPosition3","_g","_h","_i","TimelineSegments","propSegments","segments","setSegments","currentSegmentIndex","setCurrentSegmentIndex","containerRef","useRef","isDragging","lastSegmentsUpdateRef","lastSegmentsRef","container","handleMouseDown","handleTimelineClick","handleMouseMove","handleMouseUp","event","rect","clickX","containerWidth","clickPercent","clickHour","clickDate","clickTimestamp","foundSegment","startTimestamp","endTimestamp","playSegment","index","absoluteTime","seekTime","renderSegments","_j","visibleSegments","hourMap","visibleCount","skippedCount","startHourFloat","endHourFloat","startFloorHour","endCeilHour","h","mergedSegments","currentMergedSegment","b","segmentStart","mergedEnd","mergedIndex","segStartTimestamp","segEndTimestamp","visibleStartHour","visibleEndHour","startPercent","widthPercent","duration","durationStr","startTimeStr","endTimeStr","_k","width","_l","_m","TimelineCursor","setPosition","visible","setVisible","currentTime","setCurrentTime","setIsDragging","cursorRef","dragStartXRef","debouncedUpdateCursorPosition","func","delay","timeoutId","args","time","startHr","endHr","updateCursorPosition","updateTimeDisplay","cursor","positionPercent","hourRange","date","timestamp","closestSegment","timeDisplay","hours","minutes","seconds","initCursor","_n","SpeedControls","currentSpeed","setCurrentSpeed","speeds","setPlaybackSpeed","speed","_p","_o","TimelinePlayer","playbackSpeed","videoRef","lastTimeUpdateRef","lastSegmentIdRef","handleVideoPlayback","video","segmentChanged","needsReload","timeChanged","loadSegment","autoplay","recordingUrl","onLoadedMetadata","handleEnded","nextIndex","handleTimeUpdate","_q","newState","now","listener","formatDateForInput","year","month","day","parseUrlParams","params","updateUrlParams","stream","url","TimelinePage","urlParams","isLoading","setIsLoading","streamsList","setStreamsList","selectedStream","setSelectedStream","selectedDate","setSelectedDate","timelineContainerRef","initialLoadRef","flushIntervalRef","streamsData","isLoadingStreams","streamsError","useQuery","s","firstStream","getTimeRange","startDate","endDate","timelineData","isLoadingTimeline","timelineError","refetchTimeline","data","timelineSegments","segmentsCopy","firstSegmentStartTime","handleStreamChange","newStream","handleDateChange","newDate","renderContent","_r","LoadingIndicator","_s","_t","_v","_u","loadTimelineView","mainContent","render","_w","QueryClientProvider","queryClient"],"mappings":"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"}