{"version":3,"file":"TimelineView-legacy-DLv9LEwf.js","sources":["../../js/components/preact/timeline/TimelineControls.js","../../js/components/preact/timeline/TimelineRuler.js","../../js/components/preact/timeline/TimelineSegments.js","../../js/components/preact/timeline/TimelineCursor.js","../../js/components/preact/timeline/SpeedControls.js","../../js/components/preact/timeline/TimelinePlayer.js","../../js/components/preact/timeline/TimelineView.js","../../js/components/preact/timeline/TimelinePage.js"],"sourcesContent":["/**\n * LightNVR Timeline Controls Component\n * Handles play/pause and zoom controls for the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelineControls component\n * @returns {JSX.Element} TimelineControls component\n */\nexport function TimelineControls() {\n  // Local state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineControls: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineControls: Received state update:', state);\n      console.log('TimelineControls: Is playing:', state.isPlaying);\n      console.log('TimelineControls: Zoom level:', state.zoomLevel);\n      console.log('TimelineControls: Segments count:', state.timelineSegments?.length || 0);\n      \n      setIsPlaying(state.isPlaying);\n      setZoomLevel(state.zoomLevel);\n    });\n    \n    // Log initial state\n    console.log('TimelineControls: Initial timelineState:', timelineState);\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Toggle playback (play/pause)\n  const togglePlayback = () => {\n    if (isPlaying) {\n      pausePlayback();\n    } else {\n      resumePlayback();\n    }\n  };\n\n  // Pause playback\n  const pausePlayback = () => {\n    timelineState.setState({ isPlaying: false });\n    \n    // If there's a video player, pause it\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      videoPlayer.pause();\n    }\n  };\n\n  // Resume playback\n  const resumePlayback = () => {\n    // If no segments, show message and return\n    if (!timelineState.timelineSegments || timelineState.timelineSegments.length === 0) {\n      showStatusMessage('No recordings to play', 'warning');\n      return;\n    }\n    \n    // Find the earliest segment in the timeline\n    let earliestSegmentIndex = 0;\n    let earliestTimestamp = Number.MAX_SAFE_INTEGER;\n    \n    timelineState.timelineSegments.forEach((segment, index) => {\n      if (segment.start_timestamp < earliestTimestamp) {\n        earliestTimestamp = segment.start_timestamp;\n        earliestSegmentIndex = index;\n      }\n    });\n    \n    console.log(`Starting from earliest segment (index ${earliestSegmentIndex})`);\n    \n    // Start playing from the earliest segment\n    timelineState.setState({ \n      currentSegmentIndex: earliestSegmentIndex,\n      currentTime: timelineState.timelineSegments[earliestSegmentIndex].start_timestamp,\n      isPlaying: true,\n      forceReload: true // Force reload to ensure video player updates\n    });\n    \n    // Force load the earliest segment's video\n    const segment = timelineState.timelineSegments[earliestSegmentIndex];\n    const videoPlayer = document.querySelector('#video-player video');\n    \n    if (videoPlayer) {\n      console.log('Loading earliest segment video:', segment);\n      \n      // Pause any current playback\n      videoPlayer.pause();\n      \n      // Clear the source and reload\n      videoPlayer.removeAttribute('src');\n      videoPlayer.load();\n      \n      // Set the new source with a timestamp to prevent caching\n      videoPlayer.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n      \n      // Set the current time and play\n      videoPlayer.onloadedmetadata = () => {\n        videoPlayer.currentTime = 0;\n        videoPlayer.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      };\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index) => {\n    // This function will be implemented in the TimelinePlayer component\n    // Here we just update the state\n    timelineState.setState({ \n      currentSegmentIndex: index,\n      isPlaying: true \n    });\n  };\n\n  // Zoom in on timeline\n  const zoomIn = () => {\n    if (zoomLevel < 8) {\n      const newZoomLevel = zoomLevel * 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed in: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  // Zoom out on timeline\n  const zoomOut = () => {\n    if (zoomLevel > 1) {\n      const newZoomLevel = zoomLevel / 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed out: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  return html`\n    <div class=\"timeline-controls flex justify-between items-center mb-2\">\n      <div class=\"flex items-center\">\n        <button \n          id=\"play-button\" \n          class=\"w-10 h-10 rounded-full bg-green-600 hover:bg-green-700 text-white flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-offset-1 transition-colors shadow-sm mr-2\"\n          onClick=${togglePlayback}\n          title=${isPlaying ? 'Pause' : 'Play from earliest recording'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            ${isPlaying \n              ? html`\n                <!-- Pause icon - two vertical bars -->\n                <rect x=\"6\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n                <rect x=\"14\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n              `\n              : html`\n                <!-- Play icon - triangle -->\n                <path d=\"M8 5.14v14l11-7-11-7z\" fill=\"white\" />\n              `\n            }\n          </svg>\n        </button>\n        <span class=\"text-xs text-gray-600 dark:text-gray-300\">Play from earliest recording</span>\n      </div>\n      \n      <div class=\"flex items-center gap-1\">\n        <span class=\"text-xs text-gray-600 dark:text-gray-300 mr-1\">Zoom:</span>\n        <button \n          id=\"zoom-out-button\" \n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomOut}\n          title=\"Zoom Out (Show more time)\"\n          disabled=${zoomLevel <= 1}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n        <button \n          id=\"zoom-in-button\" \n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomIn}\n          title=\"Zoom In (Show less time)\"\n          disabled=${zoomLevel >= 8}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Ruler Component\n * Displays the time ruler with hour markers\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineRuler component\n * @returns {JSX.Element} TimelineRuler component\n */\nexport function TimelineRuler() {\n  // Local state\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineRuler: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineRuler: Received state update:', state);\n      console.log('TimelineRuler: Zoom level:', state.zoomLevel);\n      \n      // Calculate time range based on zoom level\n      const hoursPerView = 24 / state.zoomLevel;\n      console.log('TimelineRuler: Hours per view:', hoursPerView);\n      \n      // Calculate the center hour based on current time or segments\n      let centerHour = 12; // Default to noon\n      \n      if (state.currentTime !== null) {\n        // If we have a current time, use it as the center\n        const currentDate = new Date(state.currentTime * 1000);\n        centerHour = currentDate.getHours() + (currentDate.getMinutes() / 60) + (currentDate.getSeconds() / 3600);\n      } else if (state.timelineSegments && state.timelineSegments.length > 0) {\n        // If we have segments but no current time, use the middle of the segments\n        let earliestHour = 24;\n        let latestHour = 0;\n        \n        state.timelineSegments.forEach(segment => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n          \n          const startHour = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n          const endHour = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n          \n          earliestHour = Math.min(earliestHour, startHour);\n          latestHour = Math.max(latestHour, endHour);\n        });\n        \n        centerHour = (earliestHour + latestHour) / 2;\n      }\n      \n      // Calculate start and end hours based on center and zoom level\n      let newStartHour = Math.max(0, centerHour - (hoursPerView / 2));\n      let newEndHour = Math.min(24, newStartHour + hoursPerView);\n      \n      // Adjust start hour if end hour is at the limit\n      if (newEndHour === 24 && hoursPerView < 24) {\n        newStartHour = Math.max(0, 24 - hoursPerView);\n        newEndHour = 24;\n      } else if (newStartHour === 0 && hoursPerView < 24) {\n        newEndHour = Math.min(24, hoursPerView);\n      }\n      \n      console.log('TimelineRuler: New hour range:', { newStartHour, newEndHour });\n      \n      // Update local state\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setZoomLevel(state.zoomLevel);\n      \n      // Only update global state if the values have actually changed\n      // to prevent infinite recursion\n      if (timelineState.timelineStartHour !== newStartHour || \n          timelineState.timelineEndHour !== newEndHour) {\n        timelineState.setState({\n          timelineStartHour: newStartHour,\n          timelineEndHour: newEndHour\n        });\n      }\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Generate hour markers and labels\n  const generateHourMarkers = () => {\n    const markers = [];\n    const hourWidth = 100 / (endHour - startHour);\n    \n    // Add hour markers and labels\n    for (let hour = Math.floor(startHour); hour <= Math.ceil(endHour); hour++) {\n      if (hour >= 0 && hour <= 24) {\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        \n        // Add hour marker\n        markers.push(html`\n          <div \n            key=\"tick-${hour}\" \n            class=\"absolute top-0 w-px h-5 bg-gray-500 dark:bg-gray-400\" \n            style=\"left: ${position}%;\"\n          ></div>\n        `);\n        \n        // Add hour label\n        markers.push(html`\n          <div \n            key=\"label-${hour}\" \n            class=\"absolute top-0 text-xs text-gray-600 dark:text-gray-300 transform -translate-x-1/2\" \n            style=\"left: ${position}%;\"\n          >\n            ${hour}:00\n          </div>\n        `);\n        \n        // Add half-hour marker if not the last hour and we're zoomed in enough\n        if (hour < 24 && zoomLevel >= 2) {\n          const halfHourPosition = ((hour + 0.5 - startHour) / (endHour - startHour)) * 100;\n          markers.push(html`\n            <div \n              key=\"tick-${hour}-30\" \n              class=\"absolute top-2 w-px h-3 bg-gray-400 dark:bg-gray-500\" \n              style=\"left: ${halfHourPosition}%;\"\n            ></div>\n          `);\n          \n          // Add 15-minute markers if zoomed in even more\n          if (zoomLevel >= 4) {\n            const quarterHourPosition1 = ((hour + 0.25 - startHour) / (endHour - startHour)) * 100;\n            const quarterHourPosition3 = ((hour + 0.75 - startHour) / (endHour - startHour)) * 100;\n            \n            markers.push(html`\n              <div \n                key=\"tick-${hour}-15\" \n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\" \n                style=\"left: ${quarterHourPosition1}%;\"\n              ></div>\n            `);\n            \n            markers.push(html`\n              <div \n                key=\"tick-${hour}-45\" \n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\" \n                style=\"left: ${quarterHourPosition3}%;\"\n              ></div>\n            `);\n          }\n        }\n      }\n    }\n    \n    return markers;\n  };\n\n  return html`\n    <div class=\"timeline-ruler relative w-full h-8 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-600\">\n      ${generateHourMarkers()}\n      <div class=\"absolute bottom-0 left-0 text-xs text-gray-500 px-1\">\n        Zoom: ${zoomLevel}x (${Math.round(24 / zoomLevel)} hours)\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Segments Component\n * Displays recording segments on the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelineSegments component\n * @returns {JSX.Element} TimelineSegments component\n */\nexport function TimelineSegments() {\n  // Local state\n  const [segments, setSegments] = useState([]);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  \n  // Refs\n  const containerRef = useRef(null);\n  const isDragging = useRef(false);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineSegments: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineSegments: Received state update');\n      \n      // Update segments\n      if (state.timelineSegments) {\n        console.log(`TimelineSegments: Updating segments (${state.timelineSegments.length})`);\n        setSegments(state.timelineSegments);\n      }\n      \n      // Update other state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n      setCurrentSegmentIndex(state.currentSegmentIndex || -1);\n    });\n    \n    // Check if we already have segments in the timelineState\n    if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n      console.log(`TimelineSegments: Initial segments available (${timelineState.timelineSegments.length})`);\n      setSegments(timelineState.timelineSegments);\n      setCurrentSegmentIndex(timelineState.currentSegmentIndex || 0);\n    }\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set up drag handling\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    \n    const handleMouseDown = (e) => {\n      // Only handle clicks on the container itself, not on segments\n      if (e.target === container || e.target.classList.contains('timeline-clickable-area')) {\n        isDragging.current = true;\n        handleTimelineClick(e);\n        \n        // Add event listeners for drag\n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n      }\n    };\n    \n    const handleMouseMove = (e) => {\n      if (!isDragging.current) return;\n      handleTimelineClick(e);\n    };\n    \n    const handleMouseUp = () => {\n      isDragging.current = false;\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n    \n    container.addEventListener('mousedown', handleMouseDown);\n    \n    return () => {\n      container.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [startHour, endHour, segments]);\n\n  // Handle click on timeline for seeking\n  const handleTimelineClick = (event) => {\n    const container = containerRef.current;\n    if (!container) return;\n    \n    // Get click position relative to container\n    const rect = container.getBoundingClientRect();\n    const clickX = event.clientX - rect.left;\n    const containerWidth = rect.width;\n    \n    // Calculate time based on click position\n    const clickPercent = clickX / containerWidth;\n    const clickHour = startHour + (clickPercent * (endHour - startHour));\n    \n    // Find the segment that contains this time\n    const clickDate = new Date(timelineState.selectedDate);\n    clickDate.setHours(Math.floor(clickHour));\n    clickDate.setMinutes(Math.floor((clickHour % 1) * 60));\n    clickDate.setSeconds(Math.floor(((clickHour % 1) * 60) % 1 * 60));\n    \n    const clickTimestamp = clickDate.getTime() / 1000;\n    \n    // Find segment that contains this timestamp\n    let foundSegment = false;\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      if (clickTimestamp >= segment.start_timestamp && clickTimestamp <= segment.end_timestamp) {\n        console.log(`TimelineSegments: Found segment ${i} containing timestamp`);\n        \n        // Calculate relative time within the segment\n        const relativeTime = clickTimestamp - segment.start_timestamp;\n        \n        // Update current segment index\n        setCurrentSegmentIndex(i);\n        \n        // Play this segment starting at the clicked time\n        playSegment(i, relativeTime);\n        foundSegment = true;\n        break;\n      }\n    }\n    \n    if (!foundSegment) {\n      if (segments.length > 0) {\n        console.log('TimelineSegments: No segment contains the timestamp, finding closest segment');\n        // Find the closest segment\n        let closestSegment = -1;\n        let minDistance = Infinity;\n        \n        for (let i = 0; i < segments.length; i++) {\n          const segment = segments[i];\n          const startDistance = Math.abs(segment.start_timestamp - clickTimestamp);\n          const endDistance = Math.abs(segment.end_timestamp - clickTimestamp);\n          const distance = Math.min(startDistance, endDistance);\n          \n          if (distance < minDistance) {\n            minDistance = distance;\n            closestSegment = i;\n          }\n        }\n        \n        if (closestSegment >= 0) {\n          console.log(`TimelineSegments: Playing closest segment ${closestSegment}`);\n          \n          // Play the closest segment\n          playSegment(closestSegment);\n        }\n      } else {\n        // No segments found, just update the currentTime\n        console.log('TimelineSegments: No segments found, just updating currentTime');\n        timelineState.setState({ \n          currentTime: clickTimestamp,\n          prevCurrentTime: timelineState.currentTime\n        });\n      }\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index, relativeTime = null) => {\n    console.log(`TimelineSegments: playSegment(${index}, ${relativeTime})`);\n    \n    if (index < 0 || index >= segments.length) {\n      console.warn(`TimelineSegments: Invalid segment index: ${index}`);\n      return;\n    }\n    \n    const segment = segments[index];\n    \n    // Calculate absolute timestamp for currentTime\n    const absoluteTime = relativeTime !== null \n      ? segment.start_timestamp + relativeTime \n      : segment.start_timestamp;\n    \n    // First, pause any current playback and reset the segment index\n    timelineState.setState({ \n      isPlaying: false,\n      currentSegmentIndex: -1\n    });\n    \n    // Force a synchronous DOM update\n    document.body.offsetHeight;\n    \n    // Now set the new segment index and start playing\n    setTimeout(() => {\n      timelineState.setState({ \n        currentSegmentIndex: index,\n        currentTime: absoluteTime,\n        isPlaying: true,\n        forceReload: true\n      });\n      \n      // Force the video player to reload\n      setTimeout(() => {\n        const videoElement = document.querySelector('#video-player video');\n        if (videoElement) {\n          // Pause any current playback\n          videoElement.pause();\n          \n          // Clear the source and reload\n          videoElement.removeAttribute('src');\n          videoElement.load();\n          \n          // Set the new source\n          videoElement.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n          \n          // Set the current time and play\n          videoElement.onloadedmetadata = () => {\n            const seekTime = relativeTime !== null ? relativeTime : 0;\n            videoElement.currentTime = seekTime;\n            videoElement.play().catch(e => console.error('Error playing video:', e));\n          };\n        }\n      }, 50);\n    }, 50);\n  };\n\n  // Render segments\n  const renderSegments = () => {\n    console.log(`TimelineSegments: Rendering ${segments.length} segments`);\n    \n    if (!segments || segments.length === 0) {\n      return null;\n    }\n    \n    const visibleSegments = [];\n    const hourMap = new Map();\n    \n    // First pass: collect all segments by hour\n    segments.forEach((segment, index) => {\n      // Convert timestamps to Date objects\n      const startTime = new Date(segment.start_timestamp * 1000);\n      const endTime = new Date(segment.end_timestamp * 1000);\n      \n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n      \n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n      \n      // Mark each hour that this segment spans\n      const startFloorHour = Math.floor(startHourFloat);\n      const endCeilHour = Math.min(Math.ceil(endHourFloat), 24);\n      \n      for (let h = startFloorHour; h < endCeilHour; h++) {\n        if (h >= startHour && h <= endHour) {\n          if (!hourMap.has(h)) {\n            hourMap.set(h, []);\n          }\n          hourMap.get(h).push(index);\n        }\n      }\n    });\n    \n    // Preprocess segments to merge adjacent ones\n    const mergedSegments = [];\n    let currentMergedSegment = null;\n    \n    // Sort segments by start time\n    const sortedSegments = [...segments].sort((a, b) => a.start_timestamp - b.start_timestamp);\n    \n    // Merge adjacent segments (no gap or very small gap)\n    sortedSegments.forEach((segment, index) => {\n      if (!currentMergedSegment) {\n        // First segment\n        currentMergedSegment = { ...segment, originalIndices: [index] };\n      } else {\n        // Check if this segment is adjacent to the current merged segment\n        // Allow a small gap (1 second) to account for rounding errors\n        const gap = segment.start_timestamp - currentMergedSegment.end_timestamp;\n        \n        if (gap <= 1) {\n          // Merge with current segment\n          currentMergedSegment.end_timestamp = segment.end_timestamp;\n          currentMergedSegment.originalIndices.push(index);\n          \n          // If this segment has detection, mark the merged segment as having detection\n          if (segment.has_detection) {\n            currentMergedSegment.has_detection = true;\n          }\n        } else {\n          // Gap is too large, start a new merged segment\n          mergedSegments.push(currentMergedSegment);\n          currentMergedSegment = { ...segment, originalIndices: [index] };\n        }\n      }\n    });\n    \n    // Add the last merged segment\n    if (currentMergedSegment) {\n      mergedSegments.push(currentMergedSegment);\n    }\n    \n    console.log(`TimelineSegments: Merged ${segments.length} segments into ${mergedSegments.length} segments`);\n    \n    // Second pass: add visible segments\n    mergedSegments.forEach((segment, mergedIndex) => {\n      // Convert timestamps to Date objects\n      const startTime = new Date(segment.start_timestamp * 1000);\n      const endTime = new Date(segment.end_timestamp * 1000);\n      \n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n      \n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n      \n      // Adjust start and end to fit within visible range\n      const visibleStartHour = Math.max(startHourFloat, startHour);\n      const visibleEndHour = Math.min(endHourFloat, endHour);\n      \n      // Calculate position and width as percentages\n      const startPercent = ((visibleStartHour - startHour) / (endHour - startHour)) * 100;\n      const widthPercent = ((visibleEndHour - visibleStartHour) / (endHour - startHour)) * 100;\n      \n      // Format duration for tooltip\n      const duration = Math.round(segment.end_timestamp - segment.start_timestamp);\n      const durationStr = `${duration}s`;\n      \n      // Format times for tooltip\n      const startTimeStr = startTime.toLocaleTimeString();\n      const endTimeStr = endTime.toLocaleTimeString();\n      \n      // Use a consistent height for all segments\n      const heightPercent = 80; // 80% height for all segments\n      \n      visibleSegments.push(html`\n        <div \n          key=\"segment-${mergedIndex}\"\n          class=\"timeline-segment absolute rounded-sm transition-all duration-200 ${segment.has_detection ? 'bg-red-500' : 'bg-blue-500'}\"\n          style=\"left: ${startPercent}%; width: ${widthPercent}%; height: ${heightPercent}%; top: 50%; transform: translateY(-50%);\"\n          title=\"${startTimeStr} - ${endTimeStr} (${durationStr})\"\n        ></div>\n      `);\n    });\n    \n    // Third pass: fill in gaps with clickable areas\n    for (let hour = Math.floor(startHour); hour < Math.ceil(endHour); hour++) {\n      if (!hourMap.has(hour)) {\n        // No segments in this hour, create a clickable area\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        const width = 100 / (endHour - startHour);\n        \n        visibleSegments.push(html`\n          <div \n            key=\"clickable-${hour}\"\n            class=\"timeline-clickable-area absolute h-full cursor-pointer\"\n            style=\"left: ${position}%; width: ${width}%;\"\n            data-hour=${hour}\n          ></div>\n        `);\n      }\n    }\n    \n    return visibleSegments;\n  };\n\n  return html`\n    <div \n      class=\"timeline-segments relative w-full h-16 pt-2\"\n      ref=${containerRef}\n    >\n      ${renderSegments()}\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Cursor Component\n * Displays the playback cursor on the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineCursor component\n * @returns {JSX.Element} TimelineCursor component\n */\nexport function TimelineCursor() {\n  // Local state\n  const [position, setPosition] = useState(0);\n  const [visible, setVisible] = useState(false);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentTime, setCurrentTime] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n  \n  // Refs\n  const cursorRef = useRef(null);\n  const containerRef = useRef(null);\n  const dragStartXRef = useRef(0);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n      setCurrentTime(state.currentTime);\n      \n      // Update time display\n      updateTimeDisplay(state.currentTime);\n      \n      // Update cursor position (only if not dragging)\n      if (!isDragging) {\n        updateCursorPosition(state.currentTime, state.timelineStartHour || 0, state.timelineEndHour || 24);\n      }\n    });\n    \n    return () => unsubscribe();\n  }, [isDragging]);\n\n  // Set up drag handling\n  useEffect(() => {\n    const cursor = cursorRef.current;\n    if (!cursor) return;\n    \n    const handleMouseDown = (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      // Store the starting X position\n      dragStartXRef.current = e.clientX;\n      \n      setIsDragging(true);\n      \n      // Add event listeners for drag\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    };\n    \n    const handleMouseMove = (e) => {\n      if (!isDragging) return;\n      \n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n      \n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n      \n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      setPosition(positionPercent);\n      \n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      \n      // Convert hour to timestamp\n      const date = new Date(timelineState.selectedDate);\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      \n      const timestamp = date.getTime() / 1000;\n      \n      // Update time display\n      updateTimeDisplay(timestamp);\n    };\n    \n    const handleMouseUp = (e) => {\n      if (!isDragging) return;\n      \n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n      \n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n      \n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      \n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      \n      // Convert hour to timestamp\n      const date = new Date(timelineState.selectedDate);\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      \n      const timestamp = date.getTime() / 1000;\n      \n      // Reset dragging state FIRST\n      setIsDragging(false);\n      \n      // Remove event listeners\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      \n      // Find segment that contains this timestamp\n      const segments = timelineState.timelineSegments || [];\n      let foundSegment = false;\n      \n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (timestamp >= segment.start_timestamp && timestamp <= segment.end_timestamp) {\n          // Calculate relative time within the segment\n          const relativeTime = timestamp - segment.start_timestamp;\n          \n          // Update timeline state\n          timelineState.setState({ \n            currentSegmentIndex: i,\n            currentTime: timestamp,\n            prevCurrentTime: timelineState.currentTime,\n            isPlaying: true\n          });\n          \n          foundSegment = true;\n          break;\n        }\n      }\n      \n      // If no segment found, find the closest one\n      if (!foundSegment && segments.length > 0) {\n        let closestSegment = 0;\n        let minDistance = Infinity;\n        \n        for (let i = 0; i < segments.length; i++) {\n          const segment = segments[i];\n          const startDistance = Math.abs(segment.start_timestamp - timestamp);\n          const endDistance = Math.abs(segment.end_timestamp - timestamp);\n          const distance = Math.min(startDistance, endDistance);\n          \n          if (distance < minDistance) {\n            minDistance = distance;\n            closestSegment = i;\n          }\n        }\n        \n        // Update timeline state\n        timelineState.setState({ \n          currentSegmentIndex: closestSegment,\n          currentTime: segments[closestSegment].start_timestamp,\n          prevCurrentTime: timelineState.currentTime,\n          isPlaying: true\n        });\n      }\n    };\n    \n    // Add event listeners\n    cursor.addEventListener('mousedown', handleMouseDown);\n    \n    return () => {\n      cursor.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [cursorRef.current, startHour, endHour, isDragging]);\n\n  // Update cursor position\n  const updateCursorPosition = (time, startHr, endHr) => {\n    if (time === null) {\n      setVisible(false);\n      return;\n    }\n    \n    // Calculate cursor position\n    const date = new Date(time * 1000);\n    const hour = date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n    \n    // Check if the current time is within the visible range\n    if (hour < startHr || hour > endHr) {\n      setVisible(false);\n      return;\n    }\n    \n    // Calculate position as percentage\n    const position = ((hour - startHr) / (endHr - startHr)) * 100;\n    \n    // Update cursor position\n    setPosition(position);\n    setVisible(true);\n  };\n\n  // Update time display\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  // Force the cursor to be visible on initial render\n  useEffect(() => {\n    // Set visible to true after a short delay\n    setTimeout(() => {\n      if (timelineState.currentTime) {\n        setVisible(true);\n        updateCursorPosition(\n          timelineState.currentTime, \n          timelineState.timelineStartHour || 0, \n          timelineState.timelineEndHour || 24\n        );\n      }\n    }, 500);\n  }, []);\n\n  return html`\n    <div \n      ref=${cursorRef}\n      class=\"timeline-cursor absolute top-0 h-full z-50 transition-all duration-100 cursor-ew-resize\"\n      style=\"left: ${position}%; display: ${visible ? 'block' : 'none'}; pointer-events: auto; width: 7px; margin-left: -3.5px;\"\n    >\n      <!-- Invisible wider clickable area -->\n      <div class=\"absolute top-0 bottom-0 left-0 w-full\"></div>\n      \n      <!-- Skinnier needle with no middle chunk -->\n      <div class=\"absolute top-0 bottom-0 w-0.5 bg-orange-500 left-1/2 transform -translate-x-1/2 pointer-events-none\"></div>\n      \n      <!-- Top handle (black) -->\n      <div class=\"absolute top-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 -translate-y-1/2 shadow-md pointer-events-none\"></div>\n      \n      <!-- Bottom handle (black) -->\n      <div class=\"absolute bottom-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 translate-y-1/2 shadow-md pointer-events-none\"></div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Speed Controls Component\n * Handles playback speed controls for the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * SpeedControls component\n * @returns {JSX.Element} SpeedControls component\n */\nexport function SpeedControls() {\n  // Local state\n  const [currentSpeed, setCurrentSpeed] = useState(1.0);\n  \n  // Available speeds\n  const speeds = [0.25, 0.5, 1.0, 1.5, 2.0, 4.0];\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('SpeedControls: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('SpeedControls: Received state update:', state);\n      console.log('SpeedControls: Playback speed:', state.playbackSpeed);\n      \n      setCurrentSpeed(state.playbackSpeed);\n    });\n    \n    // Log initial state\n    console.log('SpeedControls: Initial timelineState:', timelineState);\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set playback speed\n  const setPlaybackSpeed = (speed) => {\n    // Update video playback rate\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      // Store the current playback rate for debugging\n      const oldRate = videoPlayer.playbackRate;\n      \n      // Set the new playback rate\n      videoPlayer.playbackRate = speed;\n      \n      console.log(`Setting video playback rate from ${oldRate}x to ${speed}x`, videoPlayer);\n      console.log(`Actual playback rate after setting: ${videoPlayer.playbackRate}x`);\n      \n      // Force the playback rate again after a short delay\n      setTimeout(() => {\n        videoPlayer.playbackRate = speed;\n        console.log(`Re-setting playback rate to ${speed}x, actual rate: ${videoPlayer.playbackRate}x`);\n      }, 100);\n    } else {\n      console.warn('Video player element not found');\n    }\n    \n    // Update timeline state\n    timelineState.setState({ playbackSpeed: speed });\n    \n    // Show status message\n    showStatusMessage(`Playback speed: ${speed}x`, 'info');\n  };\n\n  return html`\n    <div class=\"mt-2 mb-4 p-2 border border-green-500 rounded-lg bg-white dark:bg-gray-800 shadow-sm\">\n      <div class=\"flex flex-col items-center\">\n        <div class=\"text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300\">Playback Speed</div>\n        \n        <div class=\"flex flex-wrap justify-center gap-1\">\n          ${speeds.map(speed => html`\n            <button \n              key=${`speed-${speed}`}\n              class=${`speed-btn px-2 py-1 text-sm rounded-full ${speed === currentSpeed \n                ? 'bg-green-500 text-white' \n                : 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600'} \n                font-medium transition-all focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-opacity-50`}\n              data-speed=${speed}\n              onClick=${() => setPlaybackSpeed(speed)}\n            >\n              ${speed === 1.0 ? '1× (Normal)' : `${speed}×`}\n            </button>\n          `)}\n        </div>\n        \n        <div class=\"mt-1 text-xs font-medium text-green-600 dark:text-green-400\">\n          Current: ${currentSpeed}× ${currentSpeed === 1.0 ? '(Normal)' : ''}\n        </div>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Player Component\n * Handles video playback for the timeline\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../../preact.hooks.module.js';\nimport { timelineState } from './TimelinePage.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelinePlayer component\n * @returns {JSX.Element} TimelinePlayer component\n */\nexport function TimelinePlayer() {\n  // Local state\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [segments, setSegments] = useState([]);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n\n  // Refs\n  const videoRef = useRef(null);\n  const lastTimeUpdateRef = useRef(null);\n  const lastSegmentIdRef = useRef(null);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setCurrentSegmentIndex(state.currentSegmentIndex);\n      setIsPlaying(state.isPlaying);\n      setSegments(state.timelineSegments || []);\n      setPlaybackSpeed(state.playbackSpeed);\n\n      // Handle video playback\n      handleVideoPlayback(state);\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Handle video playback based on state changes\n  const handleVideoPlayback = (state) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have valid segments and segment index\n    if (!state.timelineSegments || \n        state.timelineSegments.length === 0 || \n        state.currentSegmentIndex < 0 || \n        state.currentSegmentIndex >= state.timelineSegments.length) {\n      return;\n    }\n    \n    // Get current segment\n    const segment = state.timelineSegments[state.currentSegmentIndex];\n    if (!segment) return;\n    \n    // Check if we need to load a new segment\n    const segmentChanged = lastSegmentIdRef.current !== segment.id;\n    \n    // IMPORTANT: Only reload if the segment has actually changed\n    // This prevents constant reloading\n    const needsReload = segmentChanged;\n    \n    // Calculate relative time within the segment\n    const relativeTime = state.currentTime !== null && \n                         state.currentTime >= segment.start_timestamp\n      ? state.currentTime - segment.start_timestamp\n      : 0;\n    \n    // Only update the video if:\n    // 1. We need to load a new segment, OR\n    // 2. The user is dragging the cursor (indicated by a significant time change)\n    const timeChanged = state.prevCurrentTime !== null && \n                        Math.abs(state.currentTime - state.prevCurrentTime) > 1;\n    \n    // Update last segment ID\n    if (segmentChanged) {\n      console.log(`Segment changed from ${lastSegmentIdRef.current} to ${segment.id}`);\n      lastSegmentIdRef.current = segment.id;\n    }\n    \n    // Handle playback\n    if (needsReload) {\n      // Load new segment\n      console.log(`Loading new segment ${segment.id} (segmentChanged: ${segmentChanged})`);\n      loadSegment(segment, relativeTime, state.isPlaying);\n    } else if (timeChanged) {\n      // User is dragging the cursor, just update the current time\n      console.log(`Seeking to ${relativeTime}s within current segment`);\n      video.currentTime = relativeTime;\n    } else if (state.isPlaying && video.paused) {\n      // Resume playback if needed\n      video.play().catch(error => {\n        console.error('Error playing video:', error);\n      });\n    } else if (!state.isPlaying && !video.paused) {\n      // Pause playback if needed\n      video.pause();\n    }\n    \n    // Update playback speed if needed\n    if (video.playbackRate !== state.playbackSpeed) {\n      video.playbackRate = state.playbackSpeed;\n    }\n  };\n\n  // Load a segment\n  const loadSegment = (segment, seekTime = 0, autoplay = false) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    console.log(`Loading segment ${segment.id} at time ${seekTime}s, autoplay: ${autoplay}`);\n    \n    // Pause current playback\n    video.pause();\n    \n    // Set new source with timestamp to prevent caching\n    const recordingUrl = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n    \n    // Set up event listeners for the new video\n    const onLoadedMetadata = () => {\n      console.log('Video metadata loaded');\n      \n      // Set current time\n      video.currentTime = seekTime;\n      \n      // Set playback speed\n      video.playbackRate = playbackSpeed;\n      \n      // Play if needed\n      if (autoplay) {\n        video.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      }\n      \n      // Remove event listener\n      video.removeEventListener('loadedmetadata', onLoadedMetadata);\n    };\n    \n    // Add event listener for metadata loaded\n    video.addEventListener('loadedmetadata', onLoadedMetadata);\n    \n    // Set new source\n    video.src = recordingUrl;\n    video.load();\n  };\n\n  // Handle video ended event\n  const handleEnded = () => {\n    console.log('Video ended');\n    \n    // Check if we have a next segment\n    if (currentSegmentIndex < segments.length - 1) {\n      // Play next segment\n      const nextIndex = currentSegmentIndex + 1;\n      console.log(`Playing next segment ${nextIndex}`);\n      \n      // Update timeline state\n      timelineState.setState({\n        currentSegmentIndex: nextIndex,\n        currentTime: segments[nextIndex].start_timestamp,\n        isPlaying: true,\n        forceReload: true\n      });\n    } else {\n      // End of all segments\n      console.log('End of all segments');\n      \n      // Update timeline state\n      timelineState.setState({\n        isPlaying: false\n      });\n    }\n  };\n\n  // Handle video time update event\n  const handleTimeUpdate = () => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have a valid segment\n    if (currentSegmentIndex < 0 || \n        !segments || \n        segments.length === 0 || \n        currentSegmentIndex >= segments.length) {\n      return;\n    }\n    \n    const segment = segments[currentSegmentIndex];\n    if (!segment) return;\n    \n    // Calculate current timestamp\n    const currentTime = segment.start_timestamp + video.currentTime;\n    \n    // Directly update the time display as well\n    updateTimeDisplay(currentTime);\n    \n    // Update timeline state with the current time\n    timelineState.setState({\n      currentTime: currentTime,\n      prevCurrentTime: lastTimeUpdateRef.current\n    });\n    \n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n  };\n\n  // Add a direct time display update function\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  return html`\n    <div class=\"timeline-player-container mb-2\" id=\"video-player\">\n      <div class=\"relative w-full bg-black rounded-lg shadow-md\" style=\"aspect-ratio: 16/9;\">\n        <video\n            ref=${videoRef}\n            class=\"w-full h-full object-contain\"\n            controls\n            autoplay=${false}\n            muted=${false}\n            playsInline\n            onended=${handleEnded}\n            ontimeupdate=${handleTimeUpdate}\n        ></video>\n        \n        <!-- Add a message for invalid segments -->\n        <div \n          class=\"absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-center p-4 ${currentSegmentIndex >= 0 && segments.length > 0 ? 'hidden' : ''}\"\n        >\n          <div>\n            <p class=\"mb-2\">No valid segment selected.</p>\n            <p class=\"text-sm\">Click on a segment in the timeline or use the play button to start playback.</p>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Playback speed controls -->\n    <${SpeedControls} />\n  `;\n}\n","/**\n * LightNVR Timeline View Component\n * Loads the Timeline page component into the main content area\n */\n\nimport { h, render } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { TimelinePage } from './TimelinePage.js';\n\n/**\n * Load TimelineView component\n */\nexport function loadTimelineView() {\n  const mainContent = document.getElementById('main-content');\n  if (!mainContent) return;\n\n  // Clear any existing content\n  mainContent.innerHTML = '';\n\n  // Render the TimelinePage component to the container\n  render(html`<${TimelinePage} />`, mainContent);\n}","/**\n * LightNVR Timeline Page Component\n * Main component for the timeline view\n */\n\nimport { h } from '../../../preact.min.js';\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../../preact.hooks.module.js';\nimport { TimelineControls } from './TimelineControls.js';\nimport { TimelineRuler } from './TimelineRuler.js';\nimport { TimelineSegments } from './TimelineSegments.js';\nimport { TimelineCursor } from './TimelineCursor.js';\nimport { TimelinePlayer } from './TimelinePlayer.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\nimport { LoadingIndicator } from '../LoadingIndicator.js';\n\n// Global timeline state for child components\nconst timelineState = {\n  streams: [],\n  timelineSegments: [],\n  selectedStream: null,\n  selectedDate: null,\n  isPlaying: false,\n  currentSegmentIndex: -1,\n  zoomLevel: 1, // 1 = 1 hour, 2 = 30 minutes, 4 = 15 minutes\n  timelineStartHour: 0,\n  timelineEndHour: 24,\n  currentTime: null,\n  prevCurrentTime: null,\n  playbackSpeed: 1.0,\n  showOnlySegments: true,\n  forceReload: false,\n  listeners: new Set(),\n\n  // Update state and notify listeners\n  setState(newState) {\n    Object.assign(this, newState);\n    this.notifyListeners();\n  },\n\n  // Subscribe to state changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  },\n\n  // Notify all listeners of state change\n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this));\n  }\n};\n\n/**\n * Format date for input element\n */\nfunction formatDateForInput(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/**\n * Parse URL parameters\n */\nfunction parseUrlParams() {\n  const params = new URLSearchParams(window.location.search);\n  return {\n    stream: params.get('stream') || '',\n    date: params.get('date') || formatDateForInput(new Date())\n  };\n}\n\n/**\n * Update URL parameters\n */\nfunction updateUrlParams(stream, date) {\n  if (!stream) return;\n  const url = new URL(window.location.href);\n  url.searchParams.set('stream', stream);\n  url.searchParams.set('date', date);\n  window.history.replaceState({}, '', url);\n}\n\n/**\n * TimelinePage component\n */\nexport function TimelinePage() {\n  // Get initial values from URL parameters\n  const urlParams = parseUrlParams();\n  \n  // State\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamsList, setStreamsList] = useState([]);\n  const [selectedStream, setSelectedStream] = useState(urlParams.stream);\n  const [selectedDate, setSelectedDate] = useState(urlParams.date);\n  const [segments, setSegments] = useState([]);\n  \n  // Refs\n  const timelineContainerRef = useRef(null);\n  const initialLoadRef = useRef(false);\n  \n  // Load streams on mount\n  useEffect(() => {\n    console.log('TimelinePage: Initial mount, loading streams');\n    loadStreams();\n  }, []);\n  \n  // Handle initial data load when streams are available\n  useEffect(() => {\n    if (streamsList.length > 0 && !initialLoadRef.current) {\n      console.log('TimelinePage: Streams loaded, initializing data');\n      initialLoadRef.current = true;\n      \n      // Check if the selected stream from URL exists\n      const streamExists = streamsList.some(s => s.name === selectedStream);\n      \n      if (streamExists && selectedStream) {\n        console.log(`TimelinePage: Using stream from URL: ${selectedStream}`);\n        loadTimelineData(selectedStream, selectedDate);\n      } else if (streamsList.length > 0) {\n        // Use first stream if URL stream doesn't exist\n        const firstStream = streamsList[0].name;\n        console.log(`TimelinePage: Using first stream: ${firstStream}`);\n        setSelectedStream(firstStream);\n        loadTimelineData(firstStream, selectedDate);\n      }\n    }\n  }, [streamsList]);\n  \n  // Load streams\n  const loadStreams = () => {\n    console.log('TimelinePage: Loading streams');\n    setIsLoading(true);\n    \n    fetch('/api/streams')\n      .then(response => {\n        if (!response.ok) throw new Error('Failed to load streams');\n        return response.json();\n      })\n      .then(data => {\n        console.log('TimelinePage: Streams data received:', data);\n        \n        // Ensure we have an array\n        const streams = Array.isArray(data) ? data : [];\n        console.log(`TimelinePage: Loaded ${streams.length} streams`);\n        \n        // Update state\n        setStreamsList(streams);\n        setIsLoading(false);\n        \n        // Update global state for child components\n        timelineState.setState({ streams });\n        \n        if (streams.length > 0) {\n          console.log('TimelinePage: First stream:', streams[0]);\n        }\n      })\n      .catch(error => {\n        console.error('TimelinePage: Error loading streams:', error);\n        showStatusMessage('Error loading streams: ' + error.message, 'error');\n        setIsLoading(false);\n      });\n  };\n  \n  // Load timeline data\n  const loadTimelineData = (stream, date) => {\n    if (!stream) {\n      showStatusMessage('Please select a stream', 'error');\n      return;\n    }\n    \n    console.log(`TimelinePage: Loading timeline data for ${stream} on ${date}`);\n    setIsLoading(true);\n    setSegments([]);\n    showStatusMessage('Loading timeline data...', 'info');\n    \n    // Update URL\n    updateUrlParams(stream, date);\n    \n    // Calculate time range (full day)\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n    \n    const endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n    \n    // Format dates for API\n    const startTime = startDate.toISOString();\n    const endTime = endDate.toISOString();\n    \n    // Update global state\n    timelineState.setState({\n      selectedStream: stream,\n      selectedDate: date,\n      timelineSegments: [],\n      currentSegmentIndex: -1,\n      currentTime: null,\n      isPlaying: false\n    });\n    \n    // Fetch timeline segments\n    fetch(`/api/timeline/segments?stream=${encodeURIComponent(stream)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}`)\n      .then(response => {\n        if (!response.ok) throw new Error('Failed to load timeline data');\n        return response.json();\n      })\n      .then(data => {\n        console.log('TimelinePage: Timeline data received:', data);\n        const timelineSegments = data.segments || [];\n        console.log(`TimelinePage: Received ${timelineSegments.length} segments`);\n        \n        setIsLoading(false);\n        \n        if (timelineSegments.length === 0) {\n          console.log('TimelinePage: No segments found');\n          setSegments([]);\n          \n          // Update global state\n          timelineState.setState({\n            timelineSegments: [],\n            currentSegmentIndex: -1,\n            currentTime: null,\n            isPlaying: false\n          });\n          \n          showStatusMessage('No recordings found for the selected date', 'warning');\n          return;\n        }\n        \n        console.log('TimelinePage: Setting segments');\n        setSegments(timelineSegments);\n        \n        // Update global state with the first segment selected\n        const initialTime = timelineSegments[0].start_timestamp;\n        timelineState.setState({\n          timelineSegments,\n          currentSegmentIndex: 0,\n          currentTime: initialTime,\n          prevCurrentTime: initialTime,\n          isPlaying: false\n        });\n        \n        // Preload the first segment's video\n        const videoPlayer = document.querySelector('#video-player video');\n        if (videoPlayer) {\n          videoPlayer.src = `/api/recordings/play/${timelineSegments[0].id}`;\n          videoPlayer.load();\n        }\n        \n        showStatusMessage(`Loaded ${timelineSegments.length} recording segments`, 'success');\n      })\n      .catch(error => {\n        console.error('TimelinePage: Error loading timeline data:', error);\n        showStatusMessage('Error loading timeline data: ' + error.message, 'error');\n        setIsLoading(false);\n        setSegments([]);\n      });\n  };\n  \n  // Handle stream selection change\n  const handleStreamChange = (e) => {\n    const newStream = e.target.value;\n    console.log(`TimelinePage: Stream changed to ${newStream}`);\n    setSelectedStream(newStream);\n    \n    if (newStream) {\n      loadTimelineData(newStream, selectedDate);\n    }\n  };\n  \n  // Handle date selection change\n  const handleDateChange = (e) => {\n    const newDate = e.target.value;\n    console.log(`TimelinePage: Date changed to ${newDate}`);\n    setSelectedDate(newDate);\n    \n    if (selectedStream) {\n      loadTimelineData(selectedStream, newDate);\n    }\n  };\n  \n  // Render content based on state\n  const renderContent = () => {\n    if (isLoading) {\n      return html`<${LoadingIndicator} message=\"Loading timeline data...\" />`;\n    }\n    \n    if (segments.length === 0) {\n      return html`\n        <div class=\"flex flex-col items-center justify-center py-12 text-center\">\n          <svg class=\"w-16 h-16 text-gray-400 dark:text-gray-600 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path>\n          </svg>\n          <p class=\"text-gray-600 dark:text-gray-400 text-lg\">No recordings found for the selected date and stream</p>\n        </div>\n      `;\n    }\n    \n    return html`\n      <!-- Video player -->\n      <${TimelinePlayer} />\n\n      <!-- Playback controls -->\n      <${TimelineControls} />\n\n        <!-- Timeline -->\n        <div\n            id=\"timeline-container\"\n            class=\"relative w-full h-24 bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg mb-6 overflow-hidden\"\n            ref=${timelineContainerRef}\n        >\n          <${TimelineRuler} />\n          <${TimelineSegments} />\n          <${TimelineCursor} />\n          \n          <!-- Instructions for cursor -->\n          <div class=\"absolute bottom-1 right-2 text-xs text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 px-2 py-1 rounded\">\n            Drag the orange dial to navigate\n          </div>\n        </div>\n    `;\n  };\n  \n  return html`\n    <div class=\"timeline-page\">\n      <div class=\"flex items-center mb-4\">\n        <h1 class=\"text-2xl font-bold\">Timeline Playback</h1>\n        <div class=\"ml-4 flex\">\n          <a href=\"recordings.html\" class=\"px-3 py-1 bg-gray-300 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-l-md\">Table View</a>\n          <a href=\"timeline.html\" class=\"px-3 py-1 bg-blue-500 text-white rounded-r-md\">Timeline View</a>\n        </div>\n      </div>\n\n      <!-- Stream selector and date picker -->\n      <div class=\"flex flex-wrap gap-4 mb-2\">\n        <div class=\"stream-selector flex-grow\">\n          <div class=\"flex justify-between items-center mb-2\">\n            <label for=\"stream-selector\">Stream</label>\n            <button \n              class=\"text-xs bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 px-2 py-1 rounded\"\n              onClick=${() => loadStreams()}\n            >\n              Reload Streams\n            </button>\n          </div>\n          <select\n              id=\"stream-selector\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedStream || ''}\n              onChange=${handleStreamChange}\n          >\n            <option value=\"\" disabled>Select a stream (${streamsList.length} available)</option>\n            ${streamsList.map(stream => html`\n              <option key=${stream.name} value=${stream.name}>${stream.name}</option>\n            `)}\n          </select>\n        </div>\n\n        <div class=\"date-selector flex-grow\">\n          <label for=\"timeline-date\" class=\"block mb-2\">Date</label>\n          <input\n              type=\"date\"\n              id=\"timeline-date\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedDate}\n              onChange=${handleDateChange}\n          />\n        </div>\n      </div>\n      \n      <!-- Auto-load message -->\n      <div class=\"mb-4 text-sm text-gray-500 dark:text-gray-400 italic\">\n        ${isLoading ? 'Loading...' : 'Recordings auto-load when stream or date changes'}\n      </div>\n\n      <!-- Current time display -->\n      <div class=\"flex justify-between items-center mb-2\">\n        <div id=\"time-display\" class=\"timeline-time-display bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded font-mono text-base\">00:00:00</div>\n      </div>\n      \n      <!-- Debug info -->\n      <div class=\"mb-2 text-xs text-gray-500\">\n        Debug - isLoading: ${isLoading ? 'true' : 'false'}, \n        Streams: ${streamsList.length},\n        Segments: ${segments.length}\n      </div>\n      \n      <!-- Content -->\n      ${renderContent()}\n\n      <!-- Instructions -->\n      <div class=\"mt-6 p-4 bg-gray-200 dark:bg-gray-800 rounded\">\n        <h3 class=\"text-lg font-semibold mb-2\">How to use the timeline:</h3>\n        <ul class=\"list-disc pl-5\">\n          <li>Select a stream and date to load recordings</li>\n          <li>Click on the timeline to seek to a specific time</li>\n          <li>Click on a segment (blue bar) to play that recording</li>\n          <li>Use the play/pause button to control playback</li>\n          <li>Use the zoom buttons to adjust the timeline scale</li>\n        </ul>\n      </div>\n    </div>\n  `;\n}\n\n// Export the timeline state for use in other components\nexport { timelineState };\n"],"names":["TimelineControls","isPlaying","setIsPlaying","useState","zoomLevel","setZoomLevel","useEffect","console","log","unsubscribe","timelineState","subscribe","state","timelineSegments","length","pausePlayback","setState","videoPlayer","document","querySelector","pause","resumePlayback","showStatusMessage","earliestSegmentIndex","earliestTimestamp","Number","MAX_SAFE_INTEGER","forEach","segment","index","start_timestamp","currentSegmentIndex","currentTime","forceReload","removeAttribute","load","src","id","Date","now","onloadedmetadata","play","catch","error","message","html","togglePlayback","zoomOut","newZoomLevel","zoomIn","TimelineRuler","startHour","setStartHour","endHour","setEndHour","hoursPerView","centerHour","currentDate","getHours","getMinutes","getSeconds","earliestHour","latestHour","startTime","endTime","end_timestamp","Math","min","max","newStartHour","newEndHour","timelineStartHour","timelineEndHour","generateHourMarkers","markers","hour","floor","ceil","position","push","halfHourPosition","quarterHourPosition1","quarterHourPosition3","round","TimelineSegments","segments","setSegments","setCurrentSegmentIndex","containerRef","useRef","isDragging","container","current","handleMouseDown","e","target","classList","contains","handleTimelineClick","addEventListener","handleMouseMove","handleMouseUp","removeEventListener","event","rect","getBoundingClientRect","clickX","clientX","left","containerWidth","width","clickHour","clickDate","selectedDate","setHours","setMinutes","setSeconds","clickTimestamp","getTime","foundSegment","i","relativeTime","playSegment","closestSegment","minDistance","Infinity","startDistance","abs","endDistance","distance","prevCurrentTime","warn","absoluteTime","body","offsetHeight","setTimeout","videoElement","seekTime","renderSegments","visibleSegments","hourMap","Map","startHourFloat","endHourFloat","startFloorHour","endCeilHour","h","has","set","get","mergedSegments","currentMergedSegment","sort","a","b","originalIndices","has_detection","mergedIndex","visibleStartHour","visibleEndHour","startPercent","widthPercent","durationStr","startTimeStr","toLocaleTimeString","endTimeStr","TimelineCursor","setPosition","visible","setVisible","setCurrentTime","setIsDragging","cursorRef","dragStartXRef","updateTimeDisplay","updateCursorPosition","cursor","preventDefault","stopPropagation","parentElement","positionPercent","date","timestamp","time","startHr","endHr","timeDisplay","getElementById","hours","toString","padStart","minutes","seconds","textContent","SpeedControls","currentSpeed","setCurrentSpeed","playbackSpeed","map","speed","oldRate","playbackRate","setPlaybackSpeed","TimelinePlayer","videoRef","lastTimeUpdateRef","lastSegmentIdRef","handleVideoPlayback","video","segmentChanged","needsReload","timeChanged","loadSegment","paused","autoplay","recordingUrl","onLoadedMetadata","handleEnded","nextIndex","handleTimeUpdate","mainContent","innerHTML","render","TimelinePage","streams","selectedStream","showOnlySegments","listeners","Set","newState","Object","assign","this","notifyListeners","listener","add","delete","urlParams","params","URLSearchParams","window","location","search","stream","getFullYear","String","getMonth","getDate","parseUrlParams","isLoading","setIsLoading","streamsList","setStreamsList","setSelectedStream","setSelectedDate","timelineContainerRef","initialLoadRef","loadStreams","some","s","name","loadTimelineData","firstStream","fetch","then","response","ok","Error","json","data","Array","isArray","url","URL","href","searchParams","history","replaceState","updateUrlParams","startDate","endDate","toISOString","encodeURIComponent","initialTime","newStream","value","newDate","LoadingIndicator"],"mappings":"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"}