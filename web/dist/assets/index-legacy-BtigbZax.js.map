{"version":3,"file":"index-legacy-BtigbZax.js","sources":["../../js/components/preact/WebRTCVideoCell.jsx","../../js/components/preact/WebRTCView.jsx","../../js/pages/index-page.jsx"],"sourcesContent":["/**\n * WebRTCVideoCell Component\n * A reusable component for displaying a WebRTC video stream\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { startDetectionPolling } from './DetectionOverlay.js';\nimport { SnapshotButton } from './SnapshotManager.jsx';\nimport { LoadingIndicator } from './LoadingIndicator.jsx';\n// We'll use inline styles for the spinner animation instead of injecting a style tag\n// This avoids direct DOM manipulation\nconst spinnerAnimation = 'spin 1s linear infinite';\n\n// Define the keyframes in a style tag in the JSX instead of injecting it directly\n\n/**\n * WebRTCVideoCell component\n * @param {Object} props - Component props\n * @param {Object} props.stream - Stream object\n * @param {Function} props.onTakeSnapshot - Snapshot handler\n * @param {Function} props.onToggleFullscreen - Fullscreen toggle handler\n * @param {Object} props.webrtcConnections - Reference to WebRTC connections\n * @param {Object} props.detectionIntervals - Reference to detection intervals\n * @param {Function} props.initializeWebRTCPlayer - Function to initialize WebRTC player\n * @param {Function} props.cleanupWebRTCPlayer - Function to cleanup WebRTC player\n * @returns {JSX.Element} WebRTCVideoCell component\n */\nexport function WebRTCVideoCell({\n  stream,\n  onTakeSnapshot,\n  onToggleFullscreen,\n  webrtcConnections,\n  detectionIntervals,\n  initializeWebRTCPlayer,\n  cleanupWebRTCPlayer\n}) {\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const cellRef = useRef(null);\n\n  // Initialize WebRTC player when component mounts\n  useEffect(() => {\n    if (!stream) return;\n\n    console.log(`WebRTCVideoCell: Initializing player for stream ${stream.name}`);\n\n    // Check if this stream already has a connection\n    const hasExistingConnection = webrtcConnections.current[stream.name];\n    if (hasExistingConnection) {\n      console.log(`WebRTCVideoCell: Stream ${stream.name} already has a connection, skipping initialization`);\n      setIsLoading(false);\n      return;\n    }\n\n    // Initialize WebRTC player with a short delay to ensure DOM is ready\n    console.log(`WebRTCVideoCell: Will initialize stream ${stream.name} after a short delay`);\n\n    const initTimeout = setTimeout(() => {\n      if (videoRef.current && canvasRef.current) {\n        console.log(`WebRTCVideoCell: Now initializing stream ${stream.name}`);\n        initializeWebRTCPlayer(stream, videoRef.current, canvasRef.current, {\n          onLoadedData: () => {\n            console.log(`Video data loaded for stream ${stream.name}`);\n            setIsLoading(false);\n          },\n          onPlaying: () => {\n            console.log(`Video playing for stream ${stream.name}`);\n            setIsLoading(false);\n\n            // Start detection polling if enabled\n            if (stream.detection_based_recording && stream.detection_model && canvasRef.current) {\n              console.log(`Starting detection polling for stream ${stream.name}`);\n              startDetectionPolling(stream.name, canvasRef.current, videoRef.current, detectionIntervals);\n            }\n          },\n          onError: (errorMessage) => {\n            console.error(`Video error for stream ${stream.name}:`, errorMessage);\n            setError(errorMessage || 'Video playback error');\n            setIsLoading(false);\n          }\n        });\n      }\n    }, 100); // Short 100ms delay to ensure DOM is ready\n\n    // Cleanup function\n    return () => {\n      clearTimeout(initTimeout);\n      if (stream) {\n        console.log(`WebRTCVideoCell: Cleaning up player for stream ${stream.name}`);\n        cleanupWebRTCPlayer(stream.name);\n      }\n    };\n  }, [stream.name]); // Only depend on stream.name to prevent unnecessary re-renders\n\n  // Handle retry button click\n  const handleRetry = () => {\n    if (!stream) return;\n\n    console.log(`Retrying connection for stream ${stream.name}`);\n    setIsLoading(true);\n    setError(null);\n\n    // Clean up existing connection\n    cleanupWebRTCPlayer(stream.name);\n\n    // Force a small delay to ensure cleanup is complete\n    setTimeout(() => {\n      if (videoRef.current && canvasRef.current) {\n        console.log(`Reinitializing WebRTC player for stream ${stream.name}`);\n        initializeWebRTCPlayer(stream, videoRef.current, canvasRef.current, {\n          onLoadedData: () => {\n            console.log(`Video data loaded for stream ${stream.name}`);\n            setIsLoading(false);\n          },\n          onPlaying: () => {\n            console.log(`Video playing for stream ${stream.name}`);\n            setIsLoading(false);\n          },\n          onError: (errorMessage) => {\n            console.error(`Video error for stream ${stream.name}:`, errorMessage);\n            // Try one more time with a longer delay\n            console.log(`Trying one more time for stream ${stream.name} with a longer delay`);\n\n            setTimeout(() => {\n              if (videoRef.current && canvasRef.current) {\n                initializeWebRTCPlayer(stream, videoRef.current, canvasRef.current, {\n                  onLoadedData: () => {\n                    console.log(`Video data loaded for stream ${stream.name} on second attempt`);\n                    setIsLoading(false);\n                  },\n                  onPlaying: () => {\n                    console.log(`Video playing for stream ${stream.name} on second attempt`);\n                    setIsLoading(false);\n                  },\n                  onError: (secondErrorMessage) => {\n                    console.error(`Video error for stream ${stream.name} on second attempt:`, secondErrorMessage);\n                    setError(secondErrorMessage || 'Video playback error');\n                    setIsLoading(false);\n                  }\n                });\n              }\n            }, 1000); // Try again after 1 second\n          }\n        });\n      }\n    }, 200);\n  };\n\n  return (\n    <div\n      className=\"video-cell\"\n      data-stream-name={stream.name}\n      data-stream-id={stream.id || stream.name}\n      ref={cellRef}\n      style={{\n        position: 'relative',\n        // Ensure the video cell doesn't interfere with navigation elements\n        pointerEvents: isLoading ? 'none' : 'auto'\n      }}\n    >\n      {/* Add keyframes for spinner animation in the component */}\n      <style>\n        {`\n          @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n          }\n        `}\n      </style>\n      {/* Video element */}\n      <video\n        id={`video-${stream.name.replace(/\\s+/g, '-')}`}\n        className=\"video-element\"\n        ref={videoRef}\n        playsInline\n        autoPlay\n        muted\n        style={{ pointerEvents: 'none', width: '100%', height: '100%', objectFit: 'contain', zIndex: 1 }}\n      />\n\n      {/* Canvas overlay for detection */}\n      <canvas\n        id={`canvas-${stream.name.replace(/\\s+/g, '-')}`}\n        className=\"detection-overlay\"\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          pointerEvents: 'none',\n          zIndex: 2 /* Lower z-index to ensure it doesn't block navigation */\n        }}\n      />\n\n      {/* Stream name overlay */}\n      <div\n        className=\"stream-name-overlay\"\n        style={{\n          position: 'absolute',\n          top: '10px',\n          left: '10px',\n          padding: '5px 10px',\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n          color: 'white',\n          borderRadius: '4px',\n          fontSize: '14px',\n          zIndex: 3, /* Lower z-index to ensure it doesn't block navigation */\n          pointerEvents: 'none'\n        }}\n      >\n        {stream.name}\n      </div>\n\n      {/* Stream controls */}\n      <div\n        className=\"stream-controls\"\n        style={{\n          position: 'absolute',\n          bottom: '10px',\n          right: '10px',\n          display: 'flex',\n          gap: '10px',\n          zIndex: 5, /* Lower z-index but still above video and overlays */\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n          padding: '5px',\n          borderRadius: '4px',\n          pointerEvents: 'auto' /* Keep pointer events enabled for controls */\n        }}\n      >\n        <div\n          style={{\n            backgroundColor: 'transparent',\n            padding: '5px',\n            borderRadius: '4px',\n            position: 'relative',\n            zIndex: 1 /* Lower z-index to prevent blocking */\n          }}\n          onMouseOver={(e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'}\n          onMouseOut={(e) => e.currentTarget.style.backgroundColor = 'transparent'}\n        >\n          <SnapshotButton\n            streamId={stream.id || stream.name}\n            streamName={stream.name}\n          />\n        </div>\n        <button\n          className=\"fullscreen-btn\"\n          title=\"Toggle Fullscreen\"\n          data-id={stream.id || stream.name}\n          data-name={stream.name}\n          onClick={(e) => onToggleFullscreen(stream.name, e, cellRef.current)}\n          style={{\n            backgroundColor: 'transparent',\n            border: 'none',\n            padding: '5px',\n            borderRadius: '4px',\n            color: 'white',\n            cursor: 'pointer',\n            position: 'relative',\n            zIndex: 1 /* Lower z-index to prevent blocking */\n          }}\n          onMouseOver={(e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'}\n          onMouseOut={(e) => e.currentTarget.style.backgroundColor = 'transparent'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path></svg>\n        </button>\n      </div>\n\n      {/* Loading indicator */}\n      {isLoading && (<LoadingIndicator message=\"Connecting...\" />)}\n\n      {/* Error indicator */}\n      {error && (\n        <div\n          className=\"error-indicator\"\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            width: '100%',\n            height: '100%',\n            display: 'flex',\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            backgroundColor: 'rgba(0, 0, 0, 0.7)',\n            color: 'white',\n            zIndex: 10,\n            pointerEvents: 'auto', /* Keep pointer events enabled for error state to allow retry button clicks */\n            textAlign: 'center',\n            // Ensure the error indicator is contained within the video cell\n            overflow: 'hidden'\n          }}\n        >\n          <div\n            className=\"error-content\"\n            style={{\n              display: 'flex',\n              flexDirection: 'column',\n              justifyContent: 'center',\n              alignItems: 'center',\n              width: '80%',\n              maxWidth: '300px',\n              padding: '20px',\n              borderRadius: '8px',\n              backgroundColor: 'rgba(0, 0, 0, 0.5)'\n            }}\n          >\n            <div\n              className=\"error-icon\"\n              style={{\n                fontSize: '28px',\n                marginBottom: '15px',\n                fontWeight: 'bold',\n                width: '40px',\n                height: '40px',\n                lineHeight: '40px',\n                borderRadius: '50%',\n                backgroundColor: 'rgba(220, 38, 38, 0.8)',\n                textAlign: 'center'\n              }}\n            >\n              !\n            </div>\n            <p style={{\n              marginBottom: '20px',\n              textAlign: 'center',\n              width: '100%',\n              fontSize: '14px',\n              lineHeight: '1.4'\n            }}>\n              {error}\n            </p>\n            <button\n              className=\"retry-button\"\n              onClick={handleRetry}\n              style={{\n                padding: '8px 20px',\n                backgroundColor: '#2563eb',\n                color: 'white',\n                borderRadius: '4px',\n                border: 'none',\n                cursor: 'pointer',\n                fontWeight: 'bold',\n                fontSize: '14px',\n                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',\n                transition: 'background-color 0.2s ease'\n              }}\n              onMouseOver={(e) => e.currentTarget.style.backgroundColor = '#1d4ed8'}\n              onMouseOut={(e) => e.currentTarget.style.backgroundColor = '#2563eb'}\n            >\n              Retry\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n","/**\n * LightNVR Web Interface WebRTCView Component\n * Preact component for the WebRTC view page\n */\n\n\nimport { useState, useEffect, useRef, useCallback } from 'preact/hooks';\nimport { showSnapshotPreview, setupModals, addModalStyles } from './UI.jsx';\nimport { showStatusMessage } from './ToastContainer.jsx';\nimport { useFullscreenManager, FullscreenManager } from './FullscreenManager.jsx';\nimport { startDetectionPolling, cleanupDetectionPolling } from './DetectionOverlay.js';\nimport { useMutation, useQuery, useQueryClient } from '../../query-client.js';\nimport { WebRTCVideoCell } from './WebRTCVideoCell.jsx';\nimport { SnapshotManager, useSnapshotManager } from './SnapshotManager.jsx';\n\n/**\n * WebRTCView component\n * @returns {JSX.Element} WebRTCView component\n */\nexport function WebRTCView() {\n  // Use the snapshot manager hook\n  const { takeSnapshot } = useSnapshotManager();\n  // Use the fullscreen manager hook\n  const { isFullscreen, setIsFullscreen, toggleFullscreen } = useFullscreenManager();\n  // WebRTC offer mutation hook - we don't specify the URL here as it will be dynamic based on the stream\n  const webrtcOfferMutation = useMutation({\n    mutationFn: async (data) => {\n      const { streamName, ...offerData } = data;\n      const auth = localStorage.getItem('auth');\n\n      const response = await fetch(`/api/webrtc?src=${encodeURIComponent(streamName)}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(auth ? { 'Authorization': 'Basic ' + auth } : {})\n        },\n        body: JSON.stringify(offerData),\n        signal: data.signal\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to send offer: ${response.status} ${response.statusText}`);\n      }\n\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch (jsonError) {\n        console.error(`Error parsing JSON for stream ${streamName}:`, jsonError);\n        console.log(`Raw response text: ${text}`);\n        throw new Error(`Failed to parse WebRTC answer: ${jsonError.message}`);\n      }\n    },\n    onError: (error, variables) => {\n      console.error(`Error sending WebRTC offer for stream ${variables.streamName}:`, error);\n    }\n  });\n\n  const [streams, setStreams] = useState([]);\n  // Initialize layout from URL or sessionStorage if available\n  const [layout, setLayout] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const layoutParam = urlParams.get('layout');\n    if (layoutParam) {\n      return layoutParam;\n    }\n    // Check sessionStorage as a backup\n    const storedLayout = sessionStorage.getItem('webrtc_layout');\n    return storedLayout || '4';\n  });\n\n  // Initialize selectedStream from URL or sessionStorage if available\n  const [selectedStream, setSelectedStream] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const streamParam = urlParams.get('stream');\n    if (streamParam) {\n      return streamParam;\n    }\n    // Check sessionStorage as a backup\n    const storedStream = sessionStorage.getItem('webrtc_selected_stream');\n    return storedStream || '';\n  });\n\n  // isFullscreen state is now managed by useFullscreenManager\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Initialize currentPage from URL or sessionStorage if available (URL uses 1-based indexing, internal state uses 0-based)\n  const [currentPage, setCurrentPage] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const pageParam = urlParams.get('page');\n    if (pageParam) {\n      // Convert from 1-based (URL) to 0-based (internal)\n      return Math.max(0, parseInt(pageParam, 10) - 1);\n    }\n    // Check sessionStorage as a backup\n    const storedPage = sessionStorage.getItem('webrtc_current_page');\n    if (storedPage) {\n      // Convert from 1-based (stored) to 0-based (internal)\n      return Math.max(0, parseInt(storedPage, 10) - 1);\n    }\n    return 0;\n  });\n  const videoGridRef = useRef(null);\n  const webrtcConnections = useRef({});\n  const detectionIntervals = useRef({});\n\n  // Set up event listeners and UI components\n  useEffect(() => {\n    // Set up modals for snapshot preview\n    setupModals();\n    addModalStyles();\n\n    // Add event listener to preserve URL parameters when page is reloaded\n    const handleBeforeUnload = () => {\n      console.log('Preserving URL parameters before page reload');\n\n      // Create a URL with the current parameters\n      const url = new URL(window.location);\n\n      // Ensure page parameter is set correctly (convert from 0-based internal to 1-based URL)\n      if (currentPage > 0) {\n        url.searchParams.set('page', currentPage + 1);\n      } else {\n        url.searchParams.delete('page');\n      }\n\n      // Ensure layout parameter is set if not default\n      if (layout !== '4') {\n        url.searchParams.set('layout', layout);\n      } else {\n        url.searchParams.delete('layout');\n      }\n\n      // Ensure stream parameter is set if in single stream mode\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without triggering navigation\n      window.history.replaceState({}, '', url);\n\n      // Store the current page in sessionStorage as a backup\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      // Store layout in sessionStorage\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      // Store selected stream in sessionStorage\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    };\n\n    // Register the beforeunload handler\n    window.addEventListener('beforeunload', handleBeforeUnload);\n\n    // Set up periodic connection check\n    const connectionCheckInterval = setInterval(() => {\n      Object.keys(webrtcConnections.current).forEach(streamName => {\n        const pc = webrtcConnections.current[streamName];\n        if (pc) {\n          // Log connection state for debugging\n          console.debug(`WebRTC connection state for ${streamName}: ${pc.connectionState}, ICE state: ${pc.iceConnectionState}`);\n\n          // If connection is failed or disconnected for too long, try to reconnect\n          if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n            console.warn(`WebRTC connection for ${streamName} is in ${pc.iceConnectionState} state, will attempt reconnect`);\n\n            // Clean up the old connection\n            cleanupWebRTCPlayer(streamName);\n\n            // Find the stream info and reinitialize\n            const stream = streams.find(s => s.name === streamName);\n            if (stream) {\n              console.log(`Attempting to reconnect WebRTC for stream ${streamName}`);\n              initializeWebRTCPlayer(stream);\n            }\n          }\n        }\n      });\n    }, 30000); // Check every 30 seconds\n\n    // Cleanup\n    return () => {\n      // Remove event listeners\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      clearInterval(connectionCheckInterval);\n      stopAllWebRTCStreams();\n    };\n  }, [streams, currentPage, layout, selectedStream]); // Add all relevant dependencies\n\n  // Get query client for fetching and invalidating queries\n  const queryClient = useQueryClient();\n\n  // Fetch streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery(\n    'streams',\n    '/api/streams',\n    {\n      timeout: 15000, // 15 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    }\n  );\n\n  // Update loading state based on streams query status\n  useEffect(() => {\n    // Only set loading state based on streams loading, but don't block UI interactions\n    setIsLoading(isLoadingStreams);\n  }, [isLoadingStreams]);\n\n  // Process streams data when it's loaded\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData)) {\n      // Process the streams data\n      const processStreams = async () => {\n        try {\n          // Filter and process the streams\n          const filteredStreams = await filterStreamsForWebRTC(streamsData);\n\n          if (filteredStreams.length > 0) {\n            setStreams(filteredStreams);\n\n            // Set selectedStream based on URL parameter if it exists and is valid\n            const urlParams = new URLSearchParams(window.location.search);\n            const streamParam = urlParams.get('stream');\n\n            if (streamParam && filteredStreams.some(stream => stream.name === streamParam)) {\n              // If the stream from URL exists in the loaded streams, use it\n              setSelectedStream(streamParam);\n            } else if (!selectedStream || !filteredStreams.some(stream => stream.name === selectedStream)) {\n              // Otherwise use the first stream if selectedStream is not set or invalid\n              setSelectedStream(filteredStreams[0].name);\n            }\n          } else {\n            console.warn('No streams available for WebRTC view after filtering');\n          }\n        } catch (error) {\n          console.error('Error processing streams:', error);\n          showStatusMessage('Error processing streams: ' + error.message);\n        }\n      };\n\n      processStreams();\n    }\n  }, [streamsData, selectedStream, queryClient]);\n\n  // Use a ref to track previous values to prevent unnecessary updates\n  const previousValues = useRef({ layout, selectedStream, currentPage, streamsLength: streams.length });\n\n  useEffect(() => {\n    // Only update if something actually changed\n    const prev = previousValues.current;\n    if (\n      prev.layout !== layout ||\n      prev.selectedStream !== selectedStream ||\n      prev.currentPage !== currentPage ||\n      prev.streamsLength !== streams.length\n    ) {\n      console.log('Layout, selectedStream, currentPage, or streams changed, updating video grid');\n      updateVideoGrid();\n\n      // Update previous values\n      previousValues.current = { layout, selectedStream, currentPage, streamsLength: streams.length };\n    }\n  }, [layout, selectedStream, streams, currentPage]);\n\n  // Update URL when layout, page, or selectedStream changes\n  useEffect(() => {\n    // Don't update URL during initial load or when streams are empty\n    if (streams.length === 0) return;\n\n    // Use a debounce to prevent multiple URL updates in quick succession\n    const updateURLTimeout = setTimeout(() => {\n      console.log('Updating URL parameters');\n      const url = new URL(window.location);\n\n      // Handle page parameter (convert from 0-based internal to 1-based URL)\n      if (currentPage === 0) {\n        url.searchParams.delete('page');\n      } else {\n        // Add 1 to convert from 0-based (internal) to 1-based (URL)\n        url.searchParams.set('page', currentPage + 1);\n      }\n\n      // Handle layout parameter\n      if (layout !== '4') { // Only set if not the default\n        url.searchParams.set('layout', layout);\n      } else {\n        // Remove layout parameter if it's the default value\n        url.searchParams.delete('layout');\n      }\n\n      // Handle selectedStream parameter\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        // Remove stream parameter if not in single stream mode\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without reloading the page\n      window.history.replaceState({}, '', url);\n\n      // Also update sessionStorage\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    }, 300); // 300ms debounce\n\n    // Clean up the timeout if the component re-renders before the timeout completes\n    return () => clearTimeout(updateURLTimeout);\n  }, [currentPage, layout, selectedStream, streams.length]);\n\n  /**\n   * Filter streams for WebRTC view\n   * @param {Array} streams - Array of streams\n   * @returns {Promise<Array>} Promise resolving to filtered array of streams\n   */\n  const filterStreamsForWebRTC = async (streams) => {\n    try {\n      if (!streams || !Array.isArray(streams)) {\n        console.warn('No streams data provided to filter');\n        return [];\n      }\n\n      // For WebRTC view, we need to fetch full details for each stream\n      const streamPromises = streams.map(async (stream) => {\n        try {\n          const streamId = stream.id || stream.name;\n\n          const streamDetails = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamId],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamId)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to load details for stream ${stream.name}`);\n              }\n              return response.json();\n            },\n            staleTime: 30000 // 30 seconds\n          });\n\n          return streamDetails;\n        } catch (error) {\n          console.error(`Error loading details for stream ${stream.name}:`, error);\n          // Return the basic stream info if we can't get details\n          return stream;\n        }\n      });\n\n      const detailedStreams = await Promise.all(streamPromises);\n      console.log('Loaded detailed streams for WebRTC view:', detailedStreams);\n\n      // Filter out streams that are soft deleted, inactive, or not configured for streaming\n      const filteredStreams = detailedStreams.filter(stream => {\n        // Filter out soft deleted streams\n        if (stream.is_deleted) {\n          console.log(`Stream ${stream.name} is soft deleted, filtering out`);\n          return false;\n        }\n\n        // Filter out inactive streams\n        if (!stream.enabled) {\n          console.log(`Stream ${stream.name} is inactive, filtering out`);\n          return false;\n        }\n\n        // Filter out streams not configured for streaming\n        if (!stream.streaming_enabled) {\n          console.log(`Stream ${stream.name} is not configured for streaming, filtering out`);\n          return false;\n        }\n\n        return true;\n      });\n\n      console.log('Filtered streams for WebRTC view:', filteredStreams);\n\n      return filteredStreams || [];\n    } catch (error) {\n      console.error('Error filtering streams for WebRTC view:', error);\n      showStatusMessage('Error processing streams: ' + error.message);\n      return [];\n    }\n  };\n\n  /**\n   * Get maximum number of streams to display based on layout\n   * @returns {number} Maximum number of streams\n   */\n  const getMaxStreamsForLayout = () => {\n    switch (layout) {\n      case '1': return 1;  // Single view\n      case '2': return 2;  // 2x1 grid\n      case '4': return 4;  // 2x2 grid\n      case '6': return 6;  // 2x3 grid\n      case '9': return 9;  // 3x3 grid\n      case '16': return 16; // 4x4 grid\n      default: return 4;\n    }\n  };\n\n  /**\n   * Get streams to show based on layout, selected stream, and pagination\n   * @returns {Array} Streams to show\n   */\n  const getStreamsToShow = () => {\n    // Filter streams based on layout and selected stream\n    let streamsToShow = streams;\n    if (layout === '1' && selectedStream) {\n      streamsToShow = streams.filter(stream => stream.name === selectedStream);\n    } else {\n      // Apply pagination\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      // Ensure current page is valid\n      if (currentPage >= totalPages && totalPages > 0) {\n        // We'll handle this in updateVideoGrid\n        return [];\n      }\n\n      // Get streams for current page\n      const startIdx = currentPage * maxStreams;\n      const endIdx = Math.min(startIdx + maxStreams, streams.length);\n      streamsToShow = streams.slice(startIdx, endIdx);\n    }\n\n    return streamsToShow;\n  };\n\n  /**\n   * Update video grid based on layout, streams, and pagination\n   */\n  const updateVideoGrid = () => {\n    if (!videoGridRef.current) return;\n\n    // Filter streams based on layout and selected stream\n    let streamsToShow = getStreamsToShow();\n\n    // If no streams to show and we have streams, check if page is invalid\n    if (streamsToShow.length === 0 && streams.length > 0) {\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      if (currentPage >= totalPages) {\n        setCurrentPage(Math.max(0, totalPages - 1));\n        return; // Will re-render with corrected page\n      }\n    }\n\n    // Get the names of streams that should be shown\n    const streamsToShowNames = streamsToShow.map(stream => stream.name);\n\n    // Log page change for debugging\n    console.log(`Updating video grid for page ${currentPage + 1}, showing streams:`, streamsToShowNames);\n\n    // Clean up connections for streams that are no longer visible\n    const connectionsToCleanup = Object.keys(webrtcConnections.current).filter(\n      streamName => !streamsToShowNames.includes(streamName)\n    );\n\n    if (connectionsToCleanup.length > 0) {\n      console.log(`Cleaning up ${connectionsToCleanup.length} WebRTC connections that are no longer visible:`, connectionsToCleanup);\n      connectionsToCleanup.forEach(streamName => {\n        cleanupWebRTCPlayer(streamName);\n      });\n    }\n  };\n\n  /**\n   * Initialize WebRTC player for a stream\n   * @param {Object} stream - Stream object\n   * @param {HTMLVideoElement} videoElement - Video element\n   * @param {HTMLCanvasElement} canvasOverlay - Canvas overlay for detection\n   * @param {Object} callbacks - Callback functions\n   */\n  const initializeWebRTCPlayer = (stream, videoElement, canvasOverlay, callbacks = {}) => {\n    if (!stream || !videoElement) {\n      console.error(`Cannot initialize WebRTC player: missing stream or video element`);\n      return;\n    }\n\n    // Check if there's already a connection for this stream\n    if (webrtcConnections.current[stream.name]) {\n      console.log(`WebRTC connection for stream ${stream.name} already exists, cleaning up first`);\n      cleanupWebRTCPlayer(stream.name);\n    }\n\n    console.log(`Initializing WebRTC player for stream ${stream.name}`);\n\n    // Create a new RTCPeerConnection with ICE servers\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ],\n      // Add additional configuration to ensure proper ICE credentials\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'balanced',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'unified-plan'\n    });\n\n    // Store the connection for cleanup\n    webrtcConnections.current[stream.name] = pc;\n\n    // Add event listeners\n    pc.ontrack = (event) => {\n      console.log(`Track received for stream ${stream.name}:`, event);\n      if (event.track.kind === 'video') {\n        videoElement.srcObject = event.streams[0];\n\n        // Add event handlers for video element\n        videoElement.onloadeddata = () => {\n          console.log(`Video data loaded for stream ${stream.name}`);\n          if (callbacks.onLoadedData) {\n            callbacks.onLoadedData();\n          }\n        };\n\n        videoElement.onplaying = () => {\n          console.log(`Video playing for stream ${stream.name}`);\n          if (callbacks.onPlaying) {\n            callbacks.onPlaying();\n          }\n\n          // Start detection polling now that the video is playing\n          if (stream.detection_based_recording && stream.detection_model && canvasOverlay) {\n            console.log(`Starting detection polling for stream ${stream.name} now that video is playing`);\n            startDetectionPolling(stream.name, canvasOverlay, videoElement, detectionIntervals.current);\n          } else {\n            console.log(`Detection not enabled for stream ${stream.name}`);\n          }\n        };\n\n        videoElement.onerror = (e) => {\n          console.error(`Video error for stream ${stream.name}:`, e);\n          if (callbacks.onError) {\n            callbacks.onError('Video playback error');\n          }\n        };\n      }\n    };\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log(`ICE candidate for stream ${stream.name}:`, event.candidate);\n        // go2rtc doesn't use a separate ICE endpoint, so we don't need to send ICE candidates\n      }\n    };\n\n    pc.oniceconnectionstatechange = () => {\n      console.log(`ICE connection state for stream ${stream.name}:`, pc.iceConnectionState);\n\n      // Handle different ICE connection states\n      if (pc.iceConnectionState === 'failed') {\n        console.warn(`ICE failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC ICE connection failed');\n        }\n      } else if (pc.iceConnectionState === 'disconnected') {\n        console.warn(`ICE disconnected for stream ${stream.name}`);\n        // Don't immediately handle as error, as disconnected can be temporary\n      }\n    };\n\n    // Also monitor connection state changes\n    pc.onconnectionstatechange = () => {\n      console.log(`Connection state changed for stream ${stream.name}:`, pc.connectionState);\n\n      if (pc.connectionState === 'failed') {\n        console.warn(`Connection failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC connection failed');\n        }\n      }\n    };\n\n    // Add transceivers to ensure we get both audio and video tracks\n    pc.addTransceiver('video', {direction: 'recvonly'});\n    pc.addTransceiver('audio', {direction: 'recvonly'});\n\n    // Create an offer with specific codec requirements\n    const offerOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n\n    // Create a timeout for the entire WebRTC setup process\n    const setupTimeoutId = setTimeout(() => {\n      console.warn(`WebRTC setup timed out for stream ${stream.name}`);\n      if (callbacks.onError) {\n        callbacks.onError('WebRTC setup timed out');\n      }\n\n      // Clean up the connection if it exists\n      if (webrtcConnections.current[stream.name]) {\n        cleanupWebRTCPlayer(stream.name);\n      }\n    }, 30000); // 30 second timeout for the entire setup process\n\n    // Create a separate timeout for video playback\n    const videoPlaybackTimeoutId = setTimeout(() => {\n      // Only show error if the connection still exists but video isn't playing\n      if (webrtcConnections.current[stream.name] &&\n          (!videoElement.srcObject || videoElement.readyState < 2)) { // HAVE_CURRENT_DATA = 2\n        console.warn(`Video playback timed out for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('Video playback timed out');\n        }\n      }\n    }, 20000); // 20 second timeout for video playback\n\n    // Add a check to ensure the connection still exists before proceeding\n    const checkConnectionExists = () => {\n      return webrtcConnections.current[stream.name] === pc;\n    };\n\n    pc.createOffer(offerOptions)\n      .then(offer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up during offer creation');\n        }\n        console.log(`Created offer for stream ${stream.name}`);\n        return pc.setLocalDescription(offer);\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting local description');\n        }\n        console.log(`Set local description for stream ${stream.name}`);\n        // Send the offer to the server\n        return sendOffer(stream.name, pc.localDescription);\n      })\n      .then(answer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after receiving answer');\n        }\n        console.log(`Received answer for stream ${stream.name}`);\n        // Set the remote description\n        return pc.setRemoteDescription(new RTCSessionDescription(answer));\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting remote description');\n        }\n        console.log(`Set remote description for stream ${stream.name}`);\n\n        // Clear both timeouts since we've successfully set up the connection\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n      })\n      .catch(error => {\n        // Clear both timeouts\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n\n        // Only log and call error callback if the connection still exists\n        if (checkConnectionExists()) {\n          console.error(`Error setting up WebRTC for stream ${stream.name}:`, error);\n          if (callbacks.onError) {\n            callbacks.onError(error.message);\n          }\n        } else {\n          console.log(`WebRTC setup for stream ${stream.name} was cancelled: ${error.message}`);\n        }\n      });\n\n    // Add event listener to clear the video playback timeout when video starts playing\n    videoElement.addEventListener('playing', () => {\n      clearTimeout(videoPlaybackTimeoutId);\n    }, { once: true }); // Use once: true to ensure it only fires once\n  };\n\n  /**\n   * Send WebRTC offer to server\n   * @param {string} streamName - Stream name\n   * @param {RTCSessionDescription} offer - WebRTC offer\n   * @returns {Promise<RTCSessionDescription>} Promise resolving to WebRTC answer\n   */\n  const sendOffer = useCallback(async (streamName, offer) => {\n    try {\n      // Format the offer according to go2rtc expectations\n      const formattedOffer = {\n        type: offer.type,\n        sdp: offer.sdp\n      };\n\n      console.log(`Sending formatted offer for stream ${streamName}`);\n\n      // Create an AbortController to allow cancellation of the request\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n\n      // Store the abort controller in the connection object for later cleanup\n      if (webrtcConnections.current[streamName]) {\n        webrtcConnections.current[streamName].abortController = abortController;\n      } else {\n        // If the connection no longer exists, abort immediately\n        console.log(`Connection for stream ${streamName} no longer exists, aborting offer`);\n        abortController.abort();\n        return Promise.reject(new Error('Connection no longer exists'));\n      }\n\n      // Use the mutation to send the offer with the abort signal\n      const result = await webrtcOfferMutation.mutateAsync({\n        ...formattedOffer,\n        streamName, // Add streamName for the URL construction in mutationFn\n        signal      // Add signal for request cancellation\n      });\n\n      // Check if the connection still exists before returning the result\n      if (webrtcConnections.current[streamName]) {\n        return result;\n      } else {\n        // If the connection was cleaned up during the request, abort and reject\n        console.log(`Connection for stream ${streamName} was cleaned up during offer, rejecting result`);\n        return Promise.reject(new Error('Connection was cleaned up during offer'));\n      }\n    } catch (error) {\n      // Check if this was an abort error, which we can safely ignore\n      if (error.name === 'AbortError') {\n        console.log(`WebRTC offer request for stream ${streamName} was aborted`);\n        // Return a rejected promise to stop the WebRTC connection process\n        return Promise.reject(new Error('Request aborted'));\n      }\n\n      console.error(`Error sending offer for stream ${streamName}:`, error);\n      throw error;\n    }\n  }, [webrtcOfferMutation]);\n\n  // ICE candidates are handled internally by the browser for go2rtc\n\n  /**\n   * Handle WebRTC error\n   * @param {string} streamName - Stream name\n   * @param {string} message - Error message\n   */\n  const handleWebRTCError = async (streamName, message) => {\n    console.error(`WebRTC error for stream ${streamName}:`, message);\n\n    // The WebRTCVideoCell component now handles its own error state\n    // We just need to update the connection state and let the component handle the UI\n\n    // Cleanup existing connection to trigger the error state in the component\n    cleanupWebRTCPlayer(streamName);\n\n    // Find the stream in our streams array\n    const stream = streams.find(s => s.name === streamName);\n\n    if (stream) {\n      console.log(`Found stream ${streamName} in local state, will be reinitialized by component`);\n      // The component will handle retrying through its error UI\n    } else {\n      console.log(`Stream ${streamName} not found in local state, this is unexpected`);\n      // This is an edge case that shouldn't happen in normal operation\n      // The component will show an error state\n    }\n  };\n\n  /**\n   * Cleanup WebRTC player\n   * @param {string} streamName - Stream name\n   */\n  const cleanupWebRTCPlayer = (streamName) => {\n    console.log(`Cleaning up WebRTC player for stream ${streamName}`);\n\n    // Close and remove the RTCPeerConnection\n    if (webrtcConnections.current[streamName]) {\n      // Create a local reference to the connection before deleting it\n      const connection = webrtcConnections.current[streamName];\n\n      // Abort any pending fetch requests\n      if (connection.abortController) {\n        console.log(`Aborting pending WebRTC requests for stream ${streamName}`);\n        try {\n          connection.abortController.abort();\n        } catch (e) {\n          console.error(`Error aborting WebRTC request for stream ${streamName}:`, e);\n        }\n      }\n\n      // Remove all event listeners to prevent memory leaks\n      if (connection.onicecandidate) connection.onicecandidate = null;\n      if (connection.oniceconnectionstatechange) connection.oniceconnectionstatechange = null;\n      if (connection.onconnectionstatechange) connection.onconnectionstatechange = null;\n      if (connection.ontrack) connection.ontrack = null;\n\n      // Close the connection\n      connection.close();\n\n      // Remove from our reference object\n      delete webrtcConnections.current[streamName];\n\n      console.log(`Closed WebRTC connection for stream ${streamName}`);\n    }\n\n    // Clean up detection polling\n    cleanupDetectionPolling(streamName, detectionIntervals.current);\n  };\n\n  /**\n   * Stop all WebRTC streams\n   */\n  const stopAllWebRTCStreams = () => {\n    console.log('Stopping all WebRTC streams');\n    // Close all RTCPeerConnections\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      cleanupWebRTCPlayer(streamName);\n    });\n    console.log('All WebRTC streams stopped');\n  };\n\n// Note: takeSnapshot is now provided by the useSnapshotManager hook\n\n  /**\n   * Toggle fullscreen mode for a specific stream\n   * @param {string} streamName - Stream name\n   * @param {Event} event - Click event\n   * @param {HTMLElement} cellElement - The video cell element (passed from the component)\n   */\n  const toggleStreamFullscreen = (streamName, event, cellElement) => {\n    // Prevent default button behavior\n    if (event) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (!streamName) {\n      console.error('Stream name not provided for fullscreen toggle');\n      return;\n    }\n\n    console.log(`Toggling fullscreen for stream: ${streamName}`);\n\n    if (!cellElement) {\n      console.error('Video cell element not provided for fullscreen toggle');\n      return;\n    }\n\n    if (!document.fullscreenElement) {\n      console.log('Entering fullscreen mode for video cell');\n      cellElement.requestFullscreen().catch(err => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n      });\n    } else {\n      console.log('Exiting fullscreen mode');\n      document.exitFullscreen();\n    }\n  };\n\n  return (\n    <section\n      id=\"live-page\"\n      className={`page ${isFullscreen ? 'fullscreen-mode' : ''}`}\n      style={{\n        // Ensure the section doesn't block navigation during loading\n        position: 'relative',\n        zIndex: 1\n      }}\n    >\n      {/* Include the SnapshotManager component */}\n      <SnapshotManager />\n      {/* Include the FullscreenManager component */}\n      <FullscreenManager isFullscreen={isFullscreen} setIsFullscreen={setIsFullscreen} targetId=\"live-page\" />\n      <div className=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\">\n        <div className=\"flex items-center space-x-2\">\n          <h2 className=\"text-xl font-bold mr-4\">Live View</h2>\n          <div className=\"flex space-x-2\">\n            <button\n              id=\"hls-toggle-btn\"\n              className=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick={() => window.location.href = '/hls.html'}\n            >\n              HLS View\n            </button>\n          </div>\n        </div>\n        <div className=\"controls flex items-center space-x-2\">\n          <div className=\"flex items-center\">\n            <label for=\"layout-selector\" className=\"mr-2\">Layout:</label>\n            <select\n                id=\"layout-selector\"\n                className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                value={layout}\n                onChange={(e) => {\n                  const newLayout = e.target.value;\n                  setLayout(newLayout);\n                  setCurrentPage(0); // Reset to first page when layout changes\n                  // URL will be updated by the useEffect hook\n                }}\n            >\n              <option value=\"1\">1 Stream</option>\n              <option value=\"2\">2 Streams</option>\n              <option value=\"4\" selected>4 Streams</option>\n              <option value=\"6\">6 Streams</option>\n              <option value=\"9\">9 Streams</option>\n              <option value=\"16\">16 Streams</option>\n            </select>\n          </div>\n\n          {layout === '1' && (\n              <div className=\"flex items-center\">\n                <label for=\"stream-selector\" className=\"mr-2\">Stream:</label>\n                <select\n                    id=\"stream-selector\"\n                    className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                    value={selectedStream}\n                    onChange={(e) => {\n                      const newStream = e.target.value;\n                      setSelectedStream(newStream);\n                      // URL will be updated by the useEffect hook\n                    }}\n                >\n                  {streams.map(stream =>\n                      <option key={stream.name} value={stream.name}>{stream.name}</option>\n                  )}\n                </select>\n              </div>\n          )}\n\n          <button\n              id=\"fullscreen-btn\"\n              className=\"p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 focus:outline-none\"\n              onClick={() => toggleFullscreen()}\n              title=\"Toggle Fullscreen\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\"\n                 stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n              <path\n                  d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path>\n            </svg>\n          </button>\n        </div>\n      </div>\n\n      <div className=\"flex flex-col space-y-4\">\n        <div\n            id=\"video-grid\"\n            className={`video-container layout-${layout}`}\n            ref={videoGridRef}\n            style={{\n              // Ensure the video grid doesn't block navigation during loading\n              position: 'relative',\n              zIndex: 1\n            }}\n        >\n          {isLoadingStreams ? (\n              <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n                <div className=\"flex flex-col items-center justify-center py-8\">\n                  <div\n                      className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                  <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (isLoading && !isLoadingStreams) ? (\n            <div\n              className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\"\n              style={{\n                pointerEvents: 'none',\n                position: 'relative',\n                zIndex: 1\n              }}\n            >\n              <div className=\"flex flex-col items-center justify-center py-8\">\n                <div\n                    className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (streamsError) ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">Error loading streams: {streamsError.message}</p>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\"\n              >\n                Retry\n              </button>\n            </div>\n          ) : streams.length === 0 ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n              <a href=\"streams.html\" className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n            </div>\n          ) : (\n            // Render video cells using our WebRTCVideoCell component\n            getStreamsToShow().map(stream => (\n              <WebRTCVideoCell\n                key={stream.name}\n                stream={stream}\n                onTakeSnapshot={takeSnapshot}\n                onToggleFullscreen={toggleStreamFullscreen}\n                webrtcConnections={webrtcConnections}\n                detectionIntervals={detectionIntervals}\n                initializeWebRTCPlayer={initializeWebRTCPlayer}\n                cleanupWebRTCPlayer={cleanupWebRTCPlayer}\n              />\n            ))\n          )}\n        </div>\n\n        {layout !== '1' && streams.length > getMaxStreamsForLayout() ? (\n          <div className=\"pagination-controls flex justify-center items-center space-x-4 mt-4\">\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to previous page');\n                setCurrentPage(Math.max(0, currentPage - 1));\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                const newPage = currentPage - 1;\n\n                if (newPage > 0) {\n                  url.searchParams.set('page', newPage + 1);\n                  sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n                } else {\n                  url.searchParams.delete('page');\n                  sessionStorage.removeItem('webrtc_current_page');\n                }\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage === 0}\n            >\n              Previous\n            </button>\n\n            <span className=\"text-gray-700 dark:text-gray-300\">\n              Page {currentPage + 1} of {Math.ceil(streams.length / getMaxStreamsForLayout())}\n            </span>\n\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to next page');\n                const newPage = Math.min(Math.ceil(streams.length / getMaxStreamsForLayout()) - 1, currentPage + 1);\n                setCurrentPage(newPage);\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                url.searchParams.set('page', newPage + 1);\n                sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage >= Math.ceil(streams.length / getMaxStreamsForLayout()) - 1}\n            >\n              Next\n            </button>\n          </div>\n        ) : null}\n      </div>\n    </section>\n  );\n}\n","/**\n * LightNVR Web Interface Live View Page\n * Entry point for the live view page with WebRTC/HLS support\n */\n\nimport { render } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { LiveView } from '../components/preact/LiveView.jsx';\nimport { WebRTCView } from '../components/preact/WebRTCView.jsx';\nimport { QueryClientProvider, queryClient } from '../query-client.js';\nimport { Header } from \"../components/preact/Header.jsx\";\nimport { Footer } from \"../components/preact/Footer.jsx\";\nimport { ToastContainer } from \"../components/preact/ToastContainer.jsx\";\n\n/**\n * Main App component that conditionally renders WebRTCView or LiveView\n * based on whether WebRTC is disabled in settings\n */\nfunction App() {\n    const [isWebRTCDisabled, setIsWebRTCDisabled] = useState(false);\n    const [isLoading, setIsLoading] = useState(true);\n\n    useEffect(() => {\n        // Check if WebRTC is disabled in settings\n        async function checkWebRTCStatus() {\n            try {\n                const response = await fetch('/api/settings');\n                if (!response.ok) {\n                    console.error('Failed to fetch settings:', response.status, response.statusText);\n                    setIsLoading(false);\n                    return;\n                }\n\n                const settings = await response.json();\n                \n                if (settings.webrtc_disabled) {\n                    console.log('WebRTC is disabled, using HLS view');\n                    setIsWebRTCDisabled(true);\n                } else {\n                    console.log('WebRTC is enabled, using WebRTC view');\n                    setIsWebRTCDisabled(false);\n                }\n            } catch (error) {\n                console.error('Error checking WebRTC status:', error);\n            } finally {\n                setIsLoading(false);\n            }\n        }\n\n        checkWebRTCStatus();\n    }, []);\n\n    if (isLoading) {\n        return <div className=\"loading\">Loading...</div>;\n    }\n\n    return (\n        <>\n            <Header />\n            <ToastContainer />\n            {isWebRTCDisabled ? <LiveView isWebRTCDisabled={true} /> : <WebRTCView />}\n            <Footer />\n        </>\n    );\n}\n\n// Render the App component when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Get the container element\n    const container = document.getElementById('main-content');\n\n    if (container) {\n        render(\n            <QueryClientProvider client={queryClient}>\n                <App />\n            </QueryClientProvider>,\n            container\n        );\n    }\n});\n"],"names":["WebRTCVideoCell","stream","onTakeSnapshot","onToggleFullscreen","webrtcConnections","detectionIntervals","initializeWebRTCPlayer","cleanupWebRTCPlayer","isLoading","setIsLoading","useState","error","setError","videoRef","useRef","canvasRef","cellRef","useEffect","console","log","name","current","initTimeout","setTimeout","onLoadedData","onPlaying","detection_based_recording","detection_model","startDetectionPolling","onError","errorMessage","clearTimeout","jsxs","className","id","ref","style","position","pointerEvents","children","jsx","replace","playsInline","autoPlay","muted","width","height","objectFit","zIndex","top","left","padding","backgroundColor","color","borderRadius","fontSize","bottom","right","display","gap","onMouseOver","e","currentTarget","onMouseOut","SnapshotButton","streamId","streamName","title","onClick","border","cursor","xmlns","viewBox","fill","stroke","d","LoadingIndicator","message","flexDirection","justifyContent","alignItems","textAlign","overflow","maxWidth","marginBottom","fontWeight","lineHeight","handleRetry","secondErrorMessage","boxShadow","transition","WebRTCView","takeSnapshot","useSnapshotManager","isFullscreen","setIsFullscreen","toggleFullscreen","useFullscreenManager","webrtcOfferMutation","useMutation","mutationFn","async","offerData","data","auth","localStorage","getItem","response","fetch","encodeURIComponent","method","headers","Authorization","body","JSON","stringify","signal","ok","Error","status","statusText","text","parse","jsonError","variables","streams","setStreams","layout","setLayout","layoutParam","URLSearchParams","window","location","search","get","sessionStorage","selectedStream","setSelectedStream","streamParam","currentPage","setCurrentPage","pageParam","Math","max","parseInt","storedPage","videoGridRef","setupModals","addModalStyles","handleBeforeUnload","url","URL","searchParams","set","delete","history","replaceState","setItem","toString","removeItem","addEventListener","connectionCheckInterval","setInterval","Object","keys","forEach","pc","debug","connectionState","iceConnectionState","warn","find","s","removeEventListener","clearInterval","stopAllWebRTCStreams","queryClient","useQueryClient","streamsData","isLoadingStreams","streamsError","useQuery","timeout","retries","retryDelay","Array","isArray","filteredStreams","filterStreamsForWebRTC","length","some","showStatusMessage","processStreams","previousValues","streamsLength","prev","updateVideoGrid","updateURLTimeout","streamPromises","map","fetchQuery","queryKey","queryFn","json","staleTime","detailedStreams","Promise","all","filter","is_deleted","enabled","streaming_enabled","getMaxStreamsForLayout","getStreamsToShow","streamsToShow","maxStreams","totalPages","ceil","startIdx","endIdx","min","slice","streamsToShowNames","connectionsToCleanup","includes","videoElement","canvasOverlay","callbacks","RTCPeerConnection","iceServers","urls","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","sdpSemantics","ontrack","event","track","kind","srcObject","onloadeddata","onplaying","onerror","onicecandidate","candidate","oniceconnectionstatechange","onconnectionstatechange","addTransceiver","direction","setupTimeoutId","videoPlaybackTimeoutId","readyState","checkConnectionExists","createOffer","offerToReceiveAudio","offerToReceiveVideo","then","offer","setLocalDescription","sendOffer","localDescription","answer","setRemoteDescription","RTCSessionDescription","catch","once","useCallback","formattedOffer","type","sdp","abortController","AbortController","abort","reject","result","mutateAsync","connection","close","cleanupDetectionPolling","toggleStreamFullscreen","cellElement","preventDefault","stopPropagation","document","fullscreenElement","exitFullscreen","requestFullscreen","err","SnapshotManager","FullscreenManager","targetId","href","for","value","onChange","newLayout","target","selected","newStream","reload","newPage","disabled","App","isWebRTCDisabled","setIsWebRTCDisabled","webrtc_disabled","checkWebRTCStatus","Fragment","Header","ToastContainer","LiveView","Footer","container","getElementById","render","QueryClientProvider","client"],"mappings":"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"}