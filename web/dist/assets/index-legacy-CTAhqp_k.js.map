{"version":3,"file":"index-legacy-CTAhqp_k.js","sources":["../../js/components/preact/WebRTCView.jsx","../../js/pages/index-page.jsx"],"sourcesContent":["/**\n * LightNVR Web Interface WebRTCView Component\n * Preact component for the WebRTC view page\n */\n\n\nimport { useState, useEffect, useRef, useCallback } from 'preact/hooks';\nimport { showStatusMessage, showSnapshotPreview, setupModals, addStatusMessageStyles, addModalStyles } from './UI.js';\nimport { toggleFullscreen, exitFullscreenMode } from './FullscreenManager.js';\nimport { startDetectionPolling, cleanupDetectionPolling } from './DetectionOverlay.js';\nimport { usePostMutation, useMutation, useQuery, useQueryClient } from '../../query-client.js';\nimport { WebRTCVideoCell } from './WebRTCVideoCell.jsx';\n\n/**\n * WebRTCView component\n * @returns {JSX.Element} WebRTCView component\n */\nexport function WebRTCView() {\n  // WebRTC offer mutation hook - we don't specify the URL here as it will be dynamic based on the stream\n  const webrtcOfferMutation = useMutation({\n    mutationFn: async (data) => {\n      const { streamName, ...offerData } = data;\n      const auth = localStorage.getItem('auth');\n\n      const response = await fetch(`/api/webrtc?src=${encodeURIComponent(streamName)}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(auth ? { 'Authorization': 'Basic ' + auth } : {})\n        },\n        body: JSON.stringify(offerData),\n        signal: data.signal\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to send offer: ${response.status} ${response.statusText}`);\n      }\n\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch (jsonError) {\n        console.error(`Error parsing JSON for stream ${streamName}:`, jsonError);\n        console.log(`Raw response text: ${text}`);\n        throw new Error(`Failed to parse WebRTC answer: ${jsonError.message}`);\n      }\n    },\n    onError: (error, variables) => {\n      console.error(`Error sending WebRTC offer for stream ${variables.streamName}:`, error);\n    }\n  });\n\n  const [streams, setStreams] = useState([]);\n  // Initialize layout from URL or sessionStorage if available\n  const [layout, setLayout] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const layoutParam = urlParams.get('layout');\n    if (layoutParam) {\n      return layoutParam;\n    }\n    // Check sessionStorage as a backup\n    const storedLayout = sessionStorage.getItem('webrtc_layout');\n    return storedLayout || '4';\n  });\n\n  // Initialize selectedStream from URL or sessionStorage if available\n  const [selectedStream, setSelectedStream] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const streamParam = urlParams.get('stream');\n    if (streamParam) {\n      return streamParam;\n    }\n    // Check sessionStorage as a backup\n    const storedStream = sessionStorage.getItem('webrtc_selected_stream');\n    return storedStream || '';\n  });\n\n  const [isFullscreen, setIsFullscreen] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Initialize currentPage from URL or sessionStorage if available (URL uses 1-based indexing, internal state uses 0-based)\n  const [currentPage, setCurrentPage] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const pageParam = urlParams.get('page');\n    if (pageParam) {\n      // Convert from 1-based (URL) to 0-based (internal)\n      return Math.max(0, parseInt(pageParam, 10) - 1);\n    }\n    // Check sessionStorage as a backup\n    const storedPage = sessionStorage.getItem('webrtc_current_page');\n    if (storedPage) {\n      // Convert from 1-based (stored) to 0-based (internal)\n      return Math.max(0, parseInt(storedPage, 10) - 1);\n    }\n    return 0;\n  });\n  const videoGridRef = useRef(null);\n  const webrtcConnections = useRef({});\n  const detectionIntervals = useRef({});\n\n  // Set up event listeners and UI components\n  useEffect(() => {\n    // Set up modals for snapshot preview\n    setupModals();\n    addStatusMessageStyles();\n    addModalStyles();\n\n    // Add event listener to preserve URL parameters when page is reloaded\n    const handleBeforeUnload = () => {\n      console.log('Preserving URL parameters before page reload');\n\n      // Create a URL with the current parameters\n      const url = new URL(window.location);\n\n      // Ensure page parameter is set correctly (convert from 0-based internal to 1-based URL)\n      if (currentPage > 0) {\n        url.searchParams.set('page', currentPage + 1);\n      } else {\n        url.searchParams.delete('page');\n      }\n\n      // Ensure layout parameter is set if not default\n      if (layout !== '4') {\n        url.searchParams.set('layout', layout);\n      } else {\n        url.searchParams.delete('layout');\n      }\n\n      // Ensure stream parameter is set if in single stream mode\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without triggering navigation\n      window.history.replaceState({}, '', url);\n\n      // Store the current page in sessionStorage as a backup\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      // Store layout in sessionStorage\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      // Store selected stream in sessionStorage\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    };\n\n    // Register the beforeunload handler\n    window.addEventListener('beforeunload', handleBeforeUnload);\n\n    // Set up periodic connection check\n    const connectionCheckInterval = setInterval(() => {\n      Object.keys(webrtcConnections.current).forEach(streamName => {\n        const pc = webrtcConnections.current[streamName];\n        if (pc) {\n          // Log connection state for debugging\n          console.debug(`WebRTC connection state for ${streamName}: ${pc.connectionState}, ICE state: ${pc.iceConnectionState}`);\n\n          // If connection is failed or disconnected for too long, try to reconnect\n          if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n            console.warn(`WebRTC connection for ${streamName} is in ${pc.iceConnectionState} state, will attempt reconnect`);\n\n            // Clean up the old connection\n            cleanupWebRTCPlayer(streamName);\n\n            // Find the stream info and reinitialize\n            const stream = streams.find(s => s.name === streamName);\n            if (stream) {\n              console.log(`Attempting to reconnect WebRTC for stream ${streamName}`);\n              initializeWebRTCPlayer(stream);\n            }\n          }\n        }\n      });\n    }, 30000); // Check every 30 seconds\n\n    // Cleanup\n    return () => {\n      // Remove event listeners\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      clearInterval(connectionCheckInterval);\n      stopAllWebRTCStreams();\n    };\n  }, [streams, currentPage, layout, selectedStream]); // Add all relevant dependencies\n\n  // Get query client for fetching and invalidating queries\n  const queryClient = useQueryClient();\n\n  // Fetch streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery(\n    'streams',\n    '/api/streams',\n    {\n      timeout: 15000, // 15 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    }\n  );\n\n  // Update loading state based on streams query status\n  useEffect(() => {\n    setIsLoading(isLoadingStreams);\n  }, [isLoadingStreams]);\n\n  // Process streams data when it's loaded\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData)) {\n      // Process the streams data\n      const processStreams = async () => {\n        try {\n          // Filter and process the streams\n          const filteredStreams = await filterStreamsForWebRTC(streamsData);\n\n          if (filteredStreams.length > 0) {\n            setStreams(filteredStreams);\n\n            // Set selectedStream based on URL parameter if it exists and is valid\n            const urlParams = new URLSearchParams(window.location.search);\n            const streamParam = urlParams.get('stream');\n\n            if (streamParam && filteredStreams.some(stream => stream.name === streamParam)) {\n              // If the stream from URL exists in the loaded streams, use it\n              setSelectedStream(streamParam);\n            } else if (!selectedStream || !filteredStreams.some(stream => stream.name === selectedStream)) {\n              // Otherwise use the first stream if selectedStream is not set or invalid\n              setSelectedStream(filteredStreams[0].name);\n            }\n          } else {\n            console.warn('No streams available for WebRTC view after filtering');\n          }\n        } catch (error) {\n          console.error('Error processing streams:', error);\n          showStatusMessage('Error processing streams: ' + error.message);\n        }\n      };\n\n      processStreams();\n    }\n  }, [streamsData, selectedStream, queryClient]);\n\n  // Use a ref to track previous values to prevent unnecessary updates\n  const previousValues = useRef({ layout, selectedStream, currentPage, streamsLength: streams.length });\n\n  useEffect(() => {\n    // Only update if something actually changed\n    const prev = previousValues.current;\n    if (\n      prev.layout !== layout ||\n      prev.selectedStream !== selectedStream ||\n      prev.currentPage !== currentPage ||\n      prev.streamsLength !== streams.length\n    ) {\n      console.log('Layout, selectedStream, currentPage, or streams changed, updating video grid');\n      updateVideoGrid();\n\n      // Update previous values\n      previousValues.current = { layout, selectedStream, currentPage, streamsLength: streams.length };\n    }\n  }, [layout, selectedStream, streams, currentPage]);\n\n  // Update URL when layout, page, or selectedStream changes\n  useEffect(() => {\n    // Don't update URL during initial load or when streams are empty\n    if (streams.length === 0) return;\n\n    // Use a debounce to prevent multiple URL updates in quick succession\n    const updateURLTimeout = setTimeout(() => {\n      console.log('Updating URL parameters');\n      const url = new URL(window.location);\n\n      // Handle page parameter (convert from 0-based internal to 1-based URL)\n      if (currentPage === 0) {\n        url.searchParams.delete('page');\n      } else {\n        // Add 1 to convert from 0-based (internal) to 1-based (URL)\n        url.searchParams.set('page', currentPage + 1);\n      }\n\n      // Handle layout parameter\n      if (layout !== '4') { // Only set if not the default\n        url.searchParams.set('layout', layout);\n      } else {\n        // Remove layout parameter if it's the default value\n        url.searchParams.delete('layout');\n      }\n\n      // Handle selectedStream parameter\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        // Remove stream parameter if not in single stream mode\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without reloading the page\n      window.history.replaceState({}, '', url);\n\n      // Also update sessionStorage\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    }, 300); // 300ms debounce\n\n    // Clean up the timeout if the component re-renders before the timeout completes\n    return () => clearTimeout(updateURLTimeout);\n  }, [currentPage, layout, selectedStream, streams.length]);\n\n  /**\n   * Filter streams for WebRTC view\n   * @param {Array} streams - Array of streams\n   * @returns {Promise<Array>} Promise resolving to filtered array of streams\n   */\n  const filterStreamsForWebRTC = async (streams) => {\n    try {\n      if (!streams || !Array.isArray(streams)) {\n        console.warn('No streams data provided to filter');\n        return [];\n      }\n\n      // For WebRTC view, we need to fetch full details for each stream\n      const streamPromises = streams.map(async (stream) => {\n        try {\n          const streamId = stream.id || stream.name;\n\n          const streamDetails = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamId],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamId)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to load details for stream ${stream.name}`);\n              }\n              return response.json();\n            },\n            staleTime: 30000 // 30 seconds\n          });\n\n          return streamDetails;\n        } catch (error) {\n          console.error(`Error loading details for stream ${stream.name}:`, error);\n          // Return the basic stream info if we can't get details\n          return stream;\n        }\n      });\n\n      const detailedStreams = await Promise.all(streamPromises);\n      console.log('Loaded detailed streams for WebRTC view:', detailedStreams);\n\n      // Filter out streams that are soft deleted, inactive, or not configured for streaming\n      const filteredStreams = detailedStreams.filter(stream => {\n        // Filter out soft deleted streams\n        if (stream.is_deleted) {\n          console.log(`Stream ${stream.name} is soft deleted, filtering out`);\n          return false;\n        }\n\n        // Filter out inactive streams\n        if (!stream.enabled) {\n          console.log(`Stream ${stream.name} is inactive, filtering out`);\n          return false;\n        }\n\n        // Filter out streams not configured for streaming\n        if (!stream.streaming_enabled) {\n          console.log(`Stream ${stream.name} is not configured for streaming, filtering out`);\n          return false;\n        }\n\n        return true;\n      });\n\n      console.log('Filtered streams for WebRTC view:', filteredStreams);\n\n      return filteredStreams || [];\n    } catch (error) {\n      console.error('Error filtering streams for WebRTC view:', error);\n      showStatusMessage('Error processing streams: ' + error.message);\n      return [];\n    }\n  };\n\n  /**\n   * Get maximum number of streams to display based on layout\n   * @returns {number} Maximum number of streams\n   */\n  const getMaxStreamsForLayout = () => {\n    switch (layout) {\n      case '1': return 1;  // Single view\n      case '2': return 2;  // 2x1 grid\n      case '4': return 4;  // 2x2 grid\n      case '6': return 6;  // 2x3 grid\n      case '9': return 9;  // 3x3 grid\n      case '16': return 16; // 4x4 grid\n      default: return 4;\n    }\n  };\n\n  /**\n   * Get streams to show based on layout, selected stream, and pagination\n   * @returns {Array} Streams to show\n   */\n  const getStreamsToShow = () => {\n    // Filter streams based on layout and selected stream\n    let streamsToShow = streams;\n    if (layout === '1' && selectedStream) {\n      streamsToShow = streams.filter(stream => stream.name === selectedStream);\n    } else {\n      // Apply pagination\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      // Ensure current page is valid\n      if (currentPage >= totalPages && totalPages > 0) {\n        // We'll handle this in updateVideoGrid\n        return [];\n      }\n\n      // Get streams for current page\n      const startIdx = currentPage * maxStreams;\n      const endIdx = Math.min(startIdx + maxStreams, streams.length);\n      streamsToShow = streams.slice(startIdx, endIdx);\n    }\n\n    return streamsToShow;\n  };\n\n  /**\n   * Update video grid based on layout, streams, and pagination\n   */\n  const updateVideoGrid = () => {\n    if (!videoGridRef.current) return;\n\n    // Filter streams based on layout and selected stream\n    let streamsToShow = getStreamsToShow();\n\n    // If no streams to show and we have streams, check if page is invalid\n    if (streamsToShow.length === 0 && streams.length > 0) {\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      if (currentPage >= totalPages) {\n        setCurrentPage(Math.max(0, totalPages - 1));\n        return; // Will re-render with corrected page\n      }\n    }\n\n    // Get the names of streams that should be shown\n    const streamsToShowNames = streamsToShow.map(stream => stream.name);\n\n    // Log page change for debugging\n    console.log(`Updating video grid for page ${currentPage + 1}, showing streams:`, streamsToShowNames);\n\n    // Clean up connections for streams that are no longer visible\n    const connectionsToCleanup = Object.keys(webrtcConnections.current).filter(\n      streamName => !streamsToShowNames.includes(streamName)\n    );\n\n    if (connectionsToCleanup.length > 0) {\n      console.log(`Cleaning up ${connectionsToCleanup.length} WebRTC connections that are no longer visible:`, connectionsToCleanup);\n      connectionsToCleanup.forEach(streamName => {\n        cleanupWebRTCPlayer(streamName);\n      });\n    }\n  };\n\n  /**\n   * Initialize WebRTC player for a stream\n   * @param {Object} stream - Stream object\n   * @param {HTMLVideoElement} videoElement - Video element\n   * @param {HTMLCanvasElement} canvasOverlay - Canvas overlay for detection\n   * @param {Object} callbacks - Callback functions\n   */\n  const initializeWebRTCPlayer = (stream, videoElement, canvasOverlay, callbacks = {}) => {\n    if (!stream || !videoElement) {\n      console.error(`Cannot initialize WebRTC player: missing stream or video element`);\n      return;\n    }\n\n    // Check if there's already a connection for this stream\n    if (webrtcConnections.current[stream.name]) {\n      console.log(`WebRTC connection for stream ${stream.name} already exists, cleaning up first`);\n      cleanupWebRTCPlayer(stream.name);\n    }\n\n    console.log(`Initializing WebRTC player for stream ${stream.name}`);\n\n    // Create a new RTCPeerConnection with ICE servers\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ],\n      // Add additional configuration to ensure proper ICE credentials\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'balanced',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'unified-plan'\n    });\n\n    // Store the connection for cleanup\n    webrtcConnections.current[stream.name] = pc;\n\n    // Add event listeners\n    pc.ontrack = (event) => {\n      console.log(`Track received for stream ${stream.name}:`, event);\n      if (event.track.kind === 'video') {\n        videoElement.srcObject = event.streams[0];\n\n        // Add event handlers for video element\n        videoElement.onloadeddata = () => {\n          console.log(`Video data loaded for stream ${stream.name}`);\n          if (callbacks.onLoadedData) {\n            callbacks.onLoadedData();\n          }\n        };\n\n        videoElement.onplaying = () => {\n          console.log(`Video playing for stream ${stream.name}`);\n          if (callbacks.onPlaying) {\n            callbacks.onPlaying();\n          }\n\n          // Start detection polling now that the video is playing\n          if (stream.detection_based_recording && stream.detection_model && canvasOverlay) {\n            console.log(`Starting detection polling for stream ${stream.name} now that video is playing`);\n            startDetectionPolling(stream.name, canvasOverlay, videoElement, detectionIntervals.current);\n          } else {\n            console.log(`Detection not enabled for stream ${stream.name}`);\n          }\n        };\n\n        videoElement.onerror = (e) => {\n          console.error(`Video error for stream ${stream.name}:`, e);\n          if (callbacks.onError) {\n            callbacks.onError('Video playback error');\n          }\n        };\n      }\n    };\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log(`ICE candidate for stream ${stream.name}:`, event.candidate);\n        // go2rtc doesn't use a separate ICE endpoint, so we don't need to send ICE candidates\n      }\n    };\n\n    pc.oniceconnectionstatechange = () => {\n      console.log(`ICE connection state for stream ${stream.name}:`, pc.iceConnectionState);\n\n      // Handle different ICE connection states\n      if (pc.iceConnectionState === 'failed') {\n        console.warn(`ICE failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC ICE connection failed');\n        }\n      } else if (pc.iceConnectionState === 'disconnected') {\n        console.warn(`ICE disconnected for stream ${stream.name}`);\n        // Don't immediately handle as error, as disconnected can be temporary\n      }\n    };\n\n    // Also monitor connection state changes\n    pc.onconnectionstatechange = () => {\n      console.log(`Connection state changed for stream ${stream.name}:`, pc.connectionState);\n\n      if (pc.connectionState === 'failed') {\n        console.warn(`Connection failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC connection failed');\n        }\n      }\n    };\n\n    // Add transceivers to ensure we get both audio and video tracks\n    pc.addTransceiver('video', {direction: 'recvonly'});\n    pc.addTransceiver('audio', {direction: 'recvonly'});\n\n    // Create an offer with specific codec requirements\n    const offerOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n\n    // Create a timeout for the entire WebRTC setup process\n    const setupTimeoutId = setTimeout(() => {\n      console.warn(`WebRTC setup timed out for stream ${stream.name}`);\n      if (callbacks.onError) {\n        callbacks.onError('WebRTC setup timed out');\n      }\n\n      // Clean up the connection if it exists\n      if (webrtcConnections.current[stream.name]) {\n        cleanupWebRTCPlayer(stream.name);\n      }\n    }, 30000); // 30 second timeout for the entire setup process\n\n    // Create a separate timeout for video playback\n    const videoPlaybackTimeoutId = setTimeout(() => {\n      // Only show error if the connection still exists but video isn't playing\n      if (webrtcConnections.current[stream.name] &&\n          (!videoElement.srcObject || videoElement.readyState < 2)) { // HAVE_CURRENT_DATA = 2\n        console.warn(`Video playback timed out for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('Video playback timed out');\n        }\n      }\n    }, 20000); // 20 second timeout for video playback\n\n    // Add a check to ensure the connection still exists before proceeding\n    const checkConnectionExists = () => {\n      return webrtcConnections.current[stream.name] === pc;\n    };\n\n    pc.createOffer(offerOptions)\n      .then(offer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up during offer creation');\n        }\n        console.log(`Created offer for stream ${stream.name}`);\n        return pc.setLocalDescription(offer);\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting local description');\n        }\n        console.log(`Set local description for stream ${stream.name}`);\n        // Send the offer to the server\n        return sendOffer(stream.name, pc.localDescription);\n      })\n      .then(answer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after receiving answer');\n        }\n        console.log(`Received answer for stream ${stream.name}`);\n        // Set the remote description\n        return pc.setRemoteDescription(new RTCSessionDescription(answer));\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting remote description');\n        }\n        console.log(`Set remote description for stream ${stream.name}`);\n\n        // Clear both timeouts since we've successfully set up the connection\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n      })\n      .catch(error => {\n        // Clear both timeouts\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n\n        // Only log and call error callback if the connection still exists\n        if (checkConnectionExists()) {\n          console.error(`Error setting up WebRTC for stream ${stream.name}:`, error);\n          if (callbacks.onError) {\n            callbacks.onError(error.message);\n          }\n        } else {\n          console.log(`WebRTC setup for stream ${stream.name} was cancelled: ${error.message}`);\n        }\n      });\n\n    // Add event listener to clear the video playback timeout when video starts playing\n    videoElement.addEventListener('playing', () => {\n      clearTimeout(videoPlaybackTimeoutId);\n    }, { once: true }); // Use once: true to ensure it only fires once\n  };\n\n  /**\n   * Send WebRTC offer to server\n   * @param {string} streamName - Stream name\n   * @param {RTCSessionDescription} offer - WebRTC offer\n   * @returns {Promise<RTCSessionDescription>} Promise resolving to WebRTC answer\n   */\n  const sendOffer = useCallback(async (streamName, offer) => {\n    try {\n      // Format the offer according to go2rtc expectations\n      const formattedOffer = {\n        type: offer.type,\n        sdp: offer.sdp\n      };\n\n      console.log(`Sending formatted offer for stream ${streamName}`);\n\n      // Create an AbortController to allow cancellation of the request\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n\n      // Store the abort controller in the connection object for later cleanup\n      if (webrtcConnections.current[streamName]) {\n        webrtcConnections.current[streamName].abortController = abortController;\n      } else {\n        // If the connection no longer exists, abort immediately\n        console.log(`Connection for stream ${streamName} no longer exists, aborting offer`);\n        abortController.abort();\n        return Promise.reject(new Error('Connection no longer exists'));\n      }\n\n      // Use the mutation to send the offer with the abort signal\n      const result = await webrtcOfferMutation.mutateAsync({\n        ...formattedOffer,\n        streamName, // Add streamName for the URL construction in mutationFn\n        signal      // Add signal for request cancellation\n      });\n\n      // Check if the connection still exists before returning the result\n      if (webrtcConnections.current[streamName]) {\n        return result;\n      } else {\n        // If the connection was cleaned up during the request, abort and reject\n        console.log(`Connection for stream ${streamName} was cleaned up during offer, rejecting result`);\n        return Promise.reject(new Error('Connection was cleaned up during offer'));\n      }\n    } catch (error) {\n      // Check if this was an abort error, which we can safely ignore\n      if (error.name === 'AbortError') {\n        console.log(`WebRTC offer request for stream ${streamName} was aborted`);\n        // Return a rejected promise to stop the WebRTC connection process\n        return Promise.reject(new Error('Request aborted'));\n      }\n\n      console.error(`Error sending offer for stream ${streamName}:`, error);\n      throw error;\n    }\n  }, [webrtcOfferMutation]);\n\n  // ICE candidates are handled internally by the browser for go2rtc\n\n  /**\n   * Handle WebRTC error\n   * @param {string} streamName - Stream name\n   * @param {string} message - Error message\n   */\n  const handleWebRTCError = async (streamName, message) => {\n    console.error(`WebRTC error for stream ${streamName}:`, message);\n\n    // Find the video cell\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    if (!videoElement) return;\n\n    const videoCell = videoElement.closest('.video-cell');\n    if (!videoCell) return;\n\n    // Hide loading indicator\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'none';\n    }\n\n    // Create error indicator if it doesn't exist\n    let errorIndicator = videoCell.querySelector('.error-indicator');\n    if (!errorIndicator) {\n      errorIndicator = document.createElement('div');\n      errorIndicator.className = 'error-indicator';\n      errorIndicator.style.position = 'absolute';\n      errorIndicator.style.top = '0';\n      errorIndicator.style.left = '0';\n      errorIndicator.style.width = '100%';\n      errorIndicator.style.height = '100%';\n      errorIndicator.style.display = 'flex';\n      errorIndicator.style.flexDirection = 'column';\n      errorIndicator.style.justifyContent = 'center';\n      errorIndicator.style.alignItems = 'center';\n      errorIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n      errorIndicator.style.color = 'white';\n      errorIndicator.style.zIndex = '20'; // Above video but below controls\n      videoCell.appendChild(errorIndicator);\n    }\n\n    // Create the error message and retry button\n    const errorIcon = document.createElement('div');\n    errorIcon.className = 'error-icon';\n    errorIcon.textContent = '!';\n    errorIcon.style.fontSize = '24px';\n    errorIcon.style.marginBottom = '10px';\n    errorIcon.style.fontWeight = 'bold';\n\n    const errorMsg = document.createElement('p');\n    errorMsg.textContent = message || 'WebRTC connection failed';\n    errorMsg.style.marginBottom = '15px';\n    errorMsg.style.textAlign = 'center';\n    errorMsg.style.maxWidth = '80%';\n    errorMsg.style.color = 'white';\n\n    const retryButton = document.createElement('button');\n    retryButton.className = 'retry-button';\n    retryButton.textContent = 'Retry';\n    retryButton.style.padding = '8px 16px';\n    retryButton.style.backgroundColor = '#2563eb'; // blue-600\n    retryButton.style.color = 'white';\n    retryButton.style.borderRadius = '4px';\n    retryButton.style.border = 'none';\n    retryButton.style.cursor = 'pointer';\n    retryButton.style.position = 'relative';\n    retryButton.style.zIndex = '30';\n    retryButton.style.pointerEvents = 'auto';\n    retryButton.style.margin = '0 auto';\n    retryButton.style.display = 'block';\n\n    // Clear the error indicator and add the new elements\n    errorIndicator.innerHTML = '';\n    errorIndicator.appendChild(errorIcon);\n    errorIndicator.appendChild(errorMsg);\n    errorIndicator.appendChild(retryButton);\n\n    errorIndicator.style.display = 'flex';\n    errorIndicator.style.pointerEvents = 'auto'; // Enable pointer events when visible to allow retry button clicks\n\n    // Add event listener to retry button\n    retryButton.addEventListener('click', async (event) => {\n      console.log('Retry button clicked for stream:', streamName);\n      event.preventDefault();\n      event.stopPropagation();\n\n      // Show loading indicator\n      if (loadingIndicator) {\n        loadingIndicator.style.display = 'flex';\n      }\n\n      // Hide error indicator\n      errorIndicator.style.display = 'none';\n\n      // Cleanup existing connection\n      cleanupWebRTCPlayer(streamName);\n\n      // Find the stream in our streams array\n      const stream = streams.find(s => s.name === streamName);\n\n      if (stream) {\n        console.log(`Found stream ${streamName} in local state, reinitializing`);\n        // Small delay to ensure cleanup is complete\n        setTimeout(() => {\n          initializeWebRTCPlayer(stream);\n        }, 100);\n      } else {\n        console.log(`Stream ${streamName} not found in local state, fetching from API`);\n\n        try {\n          // Fetch stream info using queryClient\n          const streamInfo = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamName],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamName)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to fetch stream info: ${response.status} ${response.statusText}`);\n              }\n              return response.json();\n            },\n            staleTime: 10000 // 10 seconds\n          });\n\n          console.log(`Received stream info for ${streamName}, reinitializing`);\n          // Reinitialize with a small delay\n          setTimeout(() => {\n            initializeWebRTCPlayer(streamInfo);\n          }, 100);\n        } catch (error) {\n          console.error('Error fetching stream info:', error);\n\n          // Show error indicator again with new message\n          errorIndicator.style.display = 'flex';\n          errorMsg.textContent = 'Could not reconnect: ' + error.message;\n\n          // Hide loading indicator\n          if (loadingIndicator) {\n            loadingIndicator.style.display = 'none';\n          }\n        }\n      }\n    });\n  };\n\n  /**\n   * Cleanup WebRTC player\n   * @param {string} streamName - Stream name\n   */\n  const cleanupWebRTCPlayer = (streamName) => {\n    console.log(`Cleaning up WebRTC player for stream ${streamName}`);\n\n    // Close and remove the RTCPeerConnection\n    if (webrtcConnections.current[streamName]) {\n      // Create a local reference to the connection before deleting it\n      const connection = webrtcConnections.current[streamName];\n\n      // Abort any pending fetch requests\n      if (connection.abortController) {\n        console.log(`Aborting pending WebRTC requests for stream ${streamName}`);\n        try {\n          connection.abortController.abort();\n        } catch (e) {\n          console.error(`Error aborting WebRTC request for stream ${streamName}:`, e);\n        }\n      }\n\n      // Remove all event listeners to prevent memory leaks\n      if (connection.onicecandidate) connection.onicecandidate = null;\n      if (connection.oniceconnectionstatechange) connection.oniceconnectionstatechange = null;\n      if (connection.onconnectionstatechange) connection.onconnectionstatechange = null;\n      if (connection.ontrack) connection.ontrack = null;\n\n      // Close the connection\n      connection.close();\n\n      // Remove from our reference object\n      delete webrtcConnections.current[streamName];\n\n      console.log(`Closed WebRTC connection for stream ${streamName}`);\n    }\n\n    // Clean up detection polling\n    cleanupDetectionPolling(streamName, detectionIntervals.current);\n  };\n\n  /**\n   * Stop all WebRTC streams\n   */\n  const stopAllWebRTCStreams = () => {\n    console.log('Stopping all WebRTC streams');\n    // Close all RTCPeerConnections\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      cleanupWebRTCPlayer(streamName);\n    });\n    console.log('All WebRTC streams stopped');\n  };\n\n/**\n * Take snapshot of a stream\n * @param {string} streamId - Stream ID\n * @param {Event} event - Click event\n */\nconst takeSnapshot = (streamId, event) => {\n  // Prevent default button behavior\n  if (event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  console.log(`Taking snapshot of stream with ID: ${streamId}`);\n\n  // Find the stream by ID or name\n  let streamName = streamId;\n  const stream = streams.find(s => s.id === streamId || s.name === streamId);\n  if (stream) {\n    streamName = stream.name;\n  }\n\n  if (!streamName) {\n    console.error('Stream name not found for snapshot');\n    showStatusMessage('Cannot take snapshot: Stream not identified');\n    return;\n  }\n\n  // Find the video element\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  if (!videoElement) {\n    console.error('Video element not found for stream:', streamName);\n    showStatusMessage('Cannot take snapshot: Video element not found');\n    return;\n  }\n\n  // Create a canvas element to capture the frame\n  const canvas = document.createElement('canvas');\n  canvas.width = videoElement.videoWidth;\n  canvas.height = videoElement.videoHeight;\n  canvas.style.pointerEvents = 'none'; // Ensure canvas doesn't capture clicks\n\n  // Check if we have valid dimensions\n  if (canvas.width === 0 || canvas.height === 0) {\n    console.error('Invalid video dimensions:', canvas.width, canvas.height);\n    showStatusMessage('Cannot take snapshot: Video not loaded or has invalid dimensions');\n    return;\n  }\n\n  // Draw the current frame to the canvas\n  const ctx = canvas.getContext('2d');\n  ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);\n\n  try {\n    // Save the canvas to global scope for direct access in the overlay\n    window.__snapshotCanvas = canvas;\n\n    // Generate a filename\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = `snapshot-${streamName.replace(/\\s+/g, '-')}-${timestamp}.jpg`;\n    window.__snapshotFileName = fileName;\n\n    // Show the standard preview\n    showSnapshotPreview(canvas.toDataURL('image/jpeg', 0.95), `Snapshot: ${streamName}`);\n\n    // Show success message\n    showStatusMessage('Snapshot taken successfully');\n  } catch (error) {\n    console.error('Error creating snapshot:', error);\n    showStatusMessage('Failed to create snapshot: ' + error.message);\n  }\n};\n\n  /**\n   * Toggle fullscreen mode for a specific stream\n   * @param {string} streamName - Stream name\n   * @param {Event} event - Click event\n   */\n  const toggleStreamFullscreen = (streamName, event) => {\n    // Prevent default button behavior\n    if (event) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (!streamName) {\n      console.error('Stream name not provided for fullscreen toggle');\n      return;\n    }\n\n    console.log(`Toggling fullscreen for stream: ${streamName}`);\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n\n    if (!videoCell) {\n      console.error('Stream not found:', streamName);\n      return;\n    }\n\n    if (!document.fullscreenElement) {\n      console.log('Entering fullscreen mode for video cell');\n      videoCell.requestFullscreen().catch(err => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n      });\n    } else {\n      console.log('Exiting fullscreen mode');\n      document.exitFullscreen();\n    }\n  };\n\n  return (\n    <section id=\"live-page\" className={`page ${isFullscreen ? 'fullscreen-mode' : ''}`}>\n      <div className=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\">\n        <div className=\"flex items-center space-x-2\">\n          <h2 className=\"text-xl font-bold mr-4\">Live View</h2>\n          <div className=\"flex space-x-2\">\n            <button\n              id=\"hls-toggle-btn\"\n              className=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick={() => window.location.href = '/hls.html'}\n            >\n              HLS View\n            </button>\n          </div>\n        </div>\n        <div className=\"controls flex items-center space-x-2\">\n          <div className=\"flex items-center\">\n            <label for=\"layout-selector\" className=\"mr-2\">Layout:</label>\n            <select\n                id=\"layout-selector\"\n                className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                value={layout}\n                onChange={(e) => {\n                  const newLayout = e.target.value;\n                  setLayout(newLayout);\n                  setCurrentPage(0); // Reset to first page when layout changes\n                  // URL will be updated by the useEffect hook\n                }}\n            >\n              <option value=\"1\">1 Stream</option>\n              <option value=\"2\">2 Streams</option>\n              <option value=\"4\" selected>4 Streams</option>\n              <option value=\"6\">6 Streams</option>\n              <option value=\"9\">9 Streams</option>\n              <option value=\"16\">16 Streams</option>\n            </select>\n          </div>\n\n          {layout === '1' && (\n              <div className=\"flex items-center\">\n                <label for=\"stream-selector\" className=\"mr-2\">Stream:</label>\n                <select\n                    id=\"stream-selector\"\n                    className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                    value={selectedStream}\n                    onChange={(e) => {\n                      const newStream = e.target.value;\n                      setSelectedStream(newStream);\n                      // URL will be updated by the useEffect hook\n                    }}\n                >\n                  {streams.map(stream =>\n                      <option key={stream.name} value={stream.name}>{stream.name}</option>\n                  )}\n                </select>\n              </div>\n          )}\n\n          <button\n              id=\"fullscreen-btn\"\n              className=\"p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 focus:outline-none\"\n              onClick={() => toggleFullscreen(isFullscreen, setIsFullscreen)}\n              title=\"Toggle Fullscreen\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\"\n                 stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n              <path\n                  d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path>\n            </svg>\n          </button>\n        </div>\n      </div>\n\n      <div className=\"flex flex-col space-y-4\">\n        <div\n            id=\"video-grid\"\n            className={`video-container layout-${layout}`}\n            ref={videoGridRef}\n        >\n          {isLoadingStreams ? (\n              <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n                <div className=\"flex flex-col items-center justify-center py-8\">\n                  <div\n                      className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                  <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (isLoading && !isLoadingStreams) ? (\n            <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n              <div className=\"flex flex-col items-center justify-center py-8\">\n                <div\n                    className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (streamsError) ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">Error loading streams: {streamsError.message}</p>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\"\n              >\n                Retry\n              </button>\n            </div>\n          ) : streams.length === 0 ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n              <a href=\"streams.html\" className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n            </div>\n          ) : (\n            // Render video cells using our WebRTCVideoCell component\n            getStreamsToShow().map(stream => (\n              <WebRTCVideoCell\n                key={stream.name}\n                stream={stream}\n                onTakeSnapshot={takeSnapshot}\n                onToggleFullscreen={toggleStreamFullscreen}\n                webrtcConnections={webrtcConnections}\n                detectionIntervals={detectionIntervals}\n                initializeWebRTCPlayer={initializeWebRTCPlayer}\n                cleanupWebRTCPlayer={cleanupWebRTCPlayer}\n              />\n            ))\n          )}\n        </div>\n\n        {layout !== '1' && streams.length > getMaxStreamsForLayout() ? (\n          <div className=\"pagination-controls flex justify-center items-center space-x-4 mt-4\">\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to previous page');\n                setCurrentPage(Math.max(0, currentPage - 1));\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                const newPage = currentPage - 1;\n\n                if (newPage > 0) {\n                  url.searchParams.set('page', newPage + 1);\n                  sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n                } else {\n                  url.searchParams.delete('page');\n                  sessionStorage.removeItem('webrtc_current_page');\n                }\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage === 0}\n            >\n              Previous\n            </button>\n\n            <span className=\"text-gray-700 dark:text-gray-300\">\n              Page {currentPage + 1} of {Math.ceil(streams.length / getMaxStreamsForLayout())}\n            </span>\n\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to next page');\n                const newPage = Math.min(Math.ceil(streams.length / getMaxStreamsForLayout()) - 1, currentPage + 1);\n                setCurrentPage(newPage);\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                url.searchParams.set('page', newPage + 1);\n                sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage >= Math.ceil(streams.length / getMaxStreamsForLayout()) - 1}\n            >\n              Next\n            </button>\n          </div>\n        ) : null}\n      </div>\n    </section>\n  );\n}\n","/**\n * LightNVR Web Interface Live View Page\n * Entry point for the live view page with WebRTC/HLS support\n */\n\nimport { render } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { LiveView } from '../components/preact/LiveView.jsx';\nimport { WebRTCView } from '../components/preact/WebRTCView.jsx';\nimport { QueryClientProvider, queryClient } from '../query-client.js';\nimport { Header } from \"../components/preact/Header.jsx\";\nimport { Footer } from \"../components/preact/Footer.jsx\";\n\n/**\n * Main App component that conditionally renders WebRTCView or LiveView\n * based on whether WebRTC is disabled in settings\n */\nfunction App() {\n    const [isWebRTCDisabled, setIsWebRTCDisabled] = useState(false);\n    const [isLoading, setIsLoading] = useState(true);\n\n    useEffect(() => {\n        // Check if WebRTC is disabled in settings\n        async function checkWebRTCStatus() {\n            try {\n                const response = await fetch('/api/settings');\n                if (!response.ok) {\n                    console.error('Failed to fetch settings:', response.status, response.statusText);\n                    setIsLoading(false);\n                    return;\n                }\n\n                const settings = await response.json();\n                \n                if (settings.webrtc_disabled) {\n                    console.log('WebRTC is disabled, using HLS view');\n                    setIsWebRTCDisabled(true);\n                } else {\n                    console.log('WebRTC is enabled, using WebRTC view');\n                    setIsWebRTCDisabled(false);\n                }\n            } catch (error) {\n                console.error('Error checking WebRTC status:', error);\n            } finally {\n                setIsLoading(false);\n            }\n        }\n\n        checkWebRTCStatus();\n    }, []);\n\n    if (isLoading) {\n        return <div className=\"loading\">Loading...</div>;\n    }\n\n    return (\n        <>\n            <Header />\n            {isWebRTCDisabled ? <LiveView isWebRTCDisabled={true} /> : <WebRTCView />}\n            <Footer />\n        </>\n    );\n}\n\n// Render the App component when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Get the container element\n    const container = document.getElementById('main-content');\n\n    if (container) {\n        render(\n            <QueryClientProvider client={queryClient}>\n                <App />\n            </QueryClientProvider>,\n            container\n        );\n    }\n});\n"],"names":["WebRTCView","webrtcOfferMutation","useMutation","mutationFn","async","streamName","offerData","data","auth","localStorage","getItem","response","fetch","encodeURIComponent","method","headers","Authorization","body","JSON","stringify","signal","ok","Error","status","statusText","text","parse","jsonError","console","error","log","message","onError","variables","streams","setStreams","useState","layout","setLayout","layoutParam","URLSearchParams","window","location","search","get","sessionStorage","selectedStream","setSelectedStream","streamParam","isFullscreen","setIsFullscreen","isLoading","setIsLoading","currentPage","setCurrentPage","pageParam","Math","max","parseInt","storedPage","videoGridRef","useRef","webrtcConnections","detectionIntervals","useEffect","setupModals","addStatusMessageStyles","addModalStyles","handleBeforeUnload","url","URL","searchParams","set","delete","history","replaceState","setItem","toString","removeItem","addEventListener","connectionCheckInterval","setInterval","Object","keys","current","forEach","pc","debug","connectionState","iceConnectionState","warn","cleanupWebRTCPlayer","stream","find","s","name","initializeWebRTCPlayer","removeEventListener","clearInterval","stopAllWebRTCStreams","queryClient","useQueryClient","streamsData","isLoadingStreams","streamsError","useQuery","timeout","retries","retryDelay","Array","isArray","filteredStreams","filterStreamsForWebRTC","length","some","showStatusMessage","processStreams","previousValues","streamsLength","prev","updateVideoGrid","updateURLTimeout","setTimeout","clearTimeout","streamPromises","map","streamId","id","fetchQuery","queryKey","queryFn","json","staleTime","detailedStreams","Promise","all","filter","is_deleted","enabled","streaming_enabled","getMaxStreamsForLayout","getStreamsToShow","streamsToShow","maxStreams","totalPages","ceil","startIdx","endIdx","min","slice","streamsToShowNames","connectionsToCleanup","includes","videoElement","canvasOverlay","callbacks","RTCPeerConnection","iceServers","urls","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","sdpSemantics","ontrack","event","track","kind","srcObject","onloadeddata","onLoadedData","onplaying","onPlaying","detection_based_recording","detection_model","startDetectionPolling","onerror","e","onicecandidate","candidate","oniceconnectionstatechange","onconnectionstatechange","addTransceiver","direction","setupTimeoutId","videoPlaybackTimeoutId","readyState","checkConnectionExists","createOffer","offerToReceiveAudio","offerToReceiveVideo","then","offer","setLocalDescription","sendOffer","localDescription","answer","setRemoteDescription","RTCSessionDescription","catch","once","useCallback","formattedOffer","type","sdp","abortController","AbortController","abort","reject","result","mutateAsync","connection","close","cleanupDetectionPolling","takeSnapshot","preventDefault","stopPropagation","videoElementId","replace","document","getElementById","canvas","createElement","width","videoWidth","height","videoHeight","style","pointerEvents","getContext","drawImage","__snapshotCanvas","timestamp","Date","toISOString","fileName","__snapshotFileName","showSnapshotPreview","toDataURL","toggleStreamFullscreen","videoCell","closest","fullscreenElement","exitFullscreen","requestFullscreen","err","jsxs","className","children","jsx","onClick","href","for","value","onChange","newLayout","target","selected","newStream","toggleFullscreen","title","xmlns","viewBox","fill","stroke","d","ref","reload","WebRTCVideoCell","onTakeSnapshot","onToggleFullscreen","newPage","disabled","App","isWebRTCDisabled","setIsWebRTCDisabled","webrtc_disabled","checkWebRTCStatus","Fragment","Header","LiveView","Footer","container","render","QueryClientProvider","client"],"mappings":"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"}