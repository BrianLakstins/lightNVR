{"version":3,"file":"DetectionOverlay-legacy-oEXu6ilL.js","sources":["../../js/components/preact/FullscreenManager.js","../../js/components/preact/DetectionOverlay.js"],"sourcesContent":["/**\n * Fullscreen functionality for LiveView\n */\n\nimport { showStatusMessage } from './UI.js';\n\n/**\n * Exit fullscreen mode\n * @param {Event} e - Optional event object\n * @param {Function} setIsFullscreen - State setter for fullscreen state\n */\nexport function exitFullscreenMode(e, setIsFullscreen) {\n  // If this was called from an event, stop propagation\n  if (e) {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n  \n  console.log(\"DIRECT EXIT FUNCTION CALLED\");\n  \n  const livePage = document.getElementById('live-page');\n  if (!livePage) {\n    console.error(\"Live page element not found\");\n    return;\n  }\n  \n  // Exit fullscreen\n  livePage.classList.remove('fullscreen-mode');\n  document.body.style.overflow = '';\n  \n  // Remove exit button\n  const exitBtn = document.querySelector('.fullscreen-exit');\n  if (exitBtn) {\n    exitBtn.remove();\n  } else {\n    console.warn(\"Exit button not found when trying to remove it\");\n  }\n  \n  // Show the fullscreen button again\n  const fullscreenBtn = document.getElementById('fullscreen-btn');\n  if (fullscreenBtn) {\n    fullscreenBtn.style.display = '';\n  } else {\n    console.warn(\"Fullscreen button not found when trying to show it again\");\n  }\n  \n  // Update state\n  setIsFullscreen(false);\n  \n  console.log(\"Fullscreen mode exited, state set to false\");\n}\n\n/**\n * Toggle fullscreen mode for the entire live view\n * @param {boolean} isFullscreen - Current fullscreen state\n * @param {Function} setIsFullscreen - State setter for fullscreen state\n */\nexport function toggleFullscreen(isFullscreen, setIsFullscreen) {\n  console.log(\"toggleFullscreen called, current state:\", isFullscreen);\n  \n  const livePage = document.getElementById('live-page');\n  \n  if (!livePage) {\n    console.error(\"Live page element not found\");\n    return;\n  }\n  \n  // Check the actual DOM state rather than relying on the React state\n  const isCurrentlyInFullscreen = livePage.classList.contains('fullscreen-mode');\n  console.log(\"DOM check for fullscreen mode:\", isCurrentlyInFullscreen);\n  \n  if (!isCurrentlyInFullscreen) {\n    console.log(\"Entering fullscreen mode\");\n    // Enter fullscreen\n    livePage.classList.add('fullscreen-mode');\n    document.body.style.overflow = 'hidden';\n    \n    // Add exit button - IMPORTANT: Use a standalone function for the click handler\n    const exitBtn = document.createElement('button');\n    exitBtn.className = 'fullscreen-exit fixed top-4 right-4 w-10 h-10 bg-black/70 text-white rounded-full flex justify-center items-center cursor-pointer z-50 transition-all duration-200 hover:bg-black/85 hover:scale-110 shadow-md';\n    exitBtn.innerHTML = 'âœ•';\n    \n    // Create a standalone function for the click handler\n    const exitClickHandler = function(e) {\n      console.log(\"Exit button clicked - STANDALONE HANDLER\");\n      exitFullscreenMode(e, setIsFullscreen);\n    };\n    \n    // Add the event listener with the standalone function\n    exitBtn.addEventListener('click', exitClickHandler);\n    \n    livePage.appendChild(exitBtn);\n    \n    // Hide the fullscreen button in the controls when in fullscreen mode\n    const fullscreenBtn = document.getElementById('fullscreen-btn');\n    if (fullscreenBtn) {\n      fullscreenBtn.style.display = 'none';\n    }\n    \n    // Update state\n    setIsFullscreen(true);\n    console.log(\"Fullscreen mode entered, state set to true\");\n  } else {\n    exitFullscreenMode(null, setIsFullscreen);\n  }\n}\n\n/**\n * Toggle fullscreen mode for a specific stream\n * @param {string} streamName - Name of the stream\n */\nexport function toggleStreamFullscreen(streamName) {\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n  \n  if (!videoCell) {\n    console.error('Stream not found:', streamName);\n    return;\n  }\n  \n  if (!document.fullscreenElement) {\n    videoCell.requestFullscreen().catch(err => {\n      console.error(`Error attempting to enable fullscreen: ${err.message}`);\n      showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n    });\n  } else {\n    document.exitFullscreen();\n  }\n}\n","/**\n * Detection overlay functionality for LiveView\n */\n\n/**\n * Start detection polling for a stream\n * @param {string} streamName - Name of the stream\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n * @param {Object} detectionIntervals - Reference to store interval IDs\n * @returns {number} Interval ID\n */\nexport function startDetectionPolling(streamName, canvasOverlay, videoElement, detectionIntervals) {\n  // Clear existing interval if any\n  if (detectionIntervals[streamName]) {\n    clearInterval(detectionIntervals[streamName]);\n  }\n  \n  // Function to draw bounding boxes\n  const drawDetectionBoxes = (detections) => {\n    const canvas = canvasOverlay;\n    const ctx = canvas.getContext('2d');\n    \n    // Set canvas dimensions to match the displayed video element\n    canvas.width = videoElement.clientWidth;\n    canvas.height = videoElement.clientHeight;\n    \n    // Clear previous drawings\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // No detections, just return\n    if (!detections || detections.length === 0) {\n      return;\n    }\n    \n    // Get the actual video dimensions\n    const videoWidth = videoElement.videoWidth;\n    const videoHeight = videoElement.videoHeight;\n    \n    // If video dimensions aren't available yet, skip drawing\n    if (!videoWidth || !videoHeight) {\n      console.log('Video dimensions not available yet, skipping detection drawing');\n      return;\n    }\n    \n    // Calculate the scaling and positioning to maintain aspect ratio\n    const videoAspect = videoWidth / videoHeight;\n    const canvasAspect = canvas.width / canvas.height;\n    \n    let drawWidth, drawHeight, offsetX = 0, offsetY = 0;\n    \n    if (videoAspect > canvasAspect) {\n      // Video is wider than canvas (letterboxing - black bars on top and bottom)\n      drawWidth = canvas.width;\n      drawHeight = canvas.width / videoAspect;\n      offsetY = (canvas.height - drawHeight) / 2;\n    } else {\n      // Video is taller than canvas (pillarboxing - black bars on sides)\n      drawHeight = canvas.height;\n      drawWidth = canvas.height * videoAspect;\n      offsetX = (canvas.width - drawWidth) / 2;\n    }\n    \n    // Draw each detection\n    detections.forEach(detection => {\n      // Calculate pixel coordinates based on normalized values (0-1)\n      // and adjust for the actual display area\n      const x = (detection.x * drawWidth) + offsetX;\n      const y = (detection.y * drawHeight) + offsetY;\n      const width = detection.width * drawWidth;\n      const height = detection.height * drawHeight;\n      \n      // Draw bounding box\n      ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(x, y, width, height);\n      \n      // Draw label background\n      const label = `${detection.label} (${Math.round(detection.confidence * 100)}%)`;\n      ctx.font = '14px Arial';\n      const textWidth = ctx.measureText(label).width;\n      ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';\n      ctx.fillRect(x, y - 20, textWidth + 10, 20);\n      \n      // Draw label text\n      ctx.fillStyle = 'white';\n      ctx.fillText(label, x + 5, y - 5);\n    });\n  };\n  \n  // Use a more conservative polling interval (1000ms instead of 500ms)\n  // and implement exponential backoff on errors\n  let errorCount = 0;\n  let currentInterval = 1000; // Start with 1 second\n  \n  // Poll for detection results\n  const intervalId = setInterval(() => {\n    if (!videoElement.videoWidth) {\n      // Video not loaded yet, skip this cycle\n      return;\n    }\n    \n    // Fetch detection results from API\n    fetch(`/api/detection/results/${encodeURIComponent(streamName)}`)\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`Failed to fetch detection results: ${response.status}`);\n        }\n        // Reset error count on success\n        errorCount = 0;\n        return response.json();\n      })\n      .then(data => {\n        // Draw bounding boxes if we have detections\n        if (data && data.detections) {\n          drawDetectionBoxes(data.detections);\n        }\n      })\n      .catch(error => {\n        console.error(`Error fetching detection results for ${streamName}:`, error);\n        // Clear canvas on error\n        const ctx = canvasOverlay.getContext('2d');\n        ctx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);\n        \n        // Implement backoff strategy on errors\n        errorCount++;\n        if (errorCount > 3) {\n          // After 3 consecutive errors, slow down polling to avoid overwhelming the server\n          clearInterval(intervalId);\n          currentInterval = Math.min(5000, currentInterval * 2); // Max 5 seconds\n          console.log(`Reducing detection polling frequency to ${currentInterval}ms due to errors`);\n          \n          detectionIntervals[streamName] = setInterval(arguments.callee, currentInterval);\n        }\n      });\n  }, currentInterval);\n  \n  // Store interval ID for cleanup\n  detectionIntervals[streamName] = intervalId;\n  canvasOverlay.detectionInterval = intervalId;\n  \n  return intervalId;\n}\n\n/**\n * Clean up detection polling\n * @param {string} streamName - Name of the stream\n * @param {Object} detectionIntervals - Reference to stored interval IDs\n */\nexport function cleanupDetectionPolling(streamName, detectionIntervals) {\n  const canvasId = `canvas-${streamName.replace(/\\s+/g, '-')}`;\n  const canvasOverlay = document.getElementById(canvasId);\n  \n  if (canvasOverlay && canvasOverlay.detectionInterval) {\n    clearInterval(canvasOverlay.detectionInterval);\n    delete canvasOverlay.detectionInterval;\n  }\n  \n  if (detectionIntervals[streamName]) {\n    clearInterval(detectionIntervals[streamName]);\n    delete detectionIntervals[streamName];\n  }\n}\n"],"names":["exitFullscreenMode","e","setIsFullscreen","stopPropagation","preventDefault","console","log","livePage","document","getElementById","error","classList","remove","body","style","overflow","exitBtn","querySelector","warn","fullscreenBtn","display","streamName","videoElementId","replace","videoElement","videoCell","closest","fullscreenElement","exitFullscreen","requestFullscreen","catch","err","message","showStatusMessage","detectionIntervals","canvasId","canvasOverlay","detectionInterval","clearInterval","errorCount","currentInterval","intervalId","setInterval","videoWidth","fetch","encodeURIComponent","then","response","ok","Error","status","json","data","detections","canvas","ctx","getContext","width","clientWidth","height","clientHeight","clearRect","length","videoHeight","videoAspect","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","forEach","detection","x","y","strokeStyle","lineWidth","strokeRect","label","Math","round","confidence","font","textWidth","measureText","fillStyle","fillRect","fillText","drawDetectionBoxes","min","arguments","callee","isFullscreen","isCurrentlyInFullscreen","contains","add","createElement","className","innerHTML","exitClickHandler","addEventListener","appendChild"],"mappings":"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"}