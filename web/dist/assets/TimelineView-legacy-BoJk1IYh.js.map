{"version":3,"file":"TimelineView-legacy-BoJk1IYh.js","sources":["../../js/components/preact/timeline/TimelineControls.js","../../js/components/preact/timeline/TimelineRuler.js","../../js/components/preact/timeline/TimelineSegments.js","../../js/components/preact/timeline/TimelineCursor.js","../../js/components/preact/timeline/SpeedControls.js","../../js/components/preact/timeline/TimelinePlayer.js","../../js/components/preact/timeline/TimelineView.js","../../js/components/preact/timeline/TimelinePage.js"],"sourcesContent":["/**\n * LightNVR Timeline Controls Component\n * Handles play/pause and zoom controls for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelineControls component\n * @returns {JSX.Element} TimelineControls component\n */\nexport function TimelineControls() {\n  // Local state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineControls: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineControls: Received state update:', state);\n      console.log('TimelineControls: Is playing:', state.isPlaying);\n      console.log('TimelineControls: Zoom level:', state.zoomLevel);\n      console.log('TimelineControls: Segments count:', state.timelineSegments?.length || 0);\n      \n      setIsPlaying(state.isPlaying);\n      setZoomLevel(state.zoomLevel);\n    });\n    \n    // Log initial state\n    console.log('TimelineControls: Initial timelineState:', timelineState);\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Toggle playback (play/pause)\n  const togglePlayback = () => {\n    if (isPlaying) {\n      pausePlayback();\n    } else {\n      resumePlayback();\n    }\n  };\n\n  // Pause playback\n  const pausePlayback = () => {\n    timelineState.setState({ isPlaying: false });\n    \n    // If there's a video player, pause it\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      videoPlayer.pause();\n    }\n  };\n\n  // Resume playback\n  const resumePlayback = () => {\n    // If no segments, show message and return\n    if (!timelineState.timelineSegments || timelineState.timelineSegments.length === 0) {\n      showStatusMessage('No recordings to play', 'warning');\n      return;\n    }\n    \n    // Find the earliest segment in the timeline\n    let earliestSegmentIndex = 0;\n    let earliestTimestamp = Number.MAX_SAFE_INTEGER;\n    \n    timelineState.timelineSegments.forEach((segment, index) => {\n      if (segment.start_timestamp < earliestTimestamp) {\n        earliestTimestamp = segment.start_timestamp;\n        earliestSegmentIndex = index;\n      }\n    });\n    \n    console.log(`Starting from earliest segment (index ${earliestSegmentIndex})`);\n    \n    // Start playing from the earliest segment\n    timelineState.setState({ \n      currentSegmentIndex: earliestSegmentIndex,\n      currentTime: timelineState.timelineSegments[earliestSegmentIndex].start_timestamp,\n      isPlaying: true,\n      forceReload: true // Force reload to ensure video player updates\n    });\n    \n    // Force load the earliest segment's video\n    const segment = timelineState.timelineSegments[earliestSegmentIndex];\n    const videoPlayer = document.querySelector('#video-player video');\n    \n    if (videoPlayer) {\n      console.log('Loading earliest segment video:', segment);\n      \n      // Pause any current playback\n      videoPlayer.pause();\n      \n      // Clear the source and reload\n      videoPlayer.removeAttribute('src');\n      videoPlayer.load();\n      \n      // Set the new source with a timestamp to prevent caching\n      videoPlayer.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n      \n      // Set the current time and play\n      videoPlayer.onloadedmetadata = () => {\n        videoPlayer.currentTime = 0;\n        videoPlayer.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      };\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index) => {\n    // This function will be implemented in the TimelinePlayer component\n    // Here we just update the state\n    timelineState.setState({ \n      currentSegmentIndex: index,\n      isPlaying: true \n    });\n  };\n\n  // Zoom in on timeline\n  const zoomIn = () => {\n    if (zoomLevel < 8) {\n      const newZoomLevel = zoomLevel * 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed in: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  // Zoom out on timeline\n  const zoomOut = () => {\n    if (zoomLevel > 1) {\n      const newZoomLevel = zoomLevel / 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed out: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  return html`\n    <div class=\"timeline-controls flex justify-between items-center mb-2\">\n      <div class=\"flex items-center\">\n        <button \n          id=\"play-button\" \n          class=\"w-10 h-10 rounded-full bg-green-600 hover:bg-green-700 text-white flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-offset-1 transition-colors shadow-sm mr-2\"\n          onClick=${togglePlayback}\n          title=${isPlaying ? 'Pause' : 'Play from earliest recording'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            ${isPlaying \n              ? html`\n                <!-- Pause icon - two vertical bars -->\n                <rect x=\"6\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n                <rect x=\"14\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n              `\n              : html`\n                <!-- Play icon - triangle -->\n                <path d=\"M8 5.14v14l11-7-11-7z\" fill=\"white\" />\n              `\n            }\n          </svg>\n        </button>\n        <span class=\"text-xs text-gray-600 dark:text-gray-300\">Play from earliest recording</span>\n      </div>\n      \n      <div class=\"flex items-center gap-1\">\n        <span class=\"text-xs text-gray-600 dark:text-gray-300 mr-1\">Zoom:</span>\n        <button \n          id=\"zoom-out-button\" \n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomOut}\n          title=\"Zoom Out (Show more time)\"\n          disabled=${zoomLevel <= 1}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n        <button \n          id=\"zoom-in-button\" \n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomIn}\n          title=\"Zoom In (Show less time)\"\n          disabled=${zoomLevel >= 8}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Ruler Component\n * Displays the time ruler with hour markers\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineRuler component\n * @returns {JSX.Element} TimelineRuler component\n */\nexport function TimelineRuler() {\n  // Local state\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineRuler: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineRuler: Received state update:', state);\n      console.log('TimelineRuler: Zoom level:', state.zoomLevel);\n      \n      // Calculate time range based on zoom level\n      const hoursPerView = 24 / state.zoomLevel;\n      console.log('TimelineRuler: Hours per view:', hoursPerView);\n      \n      // Calculate the center hour based on current time or segments\n      let centerHour = 12; // Default to noon\n      \n      if (state.currentTime !== null) {\n        // If we have a current time, use it as the center\n        const currentDate = new Date(state.currentTime * 1000);\n        centerHour = currentDate.getHours() + (currentDate.getMinutes() / 60) + (currentDate.getSeconds() / 3600);\n      } else if (state.timelineSegments && state.timelineSegments.length > 0) {\n        // If we have segments but no current time, use the middle of the segments\n        let earliestHour = 24;\n        let latestHour = 0;\n        \n        state.timelineSegments.forEach(segment => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n          \n          const startHour = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n          const endHour = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n          \n          earliestHour = Math.min(earliestHour, startHour);\n          latestHour = Math.max(latestHour, endHour);\n        });\n        \n        centerHour = (earliestHour + latestHour) / 2;\n      }\n      \n      // Calculate start and end hours based on center and zoom level\n      let newStartHour = Math.max(0, centerHour - (hoursPerView / 2));\n      let newEndHour = Math.min(24, newStartHour + hoursPerView);\n      \n      // Adjust start hour if end hour is at the limit\n      if (newEndHour === 24 && hoursPerView < 24) {\n        newStartHour = Math.max(0, 24 - hoursPerView);\n        newEndHour = 24;\n      } else if (newStartHour === 0 && hoursPerView < 24) {\n        newEndHour = Math.min(24, hoursPerView);\n      }\n      \n      console.log('TimelineRuler: New hour range:', { newStartHour, newEndHour });\n      \n      // Update local state\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setZoomLevel(state.zoomLevel);\n      \n      // Only update global state if the values have actually changed\n      // to prevent infinite recursion\n      if (timelineState.timelineStartHour !== newStartHour || \n          timelineState.timelineEndHour !== newEndHour) {\n        timelineState.setState({\n          timelineStartHour: newStartHour,\n          timelineEndHour: newEndHour\n        });\n      }\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Generate hour markers and labels\n  const generateHourMarkers = () => {\n    const markers = [];\n    const hourWidth = 100 / (endHour - startHour);\n    \n    // Add hour markers and labels\n    for (let hour = Math.floor(startHour); hour <= Math.ceil(endHour); hour++) {\n      if (hour >= 0 && hour <= 24) {\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        \n        // Add hour marker\n        markers.push(html`\n          <div \n            key=\"tick-${hour}\" \n            class=\"absolute top-0 w-px h-5 bg-gray-500 dark:bg-gray-400\" \n            style=\"left: ${position}%;\"\n          ></div>\n        `);\n        \n        // Add hour label\n        markers.push(html`\n          <div \n            key=\"label-${hour}\" \n            class=\"absolute top-0 text-xs text-gray-600 dark:text-gray-300 transform -translate-x-1/2\" \n            style=\"left: ${position}%;\"\n          >\n            ${hour}:00\n          </div>\n        `);\n        \n        // Add half-hour marker if not the last hour and we're zoomed in enough\n        if (hour < 24 && zoomLevel >= 2) {\n          const halfHourPosition = ((hour + 0.5 - startHour) / (endHour - startHour)) * 100;\n          markers.push(html`\n            <div \n              key=\"tick-${hour}-30\" \n              class=\"absolute top-2 w-px h-3 bg-gray-400 dark:bg-gray-500\" \n              style=\"left: ${halfHourPosition}%;\"\n            ></div>\n          `);\n          \n          // Add 15-minute markers if zoomed in even more\n          if (zoomLevel >= 4) {\n            const quarterHourPosition1 = ((hour + 0.25 - startHour) / (endHour - startHour)) * 100;\n            const quarterHourPosition3 = ((hour + 0.75 - startHour) / (endHour - startHour)) * 100;\n            \n            markers.push(html`\n              <div \n                key=\"tick-${hour}-15\" \n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\" \n                style=\"left: ${quarterHourPosition1}%;\"\n              ></div>\n            `);\n            \n            markers.push(html`\n              <div \n                key=\"tick-${hour}-45\" \n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\" \n                style=\"left: ${quarterHourPosition3}%;\"\n              ></div>\n            `);\n          }\n        }\n      }\n    }\n    \n    return markers;\n  };\n\n  return html`\n    <div class=\"timeline-ruler relative w-full h-8 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-600\">\n      ${generateHourMarkers()}\n      <div class=\"absolute bottom-0 left-0 text-xs text-gray-500 px-1\">\n        Zoom: ${zoomLevel}x (${Math.round(24 / zoomLevel)} hours)\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Segments Component\n * Displays recording segments on the timeline\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineSegments component\n * @returns {JSX.Element} TimelineSegments component\n */\nexport function TimelineSegments() {\n  // Local state\n  const [segments, setSegments] = useState([]);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  \n  // Refs\n  const containerRef = useRef(null);\n  const isDragging = useRef(false);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineSegments: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineSegments: Received state update');\n      \n      // Update segments\n      if (state.timelineSegments) {\n        console.log(`TimelineSegments: Updating segments (${state.timelineSegments.length})`);\n        setSegments(state.timelineSegments);\n      }\n      \n      // Update other state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n      setCurrentSegmentIndex(state.currentSegmentIndex || -1);\n    });\n    \n    // Check if we already have segments in the timelineState\n    if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n      console.log(`TimelineSegments: Initial segments available (${timelineState.timelineSegments.length})`);\n      setSegments(timelineState.timelineSegments);\n      setCurrentSegmentIndex(timelineState.currentSegmentIndex || 0);\n    }\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set up drag handling\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    \n    const handleMouseDown = (e) => {\n      // Only handle clicks on the container itself, not on segments\n      if (e.target === container || e.target.classList.contains('timeline-clickable-area')) {\n        isDragging.current = true;\n        handleTimelineClick(e);\n        \n        // Add event listeners for drag\n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n      }\n    };\n    \n    const handleMouseMove = (e) => {\n      if (!isDragging.current) return;\n      handleTimelineClick(e);\n    };\n    \n    const handleMouseUp = () => {\n      isDragging.current = false;\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n    \n    container.addEventListener('mousedown', handleMouseDown);\n    \n    return () => {\n      container.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [startHour, endHour, segments]);\n\n  // Handle click on timeline for seeking\n  const handleTimelineClick = (event) => {\n    const container = containerRef.current;\n    if (!container) return;\n    \n    // Get click position relative to container\n    const rect = container.getBoundingClientRect();\n    const clickX = event.clientX - rect.left;\n    const containerWidth = rect.width;\n    \n    // Calculate time based on click position\n    const clickPercent = clickX / containerWidth;\n    const clickHour = startHour + (clickPercent * (endHour - startHour));\n    \n    // Find the segment that contains this time\n    const clickDate = new Date(timelineState.selectedDate);\n    clickDate.setHours(Math.floor(clickHour));\n    clickDate.setMinutes(Math.floor((clickHour % 1) * 60));\n    clickDate.setSeconds(Math.floor(((clickHour % 1) * 60) % 1 * 60));\n    \n    const clickTimestamp = clickDate.getTime() / 1000;\n    \n    // Find segment that contains this timestamp\n    let foundSegment = false;\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n      \n      if (clickTimestamp >= startTimestamp && clickTimestamp <= endTimestamp) {\n        console.log(`TimelineSegments: Found segment ${i} containing timestamp`);\n        \n        // Calculate relative time within the segment\n        const relativeTime = clickTimestamp - startTimestamp;\n        \n        // Update current segment index\n        setCurrentSegmentIndex(i);\n        \n        // Play this segment starting at the clicked time\n        playSegment(i, relativeTime);\n        foundSegment = true;\n        break;\n      }\n    }\n    \n    if (!foundSegment) {\n      if (segments.length > 0) {\n        console.log('TimelineSegments: No segment contains the timestamp, finding closest segment');\n        // Find the closest segment\n        let closestSegment = -1;\n        let minDistance = Infinity;\n        \n        for (let i = 0; i < segments.length; i++) {\n          const segment = segments[i];\n          // Use local timestamps if available, otherwise fall back to regular timestamps\n          const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n          const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n          \n          const startDistance = Math.abs(startTimestamp - clickTimestamp);\n          const endDistance = Math.abs(endTimestamp - clickTimestamp);\n          const distance = Math.min(startDistance, endDistance);\n          \n          if (distance < minDistance) {\n            minDistance = distance;\n            closestSegment = i;\n          }\n        }\n        \n        if (closestSegment >= 0) {\n          console.log(`TimelineSegments: Playing closest segment ${closestSegment}`);\n          \n          // Play the closest segment\n          playSegment(closestSegment);\n        }\n      } else {\n        // No segments found, just update the currentTime\n        console.log('TimelineSegments: No segments found, just updating currentTime');\n        timelineState.setState({ \n          currentTime: clickTimestamp,\n          prevCurrentTime: timelineState.currentTime\n        });\n      }\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index, relativeTime = null) => {\n    console.log(`TimelineSegments: playSegment(${index}, ${relativeTime})`);\n    \n    if (index < 0 || index >= segments.length) {\n      console.warn(`TimelineSegments: Invalid segment index: ${index}`);\n      return;\n    }\n    \n    const segment = segments[index];\n    \n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n    \n    // Calculate absolute timestamp for currentTime\n    const absoluteTime = relativeTime !== null \n      ? startTimestamp + relativeTime \n      : startTimestamp;\n    \n    // First, pause any current playback and reset the segment index\n    timelineState.setState({ \n      isPlaying: false,\n      currentSegmentIndex: -1\n    });\n    \n    // Force a synchronous DOM update\n    document.body.offsetHeight;\n    \n    // Now set the new segment index and start playing\n    setTimeout(() => {\n      timelineState.setState({ \n        currentSegmentIndex: index,\n        currentTime: absoluteTime,\n        isPlaying: true,\n        forceReload: true\n      });\n      \n      // Force the video player to reload\n      setTimeout(() => {\n        const videoElement = document.querySelector('#video-player video');\n        if (videoElement) {\n          // Pause any current playback\n          videoElement.pause();\n          \n          // Clear the source and reload\n          videoElement.removeAttribute('src');\n          videoElement.load();\n          \n          // Set the new source\n          videoElement.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n          \n          // Set the current time and play\n          videoElement.onloadedmetadata = () => {\n            const seekTime = relativeTime !== null ? relativeTime : 0;\n            videoElement.currentTime = seekTime;\n            videoElement.play().catch(e => console.error('Error playing video:', e));\n          };\n        }\n      }, 50);\n    }, 50);\n  };\n\n  // Render segments\n  const renderSegments = () => {\n    console.log(`TimelineSegments: Rendering ${segments.length} segments`);\n    \n    if (!segments || segments.length === 0) {\n      return null;\n    }\n    \n    const visibleSegments = [];\n    const hourMap = new Map();\n    \n    // First pass: collect all segments by hour\n    segments.forEach((segment, index) => {\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n      \n      // Convert timestamps to Date objects\n      const startTime = new Date(startTimestamp * 1000);\n      const endTime = new Date(endTimestamp * 1000);\n      \n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n      \n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n      \n      // Mark each hour that this segment spans\n      const startFloorHour = Math.floor(startHourFloat);\n      const endCeilHour = Math.min(Math.ceil(endHourFloat), 24);\n      \n      for (let h = startFloorHour; h < endCeilHour; h++) {\n        if (h >= startHour && h <= endHour) {\n          if (!hourMap.has(h)) {\n            hourMap.set(h, []);\n          }\n          hourMap.get(h).push(index);\n        }\n      }\n    });\n    \n    // Preprocess segments to merge adjacent ones\n    const mergedSegments = [];\n    let currentMergedSegment = null;\n    \n    // Sort segments by start time (using local timestamps if available)\n    const sortedSegments = [...segments].sort((a, b) => {\n      const aStart = a.local_start_timestamp || a.start_timestamp;\n      const bStart = b.local_start_timestamp || b.start_timestamp;\n      return aStart - bStart;\n    });\n    \n    // Merge adjacent segments (no gap or very small gap)\n    sortedSegments.forEach((segment, index) => {\n      if (!currentMergedSegment) {\n        // First segment\n        currentMergedSegment = { ...segment, originalIndices: [index] };\n      } else {\n        // Check if this segment is adjacent to the current merged segment\n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const segmentStart = segment.local_start_timestamp || segment.start_timestamp;\n        const mergedEnd = currentMergedSegment.local_end_timestamp || currentMergedSegment.end_timestamp;\n        \n        // Allow a small gap (1 second) to account for rounding errors\n        const gap = segmentStart - mergedEnd;\n        \n        if (gap <= 1) {\n          // Merge with current segment\n          // Update both regular and local timestamps\n          currentMergedSegment.end_timestamp = segment.end_timestamp;\n          if (segment.local_end_timestamp) {\n            currentMergedSegment.local_end_timestamp = segment.local_end_timestamp;\n          }\n          currentMergedSegment.originalIndices.push(index);\n          \n          // If this segment has detection, mark the merged segment as having detection\n          if (segment.has_detection) {\n            currentMergedSegment.has_detection = true;\n          }\n        } else {\n          // Gap is too large, start a new merged segment\n          mergedSegments.push(currentMergedSegment);\n          currentMergedSegment = { ...segment, originalIndices: [index] };\n        }\n      }\n    });\n    \n    // Add the last merged segment\n    if (currentMergedSegment) {\n      mergedSegments.push(currentMergedSegment);\n    }\n    \n    console.log(`TimelineSegments: Merged ${segments.length} segments into ${mergedSegments.length} segments`);\n    \n    // Second pass: add visible segments\n    mergedSegments.forEach((segment, mergedIndex) => {\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const segStartTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const segEndTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n      \n      // Convert timestamps to Date objects\n      const startTime = new Date(segStartTimestamp * 1000);\n      const endTime = new Date(segEndTimestamp * 1000);\n      \n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n      \n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n      \n      // Adjust start and end to fit within visible range\n      const visibleStartHour = Math.max(startHourFloat, startHour);\n      const visibleEndHour = Math.min(endHourFloat, endHour);\n      \n      // Calculate position and width as percentages\n      const startPercent = ((visibleStartHour - startHour) / (endHour - startHour)) * 100;\n      const widthPercent = ((visibleEndHour - visibleStartHour) / (endHour - startHour)) * 100;\n      \n      // Format duration for tooltip\n      const duration = Math.round(segEndTimestamp - segStartTimestamp);\n      const durationStr = `${duration}s`;\n      \n      // Format times for tooltip\n      const startTimeStr = startTime.toLocaleTimeString();\n      const endTimeStr = endTime.toLocaleTimeString();\n      \n      // Use a consistent height for all segments\n      const heightPercent = 80; // 80% height for all segments\n      \n      visibleSegments.push(html`\n        <div \n          key=\"segment-${mergedIndex}\"\n          class=\"timeline-segment absolute rounded-sm transition-all duration-200 ${segment.has_detection ? 'bg-red-500' : 'bg-blue-500'}\"\n          style=\"left: ${startPercent}%; width: ${widthPercent}%; height: ${heightPercent}%; top: 50%; transform: translateY(-50%);\"\n          title=\"${startTimeStr} - ${endTimeStr} (${durationStr})\"\n        ></div>\n      `);\n    });\n    \n    // Third pass: fill in gaps with clickable areas\n    for (let hour = Math.floor(startHour); hour < Math.ceil(endHour); hour++) {\n      if (!hourMap.has(hour)) {\n        // No segments in this hour, create a clickable area\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        const width = 100 / (endHour - startHour);\n        \n        visibleSegments.push(html`\n          <div \n            key=\"clickable-${hour}\"\n            class=\"timeline-clickable-area absolute h-full cursor-pointer\"\n            style=\"left: ${position}%; width: ${width}%;\"\n            data-hour=${hour}\n          ></div>\n        `);\n      }\n    }\n    \n    return visibleSegments;\n  };\n\n  return html`\n    <div \n      class=\"timeline-segments relative w-full h-16 pt-2\"\n      ref=${containerRef}\n    >\n      ${renderSegments()}\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Cursor Component\n * Displays the playback cursor on the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineCursor component\n * @returns {JSX.Element} TimelineCursor component\n */\nexport function TimelineCursor() {\n  // Local state\n  const [position, setPosition] = useState(0);\n  const [visible, setVisible] = useState(false);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentTime, setCurrentTime] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n  \n  // Refs\n  const cursorRef = useRef(null);\n  const containerRef = useRef(null);\n  const dragStartXRef = useRef(0);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n      setCurrentTime(state.currentTime);\n      \n      // Update time display\n      updateTimeDisplay(state.currentTime);\n      \n      // Update cursor position (only if not dragging)\n      if (!isDragging) {\n        updateCursorPosition(state.currentTime, state.timelineStartHour || 0, state.timelineEndHour || 24);\n      }\n    });\n    \n    return () => unsubscribe();\n  }, [isDragging]);\n\n  // Set up drag handling\n  useEffect(() => {\n    const cursor = cursorRef.current;\n    if (!cursor) return;\n    \n    const handleMouseDown = (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      // Store the starting X position\n      dragStartXRef.current = e.clientX;\n      \n      setIsDragging(true);\n      \n      // Add event listeners for drag\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    };\n    \n    const handleMouseMove = (e) => {\n      if (!isDragging) return;\n      \n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n      \n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n      \n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      setPosition(positionPercent);\n      \n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      \n      // Convert hour to timestamp\n      const date = new Date(timelineState.selectedDate);\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      \n      const timestamp = date.getTime() / 1000;\n      \n      // Update time display\n      updateTimeDisplay(timestamp);\n    };\n    \n    const handleMouseUp = (e) => {\n      if (!isDragging) return;\n      \n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n      \n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n      \n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      \n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      \n      // Convert hour to timestamp\n      const date = new Date(timelineState.selectedDate);\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      \n      const timestamp = date.getTime() / 1000;\n      \n      // Reset dragging state FIRST\n      setIsDragging(false);\n      \n      // Remove event listeners\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      \n      // Find segment that contains this timestamp\n      const segments = timelineState.timelineSegments || [];\n      let foundSegment = false;\n      \n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n        const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n        \n        if (timestamp >= startTimestamp && timestamp <= endTimestamp) {\n          // Calculate relative time within the segment\n          const relativeTime = timestamp - startTimestamp;\n          \n          // Update timeline state\n          timelineState.setState({ \n            currentSegmentIndex: i,\n            currentTime: timestamp,\n            prevCurrentTime: timelineState.currentTime,\n            isPlaying: true\n          });\n          \n          foundSegment = true;\n          break;\n        }\n      }\n      \n      // If no segment found, find the closest one\n      if (!foundSegment && segments.length > 0) {\n        let closestSegment = 0;\n        let minDistance = Infinity;\n        \n        for (let i = 0; i < segments.length; i++) {\n          const segment = segments[i];\n          // Use local timestamps if available, otherwise fall back to regular timestamps\n          const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n          const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n          \n          const startDistance = Math.abs(startTimestamp - timestamp);\n          const endDistance = Math.abs(endTimestamp - timestamp);\n          const distance = Math.min(startDistance, endDistance);\n          \n          if (distance < minDistance) {\n            minDistance = distance;\n            closestSegment = i;\n          }\n        }\n        \n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const closestSegmentObj = segments[closestSegment];\n        const startTimestamp = closestSegmentObj.local_start_timestamp || closestSegmentObj.start_timestamp;\n        \n        // Update timeline state\n        timelineState.setState({ \n          currentSegmentIndex: closestSegment,\n          currentTime: startTimestamp,\n          prevCurrentTime: timelineState.currentTime,\n          isPlaying: true\n        });\n      }\n    };\n    \n    // Add event listeners\n    cursor.addEventListener('mousedown', handleMouseDown);\n    \n    return () => {\n      cursor.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [cursorRef.current, startHour, endHour, isDragging]);\n\n  // Update cursor position\n  const updateCursorPosition = (time, startHr, endHr) => {\n    if (time === null) {\n      setVisible(false);\n      return;\n    }\n    \n    // Calculate cursor position\n    const date = new Date(time * 1000);\n    const hour = date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n    \n    // Check if the current time is within the visible range\n    if (hour < startHr || hour > endHr) {\n      setVisible(false);\n      return;\n    }\n    \n    // Calculate position as percentage\n    const position = ((hour - startHr) / (endHr - startHr)) * 100;\n    \n    // Update cursor position\n    setPosition(position);\n    setVisible(true);\n  };\n\n  // Update time display\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  // Force the cursor to be visible on initial render\n  useEffect(() => {\n    // Set visible to true after a short delay\n    setTimeout(() => {\n      if (timelineState.currentTime) {\n        setVisible(true);\n        updateCursorPosition(\n          timelineState.currentTime, \n          timelineState.timelineStartHour || 0, \n          timelineState.timelineEndHour || 24\n        );\n      }\n    }, 500);\n  }, []);\n\n  return html`\n    <div \n      ref=${cursorRef}\n      class=\"timeline-cursor absolute top-0 h-full z-50 transition-all duration-100 cursor-ew-resize\"\n      style=\"left: ${position}%; display: ${visible ? 'block' : 'none'}; pointer-events: auto; width: 7px; margin-left: -3.5px;\"\n    >\n      <!-- Invisible wider clickable area -->\n      <div class=\"absolute top-0 bottom-0 left-0 w-full\"></div>\n      \n      <!-- Skinnier needle with no middle chunk -->\n      <div class=\"absolute top-0 bottom-0 w-0.5 bg-orange-500 left-1/2 transform -translate-x-1/2 pointer-events-none\"></div>\n      \n      <!-- Top handle (black) -->\n      <div class=\"absolute top-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 -translate-y-1/2 shadow-md pointer-events-none\"></div>\n      \n      <!-- Bottom handle (black) -->\n      <div class=\"absolute bottom-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 translate-y-1/2 shadow-md pointer-events-none\"></div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Speed Controls Component\n * Handles playback speed controls for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * SpeedControls component\n * @returns {JSX.Element} SpeedControls component\n */\nexport function SpeedControls() {\n  // Local state\n  const [currentSpeed, setCurrentSpeed] = useState(1.0);\n  \n  // Available speeds\n  const speeds = [0.25, 0.5, 1.0, 1.5, 2.0, 4.0];\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('SpeedControls: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('SpeedControls: Received state update:', state);\n      console.log('SpeedControls: Playback speed:', state.playbackSpeed);\n      \n      setCurrentSpeed(state.playbackSpeed);\n    });\n    \n    // Log initial state\n    console.log('SpeedControls: Initial timelineState:', timelineState);\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set playback speed\n  const setPlaybackSpeed = (speed) => {\n    // Update video playback rate\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      // Store the current playback rate for debugging\n      const oldRate = videoPlayer.playbackRate;\n      \n      // Set the new playback rate\n      videoPlayer.playbackRate = speed;\n      \n      console.log(`Setting video playback rate from ${oldRate}x to ${speed}x`, videoPlayer);\n      console.log(`Actual playback rate after setting: ${videoPlayer.playbackRate}x`);\n      \n      // Force the playback rate again after a short delay\n      setTimeout(() => {\n        videoPlayer.playbackRate = speed;\n        console.log(`Re-setting playback rate to ${speed}x, actual rate: ${videoPlayer.playbackRate}x`);\n      }, 100);\n    } else {\n      console.warn('Video player element not found');\n    }\n    \n    // Update timeline state\n    timelineState.setState({ playbackSpeed: speed });\n    \n    // Show status message\n    showStatusMessage(`Playback speed: ${speed}x`, 'info');\n  };\n\n  return html`\n    <div class=\"mt-2 mb-4 p-2 border border-green-500 rounded-lg bg-white dark:bg-gray-800 shadow-sm\">\n      <div class=\"flex flex-col items-center\">\n        <div class=\"text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300\">Playback Speed</div>\n        \n        <div class=\"flex flex-wrap justify-center gap-1\">\n          ${speeds.map(speed => html`\n            <button \n              key=${`speed-${speed}`}\n              class=${`speed-btn px-2 py-1 text-sm rounded-full ${speed === currentSpeed \n                ? 'bg-green-500 text-white' \n                : 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600'} \n                font-medium transition-all focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-opacity-50`}\n              data-speed=${speed}\n              onClick=${() => setPlaybackSpeed(speed)}\n            >\n              ${speed === 1.0 ? '1× (Normal)' : `${speed}×`}\n            </button>\n          `)}\n        </div>\n        \n        <div class=\"mt-1 text-xs font-medium text-green-600 dark:text-green-400\">\n          Current: ${currentSpeed}× ${currentSpeed === 1.0 ? '(Normal)' : ''}\n        </div>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Player Component\n * Handles video playback for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelinePlayer component\n * @returns {JSX.Element} TimelinePlayer component\n */\nexport function TimelinePlayer() {\n  // Local state\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [segments, setSegments] = useState([]);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n\n  // Refs\n  const videoRef = useRef(null);\n  const lastTimeUpdateRef = useRef(null);\n  const lastSegmentIdRef = useRef(null);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setCurrentSegmentIndex(state.currentSegmentIndex);\n      setIsPlaying(state.isPlaying);\n      setSegments(state.timelineSegments || []);\n      setPlaybackSpeed(state.playbackSpeed);\n\n      // Handle video playback\n      handleVideoPlayback(state);\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Handle video playback based on state changes\n  const handleVideoPlayback = (state) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have valid segments and segment index\n    if (!state.timelineSegments || \n        state.timelineSegments.length === 0 || \n        state.currentSegmentIndex < 0 || \n        state.currentSegmentIndex >= state.timelineSegments.length) {\n      return;\n    }\n    \n    // Get current segment\n    const segment = state.timelineSegments[state.currentSegmentIndex];\n    if (!segment) return;\n    \n    // Check if we need to load a new segment\n    const segmentChanged = lastSegmentIdRef.current !== segment.id;\n    \n    // IMPORTANT: Only reload if the segment has actually changed\n    // This prevents constant reloading\n    const needsReload = segmentChanged;\n    \n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n    \n    // Calculate relative time within the segment\n    const relativeTime = state.currentTime !== null && \n                         state.currentTime >= startTimestamp\n      ? state.currentTime - startTimestamp\n      : 0;\n    \n    // Only update the video if:\n    // 1. We need to load a new segment, OR\n    // 2. The user is dragging the cursor (indicated by a significant time change)\n    const timeChanged = state.prevCurrentTime !== null && \n                        Math.abs(state.currentTime - state.prevCurrentTime) > 1;\n    \n    // Update last segment ID\n    if (segmentChanged) {\n      console.log(`Segment changed from ${lastSegmentIdRef.current} to ${segment.id}`);\n      lastSegmentIdRef.current = segment.id;\n    }\n    \n    // Handle playback\n    if (needsReload) {\n      // Load new segment\n      console.log(`Loading new segment ${segment.id} (segmentChanged: ${segmentChanged})`);\n      loadSegment(segment, relativeTime, state.isPlaying);\n    } else if (timeChanged) {\n      // User is dragging the cursor, just update the current time\n      console.log(`Seeking to ${relativeTime}s within current segment`);\n      video.currentTime = relativeTime;\n    } else if (state.isPlaying && video.paused) {\n      // Resume playback if needed\n      video.play().catch(error => {\n        console.error('Error playing video:', error);\n      });\n    } else if (!state.isPlaying && !video.paused) {\n      // Pause playback if needed\n      video.pause();\n    }\n    \n    // Update playback speed if needed\n    if (video.playbackRate !== state.playbackSpeed) {\n      video.playbackRate = state.playbackSpeed;\n    }\n  };\n\n  // Load a segment\n  const loadSegment = (segment, seekTime = 0, autoplay = false) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    console.log(`Loading segment ${segment.id} at time ${seekTime}s, autoplay: ${autoplay}`);\n    \n    // Pause current playback\n    video.pause();\n    \n    // Set new source with timestamp to prevent caching\n    const recordingUrl = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n    \n    // Set up event listeners for the new video\n    const onLoadedMetadata = () => {\n      console.log('Video metadata loaded');\n      \n      // Set current time\n      video.currentTime = seekTime;\n      \n      // Set playback speed\n      video.playbackRate = playbackSpeed;\n      \n      // Play if needed\n      if (autoplay) {\n        video.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      }\n      \n      // Remove event listener\n      video.removeEventListener('loadedmetadata', onLoadedMetadata);\n    };\n    \n    // Add event listener for metadata loaded\n    video.addEventListener('loadedmetadata', onLoadedMetadata);\n    \n    // Set new source\n    video.src = recordingUrl;\n    video.load();\n  };\n\n  // Handle video ended event\n  const handleEnded = () => {\n    console.log('Video ended');\n    \n    // Check if we have a next segment\n    if (currentSegmentIndex < segments.length - 1) {\n      // Play next segment\n      const nextIndex = currentSegmentIndex + 1;\n      console.log(`Playing next segment ${nextIndex}`);\n      \n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const nextSegment = segments[nextIndex];\n      const startTimestamp = nextSegment.local_start_timestamp || nextSegment.start_timestamp;\n      \n      // Update timeline state\n      timelineState.setState({\n        currentSegmentIndex: nextIndex,\n        currentTime: startTimestamp,\n        isPlaying: true,\n        forceReload: true\n      });\n    } else {\n      // End of all segments\n      console.log('End of all segments');\n      \n      // Update timeline state\n      timelineState.setState({\n        isPlaying: false\n      });\n    }\n  };\n\n  // Handle video time update event\n  const handleTimeUpdate = () => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have a valid segment\n    if (currentSegmentIndex < 0 || \n        !segments || \n        segments.length === 0 || \n        currentSegmentIndex >= segments.length) {\n      return;\n    }\n    \n    const segment = segments[currentSegmentIndex];\n    if (!segment) return;\n    \n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n    \n    // Calculate current timestamp\n    const currentTime = startTimestamp + video.currentTime;\n    \n    // Directly update the time display as well\n    updateTimeDisplay(currentTime);\n    \n    // Update timeline state with the current time\n    timelineState.setState({\n      currentTime: currentTime,\n      prevCurrentTime: lastTimeUpdateRef.current\n    });\n    \n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n  };\n\n  // Add a direct time display update function\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  return html`\n    <div class=\"timeline-player-container mb-2\" id=\"video-player\">\n      <div class=\"relative w-full bg-black rounded-lg shadow-md\" style=\"aspect-ratio: 16/9;\">\n        <video\n            ref=${videoRef}\n            class=\"w-full h-full object-contain\"\n            controls\n            autoplay=${false}\n            muted=${false}\n            playsInline\n            onended=${handleEnded}\n            ontimeupdate=${handleTimeUpdate}\n        ></video>\n        \n        <!-- Add a message for invalid segments -->\n        <div \n          class=\"absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-center p-4 ${currentSegmentIndex >= 0 && segments.length > 0 ? 'hidden' : ''}\"\n        >\n          <div>\n            <p class=\"mb-2\">No valid segment selected.</p>\n            <p class=\"text-sm\">Click on a segment in the timeline or use the play button to start playback.</p>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Playback speed controls -->\n    <${SpeedControls} />\n  `;\n}\n","/**\n * LightNVR Timeline View Component\n * Loads the Timeline page component into the main content area\n */\n\nimport { render } from 'preact';\nimport { html } from '../../../html-helper.js';\nimport { TimelinePage } from './TimelinePage.js';\nimport { QueryClientProvider, queryClient } from '../../../query-client.js';\n\n/**\n * Load TimelineView component\n */\nexport function loadTimelineView() {\n  const mainContent = document.getElementById('main-content');\n  if (!mainContent) return;\n\n  // Clear any existing content\n  mainContent.innerHTML = '';\n\n  // Render the TimelinePage component to the container wrapped with QueryClientProvider\n  render(\n    html`<${QueryClientProvider} client=${queryClient}>\n      <${TimelinePage} />\n    <//>`,\n    mainContent\n  );\n}","/**\n * LightNVR Timeline Page Component\n * Main component for the timeline view\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { TimelineControls } from './TimelineControls.js';\nimport { TimelineRuler } from './TimelineRuler.js';\nimport { TimelineSegments } from './TimelineSegments.js';\nimport { TimelineCursor } from './TimelineCursor.js';\nimport { TimelinePlayer } from './TimelinePlayer.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\nimport { LoadingIndicator } from '../LoadingIndicator.js';\nimport { useQuery } from '../../../query-client.js';\n\n// Global timeline state for child components\nconst timelineState = {\n  streams: [],\n  timelineSegments: [],\n  selectedStream: null,\n  selectedDate: null,\n  isPlaying: false,\n  currentSegmentIndex: -1,\n  zoomLevel: 1, // 1 = 1 hour, 2 = 30 minutes, 4 = 15 minutes\n  timelineStartHour: 0,\n  timelineEndHour: 24,\n  currentTime: null,\n  prevCurrentTime: null,\n  playbackSpeed: 1.0,\n  showOnlySegments: true,\n  forceReload: false,\n  listeners: new Set(),\n\n  // Update state and notify listeners\n  setState(newState) {\n    Object.assign(this, newState);\n    this.notifyListeners();\n  },\n\n  // Subscribe to state changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  },\n\n  // Notify all listeners of state change\n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this));\n  }\n};\n\n/**\n * Format date for input element\n */\nfunction formatDateForInput(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/**\n * Parse URL parameters\n */\nfunction parseUrlParams() {\n  const params = new URLSearchParams(window.location.search);\n  return {\n    stream: params.get('stream') || '',\n    date: params.get('date') || formatDateForInput(new Date())\n  };\n}\n\n/**\n * Update URL parameters\n */\nfunction updateUrlParams(stream, date) {\n  if (!stream) return;\n  const url = new URL(window.location.href);\n  url.searchParams.set('stream', stream);\n  url.searchParams.set('date', date);\n  window.history.replaceState({}, '', url);\n}\n\n/**\n * TimelinePage component\n */\nexport function TimelinePage() {\n  // Get initial values from URL parameters\n  const urlParams = parseUrlParams();\n\n  // State\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamsList, setStreamsList] = useState([]);\n  const [selectedStream, setSelectedStream] = useState(urlParams.stream);\n  const [selectedDate, setSelectedDate] = useState(urlParams.date);\n  const [segments, setSegments] = useState([]);\n\n  // Refs\n  const timelineContainerRef = useRef(null);\n  const initialLoadRef = useRef(false);\n\n  // Load streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery('streams', '/api/streams', {\n    timeout: 15000, // 15 second timeout\n    retries: 2,     // Retry twice\n    retryDelay: 1000 // 1 second between retries\n  });\n\n  // Handle initial data load when streams are available\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData) && streamsData.length > 0 && !initialLoadRef.current) {\n      console.log('TimelinePage: Streams loaded, initializing data');\n      initialLoadRef.current = true;\n\n      // Update streamsList state\n      setStreamsList(streamsData);\n\n      // Update global state for child components\n      timelineState.setState({ streams: streamsData });\n\n      // Check if the selected stream from URL exists\n      const streamExists = streamsData.some(s => s.name === selectedStream);\n\n      if (streamExists && selectedStream) {\n        console.log(`TimelinePage: Using stream from URL: ${selectedStream}`);\n      } else if (streamsData.length > 0) {\n        // Use first stream if URL stream doesn't exist\n        const firstStream = streamsData[0].name;\n        console.log(`TimelinePage: Using first stream: ${firstStream}`);\n        setSelectedStream(firstStream);\n      }\n    }\n  }, [streamsData]);\n\n  // Handle streams error\n  useEffect(() => {\n    if (streamsError) {\n      console.error('TimelinePage: Error loading streams:', streamsError);\n      showStatusMessage('Error loading streams: ' + streamsError.message, 'error');\n    }\n  }, [streamsError]);\n\n  // Calculate time range for timeline data\n  const getTimeRange = (date) => {\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n\n    const endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n\n    return {\n      startTime: startDate.toISOString(),\n      endTime: endDate.toISOString()\n    };\n  };\n\n  // Update URL and global state when stream or date changes\n  useEffect(() => {\n    if (selectedStream) {\n      // Update URL\n      updateUrlParams(selectedStream, selectedDate);\n\n      // Update global state\n      timelineState.setState({\n        selectedStream,\n        selectedDate\n      });\n    }\n  }, [selectedStream, selectedDate]);\n\n  // Get time range for current date\n  const { startTime, endTime } = getTimeRange(selectedDate);\n\n  // Fetch timeline segments using preact-query\n  const {\n    data: timelineData,\n    isLoading: isLoadingTimeline,\n    error: timelineError,\n    refetch: refetchTimeline\n  } = useQuery(\n    ['timeline-segments', selectedStream, selectedDate],\n    selectedStream ? `/api/timeline/segments?stream=${encodeURIComponent(selectedStream)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}` : null,\n    {\n      timeout: 30000, // 30 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    },\n    {\n      enabled: !!selectedStream, // Only run query if we have a selected stream\n      onSuccess: (data) => {\n        console.log('TimelinePage: Timeline data received:', data);\n        const timelineSegments = data.segments || [];\n        console.log(`TimelinePage: Received ${timelineSegments.length} segments`);\n\n        if (timelineSegments.length === 0) {\n          console.log('TimelinePage: No segments found');\n          setSegments([]);\n\n          // Update global state\n          timelineState.setState({\n            timelineSegments: [],\n            currentSegmentIndex: -1,\n            currentTime: null,\n            isPlaying: false\n          });\n\n          showStatusMessage('No recordings found for the selected date', 'warning');\n          return;\n        }\n\n        console.log('TimelinePage: Setting segments');\n        setSegments(timelineSegments);\n\n        // Update global state with the first segment selected\n        const initialTime = timelineSegments[0].start_timestamp;\n        timelineState.setState({\n          timelineSegments,\n          currentSegmentIndex: 0,\n          currentTime: initialTime,\n          prevCurrentTime: initialTime,\n          isPlaying: false\n        });\n\n        // Preload the first segment's video\n        const videoPlayer = document.querySelector('#video-player video');\n        if (videoPlayer) {\n          videoPlayer.src = `/api/recordings/play/${timelineSegments[0].id}`;\n          videoPlayer.load();\n        }\n\n        showStatusMessage(`Loaded ${timelineSegments.length} recording segments`, 'success');\n      },\n      onError: (error) => {\n        console.error('TimelinePage: Error loading timeline data:', error);\n        showStatusMessage('Error loading timeline data: ' + error.message, 'error');\n        setSegments([]);\n      }\n    }\n  );\n\n  // Handle stream selection change\n  const handleStreamChange = (e) => {\n    const newStream = e.target.value;\n    console.log(`TimelinePage: Stream changed to ${newStream}`);\n    setSelectedStream(newStream);\n  };\n\n  // Handle date selection change\n  const handleDateChange = (e) => {\n    const newDate = e.target.value;\n    console.log(`TimelinePage: Date changed to ${newDate}`);\n    setSelectedDate(newDate);\n  };\n\n  // Render content based on state\n  const renderContent = () => {\n    if (isLoadingTimeline) {\n      return html`<${LoadingIndicator} message=\"Loading timeline data...\" />`;\n    }\n\n    if (segments.length === 0) {\n      return html`\n        <div class=\"flex flex-col items-center justify-center py-12 text-center\">\n          <svg class=\"w-16 h-16 text-gray-400 dark:text-gray-600 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path>\n          </svg>\n          <p class=\"text-gray-600 dark:text-gray-400 text-lg\">No recordings found for the selected date and stream</p>\n        </div>\n      `;\n    }\n\n    return html`\n      <!-- Video player -->\n      <${TimelinePlayer} />\n\n      <!-- Playback controls -->\n      <${TimelineControls} />\n\n        <!-- Timeline -->\n        <div\n            id=\"timeline-container\"\n            class=\"relative w-full h-24 bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg mb-6 overflow-hidden\"\n            ref=${timelineContainerRef}\n        >\n          <${TimelineRuler} />\n          <${TimelineSegments} />\n          <${TimelineCursor} />\n\n          <!-- Instructions for cursor -->\n          <div class=\"absolute bottom-1 right-2 text-xs text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 px-2 py-1 rounded\">\n            Drag the orange dial to navigate\n          </div>\n        </div>\n    `;\n  };\n\n  return html`\n    <div class=\"timeline-page\">\n      <div class=\"flex items-center mb-4\">\n        <h1 class=\"text-2xl font-bold\">Timeline Playback</h1>\n        <div class=\"ml-4 flex\">\n          <a href=\"recordings.html\" class=\"px-3 py-1 bg-gray-300 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-l-md\">Table View</a>\n          <a href=\"timeline.html\" class=\"px-3 py-1 bg-blue-500 text-white rounded-r-md\">Timeline View</a>\n        </div>\n      </div>\n\n      <!-- Stream selector and date picker -->\n      <div class=\"flex flex-wrap gap-4 mb-2\">\n        <div class=\"stream-selector flex-grow\">\n          <div class=\"flex justify-between items-center mb-2\">\n            <label for=\"stream-selector\">Stream</label>\n            <button\n              class=\"text-xs bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 px-2 py-1 rounded\"\n              onClick=${() => refetchTimeline()}\n            >\n              Reload Data\n            </button>\n          </div>\n          <select\n              id=\"stream-selector\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedStream || ''}\n              onChange=${handleStreamChange}\n          >\n            <option value=\"\" disabled>Select a stream (${streamsList.length} available)</option>\n            ${streamsList.map(stream => html`\n              <option key=${stream.name} value=${stream.name}>${stream.name}</option>\n            `)}\n          </select>\n        </div>\n\n        <div class=\"date-selector flex-grow\">\n          <label for=\"timeline-date\" class=\"block mb-2\">Date</label>\n          <input\n              type=\"date\"\n              id=\"timeline-date\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedDate}\n              onChange=${handleDateChange}\n          />\n        </div>\n      </div>\n\n      <!-- Auto-load message -->\n      <div class=\"mb-4 text-sm text-gray-500 dark:text-gray-400 italic\">\n        ${isLoadingTimeline ? 'Loading...' : 'Recordings auto-load when stream or date changes'}\n      </div>\n\n      <!-- Current time display -->\n      <div class=\"flex justify-between items-center mb-2\">\n        <div id=\"time-display\" class=\"timeline-time-display bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded font-mono text-base\">00:00:00</div>\n      </div>\n\n      <!-- Debug info -->\n      <div class=\"mb-2 text-xs text-gray-500\">\n        Debug - isLoading: ${isLoadingTimeline ? 'true' : 'false'},\n        Streams: ${streamsList.length},\n        Segments: ${segments.length}\n      </div>\n\n      <!-- Content -->\n      ${renderContent()}\n\n      <!-- Instructions -->\n      <div class=\"mt-6 p-4 bg-gray-200 dark:bg-gray-800 rounded\">\n        <h3 class=\"text-lg font-semibold mb-2\">How to use the timeline:</h3>\n        <ul class=\"list-disc pl-5\">\n          <li>Select a stream and date to load recordings</li>\n          <li>Click on the timeline to seek to a specific time</li>\n          <li>Click on a segment (blue bar) to play that recording</li>\n          <li>Use the play/pause button to control playback</li>\n          <li>Use the zoom buttons to adjust the timeline scale</li>\n        </ul>\n      </div>\n    </div>\n  `;\n}\n\n// Export the timeline state for use in other components\nexport { timelineState };\n"],"names":["TimelineControls","isPlaying","setIsPlaying","useState","zoomLevel","setZoomLevel","useEffect","console","log","unsubscribe","timelineState","subscribe","state","timelineSegments","length","pausePlayback","setState","videoPlayer","document","querySelector","pause","resumePlayback","showStatusMessage","earliestSegmentIndex","earliestTimestamp","Number","MAX_SAFE_INTEGER","forEach","segment","index","start_timestamp","currentSegmentIndex","currentTime","forceReload","removeAttribute","load","src","id","Date","now","onloadedmetadata","play","catch","error","message","html","togglePlayback","zoomOut","newZoomLevel","zoomIn","TimelineRuler","startHour","setStartHour","endHour","setEndHour","hoursPerView","centerHour","currentDate","getHours","getMinutes","getSeconds","earliestHour","latestHour","startTime","endTime","end_timestamp","Math","min","max","newStartHour","newEndHour","timelineStartHour","timelineEndHour","generateHourMarkers","markers","hour","floor","ceil","position","push","halfHourPosition","quarterHourPosition1","quarterHourPosition3","round","TimelineSegments","segments","setSegments","setCurrentSegmentIndex","containerRef","useRef","isDragging","container","current","handleMouseDown","e","target","classList","contains","handleTimelineClick","addEventListener","handleMouseMove","handleMouseUp","removeEventListener","event","rect","getBoundingClientRect","clickX","clientX","left","containerWidth","width","clickHour","clickDate","selectedDate","setHours","setMinutes","setSeconds","clickTimestamp","getTime","foundSegment","i","startTimestamp","local_start_timestamp","endTimestamp","local_end_timestamp","relativeTime","playSegment","closestSegment","minDistance","Infinity","startDistance","abs","endDistance","distance","prevCurrentTime","warn","absoluteTime","body","offsetHeight","setTimeout","videoElement","seekTime","renderSegments","visibleSegments","hourMap","Map","startHourFloat","endHourFloat","startFloorHour","endCeilHour","h","has","set","get","mergedSegments","currentMergedSegment","sort","a","b","originalIndices","has_detection","mergedIndex","segStartTimestamp","segEndTimestamp","visibleStartHour","visibleEndHour","startPercent","widthPercent","durationStr","startTimeStr","toLocaleTimeString","endTimeStr","TimelineCursor","setPosition","visible","setVisible","setCurrentTime","setIsDragging","cursorRef","dragStartXRef","updateTimeDisplay","updateCursorPosition","cursor","preventDefault","stopPropagation","parentElement","positionPercent","date","timestamp","closestSegmentObj","time","startHr","endHr","timeDisplay","getElementById","hours","toString","padStart","minutes","seconds","textContent","SpeedControls","currentSpeed","setCurrentSpeed","playbackSpeed","map","speed","oldRate","playbackRate","setPlaybackSpeed","TimelinePlayer","videoRef","lastTimeUpdateRef","lastSegmentIdRef","handleVideoPlayback","video","segmentChanged","needsReload","timeChanged","loadSegment","paused","autoplay","recordingUrl","onLoadedMetadata","handleEnded","nextIndex","nextSegment","handleTimeUpdate","mainContent","innerHTML","render","QueryClientProvider","queryClient","TimelinePage","streams","selectedStream","showOnlySegments","listeners","Set","newState","Object","assign","this","notifyListeners","listener","add","delete","urlParams","params","URLSearchParams","window","location","search","stream","getFullYear","String","getMonth","getDate","parseUrlParams","isLoading","setIsLoading","streamsList","setStreamsList","setSelectedStream","setSelectedDate","timelineContainerRef","initialLoadRef","data","streamsData","isLoadingStreams","streamsError","useQuery","timeout","retries","retryDelay","Array","isArray","some","s","name","firstStream","url","URL","href","searchParams","history","replaceState","updateUrlParams","startDate","endDate","toISOString","getTimeRange","timelineData","isLoadingTimeline","timelineError","refetch","refetchTimeline","encodeURIComponent","enabled","onSuccess","initialTime","onError","newStream","value","newDate","LoadingIndicator"],"mappings":"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"}