{"version":3,"file":"websocket-client-legacy-BO-Yc0A6.js","sources":["../../js/websocket-client.js"],"sourcesContent":["/**\n * WebSocket Client for LightNVR\n * Provides a reusable WebSocket connection with automatic reconnection\n */\n\n/**\n * WebSocket Client class\n */\nexport class WebSocketClient {\n    /**\n     * Generate a UUID v4\n     * @returns {string} A random UUID\n     */\n    static generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Create a new WebSocket client\n     */\n    constructor() {\n        this.socket = null;\n        // We'll get the client ID from the server's welcome message\n        this.clientId = null;\n        this.connected = false;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 5;\n        this.reconnectDelay = 1000; // Start with 1 second delay\n        this.handlers = {};\n        this.subscriptions = new Set();\n        this.pendingSubscriptions = new Set();\n        this.messageQueue = [];\n        this.connecting = false;\n        // Store subscription parameters\n        this.subscriptionParams = new Map();\n        // Store callbacks waiting for client ID\n        this.clientIdCallbacks = [];\n        // Connection change listeners\n        this.connectionChangeListeners = [];\n\n        console.log('WebSocket client initialized, waiting for server-assigned client ID');\n\n        // Bind methods to this instance\n        this.connect = this.connect.bind(this);\n        this.disconnect = this.disconnect.bind(this);\n        this.reconnect = this.reconnect.bind(this);\n        this.send = this.send.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.unsubscribe = this.unsubscribe.bind(this);\n        this.handleMessage = this.handleMessage.bind(this);\n        this.processMessageQueue = this.processMessageQueue.bind(this);\n        this.addConnectionChangeListener = this.addConnectionChangeListener.bind(this);\n        this.removeConnectionChangeListener = this.removeConnectionChangeListener.bind(this);\n        this.notifyConnectionChangeListeners = this.notifyConnectionChangeListeners.bind(this);\n\n        // Connect automatically\n        this.connect();\n    }\n\n    /**\n     * Connect to the WebSocket server\n     */\n    connect() {\n        if (this.socket && (this.socket.readyState === WebSocket.OPEN || this.socket.readyState === WebSocket.CONNECTING)) {\n            console.log('WebSocket already connected or connecting');\n            return;\n        }\n\n        if (this.connecting) {\n            console.log('WebSocket connection already in progress');\n            return;\n        }\n\n        this.connecting = true;\n\n        // Determine WebSocket URL based on current page protocol\n        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n        const wsUrl = `${protocol}//${window.location.host}/api/ws`;\n\n        console.log(`Connecting to WebSocket server at ${wsUrl}`);\n\n        // Check if WebSocket is supported\n        if (typeof WebSocket === 'undefined') {\n            console.error('WebSocket not supported by this browser or environment');\n            this.connecting = false;\n            this.fallbackToHttp();\n            return;\n        }\n\n        try {\n            // Create WebSocket with a timeout to handle stalled connections\n            const connectTimeout = setTimeout(() => {\n                console.error('WebSocket connection timeout');\n                if (this.socket && this.socket.readyState !== WebSocket.OPEN) {\n                    this.socket.close();\n                    this.socket = null;\n                    this.connecting = false;\n                    this.fallbackToHttp();\n                }\n            }, 10000); // 10 second timeout\n\n            this.socket = new WebSocket(wsUrl);\n\n            this.socket.onopen = () => {\n                clearTimeout(connectTimeout);\n                console.log('WebSocket connection established');\n                this.connected = true;\n                this.connecting = false;\n                this.reconnectAttempts = 0;\n                this.reconnectDelay = 1000;\n\n                // Notify connection change listeners\n                this.notifyConnectionChangeListeners(true);\n\n                // Set a smaller buffer size for better compatibility with older systems\n                if (this.socket.bufferedAmount !== undefined) {\n                    console.log(`Initial WebSocket buffered amount: ${this.socket.bufferedAmount}`);\n                }\n\n                // Wait for welcome message with client ID before processing subscriptions\n                // The server will send a welcome message with the client ID\n                console.log('WebSocket connected, waiting for welcome message with client ID');\n\n                // If we already have a client ID (from a previous connection), we can process\n                // pending subscriptions and messages immediately\n                if (this.clientId) {\n                    console.log(`Using existing client ID: ${this.clientId}`);\n                    // Resubscribe to topics\n                    this.pendingSubscriptions = new Set([...this.subscriptions]);\n                    this.subscriptions.clear();\n                    this.processPendingSubscriptions();\n\n                    // Process any queued messages\n                    this.processMessageQueue();\n                }\n            };\n\n            this.socket.onmessage = (event) => {\n                try {\n                    this.handleMessage(event.data);\n                } catch (error) {\n                    console.error('Error handling WebSocket message:', error);\n                }\n            };\n\n            this.socket.onclose = (event) => {\n                clearTimeout(connectTimeout);\n                console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n                this.connected = false;\n                this.connecting = false;\n\n                // Notify connection change listeners\n                this.notifyConnectionChangeListeners(false);\n\n                // Check for specific close codes that indicate compatibility issues\n                if (event.code === 1006) {\n                    console.warn('WebSocket closed abnormally (code 1006), possible compatibility issue');\n\n                    // If we've tried multiple times and keep getting 1006, fall back to HTTP\n                    if (this.reconnectAttempts >= 3) {\n                        console.warn('Multiple abnormal closures, falling back to HTTP');\n                        this.fallbackToHttp();\n                        return;\n                    }\n                }\n\n                // Attempt to reconnect if not a normal closure\n                if (event.code !== 1000) {\n                    this.reconnect();\n                }\n            };\n\n            this.socket.onerror = (error) => {\n                console.error('WebSocket error:', error);\n                this.connecting = false;\n\n                // If we were connected, notify listeners that we're disconnected\n                if (this.connected) {\n                    this.connected = false;\n                    this.notifyConnectionChangeListeners(false);\n                }\n\n                // On error, increment reconnect attempts\n                this.reconnectAttempts++;\n\n                // If we've had multiple errors, fall back to HTTP\n                if (this.reconnectAttempts >= 3) {\n                    console.warn('Multiple WebSocket errors, falling back to HTTP');\n                    this.fallbackToHttp();\n                }\n            };\n        } catch (error) {\n            console.error('Error creating WebSocket:', error);\n            this.connecting = false;\n            this.reconnect();\n        }\n    }\n\n    /**\n     * Fall back to HTTP for operations\n     * This sets a flag that other components can check to use HTTP instead of WebSocket\n     */\n    fallbackToHttp() {\n        console.warn('Falling back to HTTP for operations');\n        this.usingHttpFallback = true;\n\n        // Make sure connected is set to false\n        if (this.connected) {\n            this.connected = false;\n            // Notify connection change listeners\n            this.notifyConnectionChangeListeners(false);\n        }\n\n        // Dispatch an event that components can listen for\n        const fallbackEvent = new CustomEvent('websocket-fallback', {\n            detail: { usingHttp: true }\n        });\n        window.dispatchEvent(fallbackEvent);\n\n        // Try to notify any waiting operations\n        if (this.pendingSubscriptions.size > 0) {\n            console.log(`Notifying ${this.pendingSubscriptions.size} pending subscriptions about HTTP fallback`);\n        }\n    }\n\n    /**\n     * Disconnect from the WebSocket server\n     */\n    disconnect() {\n        if (this.socket) {\n            this.socket.close(1000, 'Client disconnected');\n            this.socket = null;\n        }\n\n        this.connected = false;\n        this.connecting = false;\n        // Keep the client ID if we have one, so we can reuse it on reconnect\n        this.subscriptions.clear();\n        this.pendingSubscriptions.clear();\n        this.subscriptionParams.clear();\n        this.messageQueue = [];\n    }\n\n    /**\n     * Reconnect to the WebSocket server with exponential backoff\n     */\n    reconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            console.log('Maximum reconnect attempts reached');\n            return;\n        }\n\n        this.reconnectAttempts++;\n        const delay = Math.min(30000, this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1));\n\n        console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n\n        setTimeout(() => {\n            this.connect();\n        }, delay);\n    }\n\n    /**\n     * Send a message to the WebSocket server\n     *\n     * @param {string} type Message type\n     * @param {string} topic Message topic\n     * @param {Object} payload Message payload\n     * @returns {boolean} Whether the message was sent\n     */\n    send(type, topic, payload) {\n        if (!this.connected) {\n            console.log('WebSocket not connected, queueing message');\n            this.messageQueue.push({ type, topic, payload });\n            this.connect();\n            return false;\n        }\n\n        const message = {\n            type,\n            topic,\n            payload\n        };\n\n        try {\n            // Log the message being sent for debugging\n            console.log('Sending WebSocket message:', JSON.stringify(message));\n\n            this.socket.send(JSON.stringify(message));\n            return true;\n        } catch (error) {\n            console.error('Error sending WebSocket message:', error);\n            this.messageQueue.push({ type, topic, payload });\n            return false;\n        }\n    }\n\n    /**\n     * Process the message queue\n     */\n    processMessageQueue() {\n        if (!this.connected || this.messageQueue.length === 0) {\n            return;\n        }\n\n        console.log(`Processing ${this.messageQueue.length} queued messages`);\n\n        const queue = [...this.messageQueue];\n        this.messageQueue = [];\n\n        for (const message of queue) {\n            this.send(message.type, message.topic, message.payload);\n        }\n    }\n\n    /**\n     * Process pending subscriptions\n     */\n    processPendingSubscriptions() {\n        if (!this.connected || this.pendingSubscriptions.size === 0) {\n            return;\n        }\n\n        console.log(`Processing ${this.pendingSubscriptions.size} pending subscriptions`);\n\n        for (const topic of this.pendingSubscriptions) {\n            // Get parameters for this topic if available\n            const params = this.subscriptionParams.get(topic) || {};\n            this.subscribe(topic, params);\n        }\n\n        this.pendingSubscriptions.clear();\n    }\n\n    /**\n     * Subscribe to a topic\n     *\n     * @param {string} topic Topic to subscribe to\n     * @param {Object} params Additional parameters to include in the subscription\n     * @returns {boolean} Whether the subscription request was sent\n     */\n    subscribe(topic, params = {}) {\n        if (!this.connected) {\n            console.log(`WebSocket not connected, queueing subscription to ${topic}`);\n            this.pendingSubscriptions.add(topic);\n            this.connect();\n            return false;\n        }\n\n        if (this.subscriptions.has(topic)) {\n            console.log(`Already subscribed to ${topic}, updating parameters`);\n            // Continue with the subscription to update parameters\n        }\n\n        console.log(`Subscribing to ${topic} with params:`, params);\n\n        // Store parameters for this topic\n        this.subscriptionParams.set(topic, params);\n\n        // Include client_id in the payload to ensure server knows who's subscribing\n        const payload = {\n            client_id: this.clientId,\n            ...params\n        };\n\n        const success = this.send('subscribe', topic, payload);\n        if (success) {\n            this.subscriptions.add(topic);\n        } else {\n            this.pendingSubscriptions.add(topic);\n        }\n\n        return success;\n    }\n\n    /**\n     * Unsubscribe from a topic\n     *\n     * @param {string} topic Topic to unsubscribe from\n     * @returns {boolean} Whether the unsubscription request was sent\n     */\n    unsubscribe(topic) {\n        if (!this.connected) {\n            console.log(`WebSocket not connected, cannot unsubscribe from ${topic}`);\n            this.pendingSubscriptions.delete(topic);\n            return false;\n        }\n\n        if (!this.subscriptions.has(topic)) {\n            console.log(`Not subscribed to ${topic}`);\n            return true;\n        }\n\n        console.log(`Unsubscribing from ${topic}`);\n\n        const success = this.send('unsubscribe', topic, {});\n        if (success) {\n            this.subscriptions.delete(topic);\n            // Remove stored parameters for this topic\n            this.subscriptionParams.delete(topic);\n        }\n\n        return success;\n    }\n\n    /**\n     * Handle an incoming WebSocket message\n     *\n     * @param {string} data Message data\n     */\n    handleMessage(data) {\n        console.log('Raw WebSocket message received:', data);\n\n        try {\n            const message = JSON.parse(data);\n\n            if (!message.type || !message.topic) {\n                console.error('Invalid WebSocket message format:', message);\n                return;\n            }\n\n            console.log(`Received WebSocket message: ${message.type} ${message.topic}`, message);\n\n            // Debug log for progress and result messages\n            if (message.type === 'progress' || message.type === 'result') {\n                console.log(`Received ${message.type} message for topic ${message.topic}:`, message.payload);\n            }\n\n            // Always try to parse payload if it's a string (could be JSON)\n            if (typeof message.payload === 'string') {\n                try {\n                    const parsedPayload = JSON.parse(message.payload);\n                    console.log(`Parsed payload for ${message.type}:${message.topic}:`, parsedPayload);\n                    // Replace the string payload with the parsed object\n                    message.payload = parsedPayload;\n                } catch (e) {\n                    // Not JSON, keep as string\n                    console.log(`Payload for ${message.type}:${message.topic} is not JSON, keeping as string`);\n                }\n            }\n\n            // Handle welcome message\n            if (message.type === 'welcome' && message.topic === 'system') {\n                console.log('Received welcome message:', message);\n\n                // The payload might be a string that needs to be parsed\n                let payload = message.payload;\n                console.log('Welcome payload type:', typeof payload);\n\n                // If payload is a string, try to parse it as JSON\n                if (typeof payload === 'string') {\n                    try {\n                        payload = JSON.parse(payload);\n                        console.log('Parsed welcome payload:', payload);\n                    } catch (e) {\n                        console.error('Error parsing welcome payload as JSON:', e);\n                        console.log('Raw payload string:', payload);\n                    }\n                }\n\n                if (!payload || !payload.client_id) {\n                    console.error('Welcome message missing client_id:', payload);\n                } else {\n                    // Extract client ID from payload\n                    this.clientId = payload.client_id;\n                    console.log(`WebSocket client ID received from server: ${this.clientId}`);\n\n                    // Process pending subscriptions\n                    this.pendingSubscriptions = new Set([...this.subscriptions]);\n                    this.subscriptions.clear();\n                    this.processPendingSubscriptions();\n\n                    // Process any queued messages\n                    this.processMessageQueue();\n\n                    // Notify any waiting operations\n                    console.log(`Notifying ${this.clientIdCallbacks.length} waiting operations about client ID`);\n\n                    // Call all callbacks waiting for client ID\n                    const callbacks = [...this.clientIdCallbacks];\n                    this.clientIdCallbacks = [];\n                    for (const callback of callbacks) {\n                        try {\n                            callback(this.clientId);\n                        } catch (error) {\n                            console.error('Error in client ID callback:', error);\n                        }\n                    }\n                }\n                return;\n            }\n\n            // Handle other messages\n            const key = `${message.type}:${message.topic}`;\n            const handlers = this.handlers[key] || [];\n\n            for (const handler of handlers) {\n                try {\n                    handler(message.payload);\n                } catch (error) {\n                    console.error(`Error in WebSocket message handler for ${key}:`, error);\n                }\n            }\n        } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n        }\n    }\n\n    /**\n     * Register a message handler\n     *\n     * @param {string} type Message type\n     * @param {string} topic Message topic\n     * @param {Function} handler Message handler\n     */\n    on(type, topic, handler) {\n        const key = `${type}:${topic}`;\n\n        if (!this.handlers[key]) {\n            this.handlers[key] = [];\n        }\n\n        this.handlers[key].push(handler);\n\n        // Subscribe to topic if not already subscribed\n        if (type !== 'welcome' && type !== 'ack' && type !== 'error') {\n            this.subscribe(topic);\n        }\n    }\n\n    /**\n     * Unregister a message handler\n     *\n     * @param {string} type Message type\n     * @param {string} topic Message topic\n     * @param {Function} handler Message handler\n     */\n    off(type, topic, handler) {\n        const key = `${type}:${topic}`;\n\n        if (!this.handlers[key]) {\n            return;\n        }\n\n        if (handler) {\n            this.handlers[key] = this.handlers[key].filter(h => h !== handler);\n        } else {\n            this.handlers[key] = [];\n        }\n\n        // Unsubscribe from topic if no more handlers\n        if (this.handlers[key].length === 0 && type !== 'welcome' && type !== 'ack' && type !== 'error') {\n            this.unsubscribe(topic);\n        }\n    }\n\n    /**\n     * Get the client ID\n     *\n     * @param {Function} callback Optional callback to call when client ID is available\n     * @returns {string|null} Client ID or null if not connected\n     */\n    getClientId(callback) {\n        if (this.clientId) {\n            // If we already have a client ID, return it immediately\n            if (callback) {\n                callback(this.clientId);\n            }\n            return this.clientId;\n        } else if (callback) {\n            // If we don't have a client ID yet, add the callback to the queue\n            console.log('Client ID not available yet, adding callback to queue');\n            this.clientIdCallbacks.push(callback);\n\n            // Make sure we're connected to get a client ID\n            if (!this.connected && !this.connecting) {\n                console.log('Not connected, connecting now to get client ID');\n                this.connect();\n            }\n            return null;\n        }\n        return null;\n    }\n\n    /**\n     * Add a connection change listener\n     *\n     * @param {Function} listener Function to call when connection state changes\n     */\n    addConnectionChangeListener(listener) {\n        if (typeof listener !== 'function') {\n            console.error('Connection change listener must be a function');\n            return;\n        }\n\n        // Add listener if it doesn't already exist\n        if (!this.connectionChangeListeners.includes(listener)) {\n            this.connectionChangeListeners.push(listener);\n            console.log('Added connection change listener');\n\n            // Call the listener immediately with the current connection state\n            try {\n                listener(this.connected);\n            } catch (error) {\n                console.error('Error in connection change listener:', error);\n            }\n        }\n    }\n\n    /**\n     * Remove a connection change listener\n     *\n     * @param {Function} listener Function to remove\n     */\n    removeConnectionChangeListener(listener) {\n        const index = this.connectionChangeListeners.indexOf(listener);\n        if (index !== -1) {\n            this.connectionChangeListeners.splice(index, 1);\n            console.log('Removed connection change listener');\n        }\n    }\n\n    /**\n     * Notify all connection change listeners\n     *\n     * @param {boolean} connected Whether the connection is established\n     */\n    notifyConnectionChangeListeners(connected) {\n        console.log(`Notifying ${this.connectionChangeListeners.length} connection change listeners: connected=${connected}`);\n\n        for (const listener of this.connectionChangeListeners) {\n            try {\n                listener(connected);\n            } catch (error) {\n                console.error('Error in connection change listener:', error);\n            }\n        }\n    }\n\n    /**\n     * Check if connected to the WebSocket server\n     *\n     * @returns {boolean} Whether connected to the WebSocket server\n     */\n    isConnected() {\n        return this.connected;\n    }\n}\n\n/**\n * BatchDeleteRecordingsClient class\n * Handles batch delete recordings operations via WebSocket\n */\nexport class BatchDeleteRecordingsClient {\n    /**\n     * Create a new BatchDeleteRecordingsClient\n     *\n     * @param {WebSocketClient} wsClient WebSocket client\n     */\n    constructor(wsClient) {\n        this.wsClient = wsClient;\n        this.topic = 'recordings/batch-delete';\n        this.progressHandlers = [];\n        this.resultHandlers = [];\n        this.errorHandlers = [];\n        this._httpFallbackTimeout = null; // Store timeout ID for HTTP fallback\n\n        // Subscribe to topic\n        this.wsClient.subscribe(this.topic);\n\n        // Register handlers\n        this.wsClient.on('progress', this.topic, (payload) => {\n            this.handleProgress(payload);\n        });\n\n        this.wsClient.on('result', this.topic, (payload) => {\n            this.handleResult(payload);\n        });\n\n        this.wsClient.on('error', this.topic, (payload) => {\n            this.handleError(payload);\n        });\n    }\n\n    /**\n     * Delete recordings with progress updates\n     *\n     * @param {Object} params Delete parameters (ids or filter)\n     * @returns {Promise<Object>} Promise that resolves when the operation is complete\n     */\n    deleteWithProgress(params) {\n        return new Promise((resolve, reject) => {\n            console.log('Starting batch delete operation with params:', params);\n\n            // Check if WebSocket is connected\n            if (!this.wsClient.isConnected()) {\n                console.error('WebSocket not connected, attempting to connect');\n                this.wsClient.connect();\n\n                // Wait for connection and retry\n                setTimeout(() => {\n                    if (this.wsClient.isConnected()) {\n                        console.log('WebSocket connected, retrying batch delete');\n                        this.deleteWithProgress(params)\n                            .then(resolve)\n                            .catch(reject);\n                    } else {\n                        console.error('WebSocket still not connected, falling back to HTTP');\n                        // Fallback to HTTP if available\n                        if (typeof batchDeleteRecordingsByHttpRequest === 'function') {\n                            batchDeleteRecordingsByHttpRequest(params)\n                                .then(resolve)\n                                .catch(reject);\n                        } else {\n                            reject(new Error('WebSocket not connected and HTTP fallback not available'));\n                        }\n                    }\n                }, 1000);\n                return;\n            }\n\n            // Get client ID from the WebSocket client\n            // This will either return the client ID immediately or call our callback when it's available\n            const getClientIdAndProceed = (clientId) => {\n                console.log('Using WebSocket client ID for batch delete:', clientId);\n\n                console.log('Registering WebSocket handlers for batch delete');\n\n    // Register one-time result handler\n    const resultHandler = (payload) => {\n        console.log('Batch delete result received:', payload);\n        this.wsClient.off('result', this.topic, resultHandler);\n\n        // Log the full payload details for debugging\n        console.log('Batch delete result details:', JSON.stringify(payload, null, 2));\n\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received a result');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        resolve(payload);\n    };\n\n    // Register one-time error handler\n    const errorHandler = (payload) => {\n        console.error('Batch delete error received:', payload);\n        this.wsClient.off('error', this.topic, errorHandler);\n\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received an error');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        reject(new Error(payload.error || 'Unknown error'));\n    };\n\n                // Register handlers for both result and progress\n                this.wsClient.on('result', this.topic, resultHandler);\n                this.wsClient.on('error', this.topic, errorHandler);\n\n                // Make sure we're subscribed to the topic\n                // Use an empty object as payload to avoid issues\n                if (!this.wsClient.subscriptions.has(this.topic)) {\n                    console.log(`Subscribing to ${this.topic} before sending request`);\n\n                    // Create a subscription message with client_id\n                    const subscribePayload = { client_id: clientId };\n                    console.log(`Subscription payload:`, subscribePayload);\n\n                    // Send subscription directly to ensure it works\n                    if (this.wsClient.socket && this.wsClient.socket.readyState === WebSocket.OPEN) {\n                        const subscribeMsg = {\n                            type: 'subscribe',\n                            topic: this.topic,\n                            payload: subscribePayload\n                        };\n                        this.wsClient.socket.send(JSON.stringify(subscribeMsg));\n                        console.log('Subscription sent directly via socket');\n                    } else {\n                        this.wsClient.send('subscribe', this.topic, subscribePayload);\n                    }\n\n                    this.wsClient.subscriptions.add(this.topic);\n\n                    // Add a longer delay to ensure subscription is processed\n                    setTimeout(() => {\n                        // Send the actual delete request with client ID\n                        this.sendDeleteRequest(params, clientId, resolve, reject, resultHandler, errorHandler);\n                    }, 1000);\n                } else {\n                    console.log(`Already subscribed to ${this.topic}, sending request immediately`);\n                    // Already subscribed, send request immediately\n                    this.sendDeleteRequest(params, clientId, resolve, reject, resultHandler, errorHandler);\n                }\n            };\n\n            // Get the client ID, which will either return it immediately or call our callback when available\n            const clientId = this.wsClient.getClientId(getClientIdAndProceed);\n            if (clientId) {\n                // If we got the client ID immediately, proceed with the operation\n                getClientIdAndProceed(clientId);\n            }\n        });\n    }\n\n    /**\n     * Send the actual delete request\n     *\n     * @param {Object} params Delete parameters\n     * @param {string} clientId Client ID\n     * @param {Function} resolve Promise resolve function\n     * @param {Function} reject Promise reject function\n     * @param {Function} resultHandler Result handler to unregister on failure\n     * @param {Function} errorHandler Error handler to unregister on failure\n     */\n    sendDeleteRequest(params, clientId, resolve, reject, resultHandler, errorHandler) {\n        console.log('Sending batch delete request');\n\n        // Validate params\n        if (!params.ids && !params.filter) {\n            console.error('Missing ids or filter in batch delete params');\n            this.wsClient.off('result', this.topic, resultHandler);\n            this.wsClient.off('error', this.topic, errorHandler);\n            reject(new Error('Missing ids or filter in batch delete params'));\n            return;\n        }\n\n        // Log the IDs if present for debugging\n        if (params.ids) {\n            console.log(`Deleting ${params.ids.length} recordings with IDs:`, params.ids);\n        } else if (params.filter) {\n            console.log('Deleting recordings with filter:', params.filter);\n        }\n\n        // Validate client ID - it should be a pointer value from the server\n        if (!clientId || !clientId.startsWith('0x')) {\n            console.error(`Invalid client ID format: ${clientId}. Expected a pointer value like 0x12345678`);\n            this.wsClient.off('result', this.topic, resultHandler);\n            this.wsClient.off('error', this.topic, errorHandler);\n            reject(new Error('Invalid client ID format. Please try again.'));\n            return;\n        }\n\n        // Include the client ID in the request payload\n        const requestParams = {\n            ...params,\n            client_id: clientId // Add client ID to the request\n        };\n\n        // Log the full request details for debugging\n        console.log('Full request params:', JSON.stringify(requestParams, null, 2));\n\n        // Create the complete message\n        const message = {\n            type: 'request',\n            topic: this.topic,\n            payload: requestParams\n        };\n\n        // Log the complete message\n        console.log('Complete WebSocket message:', JSON.stringify(message, null, 2));\n\n        // Debug the client ID format\n        console.log('Client ID format check:', {\n            clientId,\n            startsWithHex: clientId.startsWith('0x'),\n            length: clientId.length,\n            isValid: clientId.startsWith('0x') && clientId.length > 2\n        });\n\n        // If we have a total count from the filter, simulate an initial progress update\n        // This helps the UI show progress even if the server doesn't send updates\n        if (params.filter && params.totalCount && typeof window.updateBatchDeleteProgress === 'function') {\n            console.log('Simulating initial progress update with total count:', params.totalCount);\n            window.updateBatchDeleteProgress({\n                current: 0,\n                total: params.totalCount,\n                succeeded: 0,\n                failed: 0,\n                status: `Starting batch delete operation for ${params.totalCount} recordings...`,\n                complete: false\n            });\n        } else if (params.ids && typeof window.updateBatchDeleteProgress === 'function') {\n            // Also simulate initial progress for IDs-based delete\n            console.log('Simulating initial progress update with IDs count:', params.ids.length);\n            window.updateBatchDeleteProgress({\n                current: 0,\n                total: params.ids.length,\n                succeeded: 0,\n                failed: 0,\n                status: `Starting batch delete operation for ${params.ids.length} recordings...`,\n                complete: false\n            });\n        }\n\n        // Send the request\n        try {\n            if (this.wsClient.socket && this.wsClient.socket.readyState === WebSocket.OPEN) {\n                // Double check the client ID is included in the payload\n                if (!message.payload.client_id || message.payload.client_id !== clientId) {\n                    console.warn('Client ID missing or incorrect in payload, fixing it');\n                    message.payload.client_id = clientId;\n                }\n\n                // Send directly to ensure it works\n                this.wsClient.socket.send(JSON.stringify(message));\n                console.log('Batch delete request sent successfully via direct socket send');\n\n                // Set a longer timeout to check if we get a response\n                // Some operations might take longer to start processing\n                this._httpFallbackTimeout = setTimeout(() => {\n                    // If we haven't received a response after 30 seconds, try HTTP fallback\n                    console.warn('No response received after 30 seconds, trying HTTP fallback');\n                    this._httpFallbackTimeout = null;\n                    if (typeof batchDeleteRecordingsByHttpRequest === 'function') {\n                        console.log('Falling back to HTTP for batch delete');\n                        batchDeleteRecordingsByHttpRequest(params)\n                            .then(resolve)\n                            .catch(reject);\n                    }\n                }, 30000); // Increased from 10000 to 30000 ms to allow more time for server processing\n\n                return true;\n            } else {\n                // Fall back to the send method\n                const success = this.wsClient.send('request', this.topic, requestParams);\n\n                if (!success) {\n                    console.error('Failed to send batch delete request');\n                    this.wsClient.off('result', this.topic, resultHandler);\n                    this.wsClient.off('error', this.topic, errorHandler);\n\n                    // Try HTTP fallback\n                    if (typeof batchDeleteRecordingsByHttpRequest === 'function') {\n                        console.log('Falling back to HTTP for batch delete');\n                        batchDeleteRecordingsByHttpRequest(params)\n                            .then(resolve)\n                            .catch(reject);\n                    } else {\n                        reject(new Error('Failed to send batch delete request'));\n                    }\n                } else {\n                    console.log('Batch delete request sent successfully via send method');\n                }\n\n                return success;\n            }\n        } catch (error) {\n            console.error('Error sending batch delete request:', error);\n            this.wsClient.off('result', this.topic, resultHandler);\n            this.wsClient.off('error', this.topic, errorHandler);\n            reject(error);\n            return false;\n        }\n    }\n\n    /**\n     * Handle progress update\n     *\n     * @param {Object} payload Progress payload\n     */\n    handleProgress(payload) {\n        console.log('Batch delete progress update received:', payload);\n\n        // Ensure payload is an object\n        let progressData = payload;\n\n        // If payload is still a string (wasn't parsed in handleMessage), try to parse it here\n        if (typeof payload === 'string') {\n            try {\n                progressData = JSON.parse(payload);\n                console.log('Parsed progress payload:', progressData);\n            } catch (e) {\n                console.error('Error parsing progress payload:', e);\n                // Keep original payload if parsing fails\n                progressData = { error: 'Failed to parse progress data' };\n            }\n        }\n\n        // If we received a progress update, we know the WebSocket connection is working\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received a progress update');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        // Directly update the progress UI with the progress data\n        // This ensures the progress bar is updated even if the registered handlers don't work\n        if (typeof window.updateBatchDeleteProgress === 'function' && progressData) {\n            try {\n                console.log('Directly updating progress UI with:', progressData);\n                window.updateBatchDeleteProgress(progressData);\n            } catch (error) {\n                console.error('Error directly updating progress UI:', error);\n            }\n        }\n\n        // Call all registered progress handlers with the progress data\n        for (const handler of this.progressHandlers) {\n            try {\n                handler(progressData);\n            } catch (error) {\n                console.error('Error in progress handler:', error);\n            }\n        }\n    }\n\n    /**\n     * Handle result\n     *\n     * @param {Object} payload Result payload\n     */\n    handleResult(payload) {\n        console.log('Batch delete result received:', payload);\n\n        // If we received a result, we know the WebSocket connection is working\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received a result');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        // Ensure payload is an object\n        let resultData = payload;\n\n        // If payload is still a string (wasn't parsed in handleMessage), try to parse it here\n        if (typeof payload === 'string') {\n            try {\n                resultData = JSON.parse(payload);\n                console.log('Parsed result payload:', resultData);\n            } catch (e) {\n                console.error('Error parsing result payload:', e);\n                // Keep original payload if parsing fails\n                resultData = { error: 'Failed to parse result data' };\n            }\n        }\n\n        // Also update the progress UI with the final result data\n        // This ensures the progress bar shows 100% even if no progress updates were received\n        if (typeof window.updateBatchDeleteProgress === 'function' && resultData) {\n            try {\n                // Create a progress update from the result data\n                const progressUpdate = {\n                    current: resultData.total || 0,\n                    total: resultData.total || 0,\n                    succeeded: resultData.succeeded || 0,\n                    failed: resultData.failed || 0,\n                    status: 'Batch delete operation complete',\n                    complete: true\n                };\n\n                console.log('Updating progress UI with final result:', progressUpdate);\n                window.updateBatchDeleteProgress(progressUpdate);\n            } catch (error) {\n                console.error('Error updating progress UI from result:', error);\n            }\n        }\n\n        // Call all registered result handlers with the result data\n        for (const handler of this.resultHandlers) {\n            try {\n                handler(resultData);\n            } catch (error) {\n                console.error('Error in result handler:', error);\n            }\n        }\n    }\n\n    /**\n     * Handle error\n     *\n     * @param {Object} payload Error payload\n     */\n    handleError(payload) {\n        console.log('Batch delete error received:', payload);\n\n        // If we received an error, we know the WebSocket connection is working\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received an error');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        // Ensure payload is an object\n        let errorData = payload;\n\n        // If payload is still a string (wasn't parsed in handleMessage), try to parse it here\n        if (typeof payload === 'string') {\n            try {\n                errorData = JSON.parse(payload);\n                console.log('Parsed error payload:', errorData);\n            } catch (e) {\n                console.error('Error parsing error payload:', e);\n                // Keep original payload if parsing fails\n                errorData = { error: typeof payload === 'string' ? payload : 'Unknown error' };\n            }\n        }\n\n        // Update the progress UI to show the error\n        if (typeof window.updateBatchDeleteProgress === 'function') {\n            try {\n                // Create a progress update from the error data\n                const progressUpdate = {\n                    current: 0,\n                    total: 0,\n                    succeeded: 0,\n                    failed: 0,\n                    status: `Error: ${errorData.error || 'Unknown error'}`,\n                    complete: true,\n                    error: true\n                };\n\n                console.log('Updating progress UI with error:', progressUpdate);\n                window.updateBatchDeleteProgress(progressUpdate);\n            } catch (error) {\n                console.error('Error updating progress UI from error:', error);\n            }\n        }\n\n        // Call all registered error handlers with the error data\n        for (const handler of this.errorHandlers) {\n            try {\n                handler(errorData);\n            } catch (error) {\n                console.error('Error in error handler:', error);\n            }\n        }\n    }\n\n    /**\n     * Register progress handler\n     *\n     * @param {Function} handler Progress handler\n     * @returns {Function} Function to unregister the handler\n     */\n    onProgress(handler) {\n        this.progressHandlers.push(handler);\n\n        return () => {\n            this.progressHandlers = this.progressHandlers.filter(h => h !== handler);\n        };\n    }\n\n    /**\n     * Register result handler\n     *\n     * @param {Function} handler Result handler\n     * @returns {Function} Function to unregister the handler\n     */\n    onResult(handler) {\n        this.resultHandlers.push(handler);\n\n        return () => {\n            this.resultHandlers = this.resultHandlers.filter(h => h !== handler);\n        };\n    }\n\n    /**\n     * Register error handler\n     *\n     * @param {Function} handler Error handler\n     * @returns {Function} Function to unregister the handler\n     */\n    onError(handler) {\n        this.errorHandlers.push(handler);\n\n        return () => {\n            this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n        };\n    }\n}\n"],"names":["exports","generateUUID","replace","c","r","Math","random","toString","constructor","this","socket","clientId","connected","reconnectAttempts","maxReconnectAttempts","reconnectDelay","handlers","subscriptions","Set","pendingSubscriptions","messageQueue","connecting","subscriptionParams","Map","clientIdCallbacks","connectionChangeListeners","console","log","connect","bind","disconnect","reconnect","send","subscribe","unsubscribe","handleMessage","processMessageQueue","addConnectionChangeListener","removeConnectionChangeListener","notifyConnectionChangeListeners","readyState","WebSocket","OPEN","CONNECTING","wsUrl","window","location","protocol","host","error","fallbackToHttp","connectTimeout","setTimeout","close","onopen","clearTimeout","undefined","bufferedAmount","clear","processPendingSubscriptions","onmessage","event","data","onclose","code","reason","warn","onerror","usingHttpFallback","fallbackEvent","CustomEvent","detail","usingHttp","dispatchEvent","size","delay","min","pow","type","topic","payload","push","message","JSON","stringify","length","queue","params","get","add","has","set","client_id","success","delete","parse","parsedPayload","e","callbacks","callback","key","handler","on","off","filter","h","getClientId","listener","includes","index","indexOf","splice","isConnected","wsClient","progressHandlers","resultHandlers","errorHandlers","_httpFallbackTimeout","handleProgress","handleResult","handleError","deleteWithProgress","Promise","resolve","reject","then","catch","batchDeleteRecordingsByHttpRequest","Error","getClientIdAndProceed","resultHandler","errorHandler","sendDeleteRequest","subscribePayload","subscribeMsg","ids","startsWith","requestParams","startsWithHex","isValid","totalCount","updateBatchDeleteProgress","current","total","succeeded","failed","status","complete","progressData","resultData","progressUpdate","errorData","onProgress","onResult","onError"],"mappings":"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"}