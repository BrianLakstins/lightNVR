{"version":3,"file":"websocket-client-DzZLM-9M.js","sources":["../../js/websocket-client.js"],"sourcesContent":["/**\n * WebSocket Client for LightNVR\n * Provides a reusable WebSocket connection with automatic reconnection\n */\n\n/**\n * WebSocket Client class\n */\nexport class WebSocketClient {\n    /**\n     * Generate a UUID v4\n     * @returns {string} A random UUID\n     */\n    static generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Create a new WebSocket client\n     */\n    constructor() {\n        this.socket = null;\n        // We'll get the client ID from the server's welcome message\n        this.clientId = null;\n        this.connected = false;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 5;\n        this.reconnectDelay = 1000; // Start with 1 second delay\n        this.handlers = {};\n        this.subscriptions = new Set();\n        this.pendingSubscriptions = new Set();\n        this.messageQueue = [];\n        this.connecting = false;\n        // Store subscription parameters\n        this.subscriptionParams = new Map();\n        // Store callbacks waiting for client ID\n        this.clientIdCallbacks = [];\n        // Connection change listeners\n        this.connectionChangeListeners = [];\n\n        console.log('WebSocket client initialized, waiting for server-assigned client ID');\n\n        // Bind methods to this instance\n        this.connect = this.connect.bind(this);\n        this.disconnect = this.disconnect.bind(this);\n        this.reconnect = this.reconnect.bind(this);\n        this.send = this.send.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.unsubscribe = this.unsubscribe.bind(this);\n        this.handleMessage = this.handleMessage.bind(this);\n        this.processMessageQueue = this.processMessageQueue.bind(this);\n        this.addConnectionChangeListener = this.addConnectionChangeListener.bind(this);\n        this.removeConnectionChangeListener = this.removeConnectionChangeListener.bind(this);\n        this.notifyConnectionChangeListeners = this.notifyConnectionChangeListeners.bind(this);\n\n        // Connect automatically\n        this.connect();\n    }\n\n    /**\n     * Connect to the WebSocket server\n     */\n    connect() {\n        if (this.socket && (this.socket.readyState === WebSocket.OPEN || this.socket.readyState === WebSocket.CONNECTING)) {\n            console.log('WebSocket already connected or connecting');\n            return;\n        }\n\n        if (this.connecting) {\n            console.log('WebSocket connection already in progress');\n            return;\n        }\n\n        this.connecting = true;\n\n        // Determine WebSocket URL based on current page protocol\n        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n        const wsUrl = `${protocol}//${window.location.host}/api/ws`;\n\n        console.log(`Connecting to WebSocket server at ${wsUrl}`);\n\n        // Check if WebSocket is supported\n        if (typeof WebSocket === 'undefined') {\n            console.error('WebSocket not supported by this browser or environment');\n            this.connecting = false;\n            this.fallbackToHttp();\n            return;\n        }\n\n        try {\n            // Create WebSocket with a timeout to handle stalled connections\n            const connectTimeout = setTimeout(() => {\n                console.error('WebSocket connection timeout');\n                if (this.socket && this.socket.readyState !== WebSocket.OPEN) {\n                    this.socket.close();\n                    this.socket = null;\n                    this.connecting = false;\n                    this.fallbackToHttp();\n                }\n            }, 10000); // 10 second timeout\n\n            this.socket = new WebSocket(wsUrl);\n\n            this.socket.onopen = () => {\n                clearTimeout(connectTimeout);\n                console.log('WebSocket connection established');\n                this.connected = true;\n                this.connecting = false;\n                this.reconnectAttempts = 0;\n                this.reconnectDelay = 1000;\n\n                // Notify connection change listeners\n                this.notifyConnectionChangeListeners(true);\n\n                // Set a smaller buffer size for better compatibility with older systems\n                if (this.socket.bufferedAmount !== undefined) {\n                    console.log(`Initial WebSocket buffered amount: ${this.socket.bufferedAmount}`);\n                }\n\n                // Wait for welcome message with client ID before processing subscriptions\n                // The server will send a welcome message with the client ID\n                console.log('WebSocket connected, waiting for welcome message with client ID');\n\n                // If we already have a client ID (from a previous connection), we can process\n                // pending subscriptions and messages immediately\n                if (this.clientId) {\n                    console.log(`Using existing client ID: ${this.clientId}`);\n                    // Resubscribe to topics\n                    this.pendingSubscriptions = new Set([...this.subscriptions]);\n                    this.subscriptions.clear();\n                    this.processPendingSubscriptions();\n\n                    // Process any queued messages\n                    this.processMessageQueue();\n                }\n            };\n\n            this.socket.onmessage = (event) => {\n                try {\n                    this.handleMessage(event.data);\n                } catch (error) {\n                    console.error('Error handling WebSocket message:', error);\n                }\n            };\n\n            this.socket.onclose = (event) => {\n                clearTimeout(connectTimeout);\n                console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n                this.connected = false;\n                this.connecting = false;\n\n                // Notify connection change listeners\n                this.notifyConnectionChangeListeners(false);\n\n                // Check for specific close codes that indicate compatibility issues\n                if (event.code === 1006) {\n                    console.warn('WebSocket closed abnormally (code 1006), possible compatibility issue');\n\n                    // If we've tried multiple times and keep getting 1006, fall back to HTTP\n                    if (this.reconnectAttempts >= 3) {\n                        console.warn('Multiple abnormal closures, falling back to HTTP');\n                        this.fallbackToHttp();\n                        return;\n                    }\n                }\n\n                // Attempt to reconnect if not a normal closure\n                if (event.code !== 1000) {\n                    this.reconnect();\n                }\n            };\n\n            this.socket.onerror = (error) => {\n                console.error('WebSocket error:', error);\n                this.connecting = false;\n\n                // If we were connected, notify listeners that we're disconnected\n                if (this.connected) {\n                    this.connected = false;\n                    this.notifyConnectionChangeListeners(false);\n                }\n\n                // On error, increment reconnect attempts\n                this.reconnectAttempts++;\n\n                // If we've had multiple errors, fall back to HTTP\n                if (this.reconnectAttempts >= 3) {\n                    console.warn('Multiple WebSocket errors, falling back to HTTP');\n                    this.fallbackToHttp();\n                }\n            };\n        } catch (error) {\n            console.error('Error creating WebSocket:', error);\n            this.connecting = false;\n            this.reconnect();\n        }\n    }\n\n    /**\n     * Fall back to HTTP for operations\n     * This sets a flag that other components can check to use HTTP instead of WebSocket\n     */\n    fallbackToHttp() {\n        console.warn('Falling back to HTTP for operations');\n        this.usingHttpFallback = true;\n\n        // Make sure connected is set to false\n        if (this.connected) {\n            this.connected = false;\n            // Notify connection change listeners\n            this.notifyConnectionChangeListeners(false);\n        }\n\n        // Dispatch an event that components can listen for\n        const fallbackEvent = new CustomEvent('websocket-fallback', {\n            detail: { usingHttp: true }\n        });\n        window.dispatchEvent(fallbackEvent);\n\n        // Try to notify any waiting operations\n        if (this.pendingSubscriptions.size > 0) {\n            console.log(`Notifying ${this.pendingSubscriptions.size} pending subscriptions about HTTP fallback`);\n        }\n    }\n\n    /**\n     * Disconnect from the WebSocket server\n     */\n    disconnect() {\n        if (this.socket) {\n            this.socket.close(1000, 'Client disconnected');\n            this.socket = null;\n        }\n\n        this.connected = false;\n        this.connecting = false;\n        // Keep the client ID if we have one, so we can reuse it on reconnect\n        this.subscriptions.clear();\n        this.pendingSubscriptions.clear();\n        this.subscriptionParams.clear();\n        this.messageQueue = [];\n    }\n\n    /**\n     * Reconnect to the WebSocket server with exponential backoff\n     */\n    reconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            console.log('Maximum reconnect attempts reached');\n            return;\n        }\n\n        this.reconnectAttempts++;\n        const delay = Math.min(30000, this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1));\n\n        console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n\n        setTimeout(() => {\n            this.connect();\n        }, delay);\n    }\n\n    /**\n     * Send a message to the WebSocket server\n     *\n     * @param {string} type Message type\n     * @param {string} topic Message topic\n     * @param {Object} payload Message payload\n     * @returns {boolean} Whether the message was sent\n     */\n    send(type, topic, payload) {\n        if (!this.connected) {\n            console.log('WebSocket not connected, queueing message');\n            this.messageQueue.push({ type, topic, payload });\n            this.connect();\n            return false;\n        }\n\n        const message = {\n            type,\n            topic,\n            payload\n        };\n\n        try {\n            // Log the message being sent for debugging\n            console.log('Sending WebSocket message:', JSON.stringify(message));\n\n            this.socket.send(JSON.stringify(message));\n            return true;\n        } catch (error) {\n            console.error('Error sending WebSocket message:', error);\n            this.messageQueue.push({ type, topic, payload });\n            return false;\n        }\n    }\n\n    /**\n     * Process the message queue\n     */\n    processMessageQueue() {\n        if (!this.connected || this.messageQueue.length === 0) {\n            return;\n        }\n\n        console.log(`Processing ${this.messageQueue.length} queued messages`);\n\n        const queue = [...this.messageQueue];\n        this.messageQueue = [];\n\n        for (const message of queue) {\n            this.send(message.type, message.topic, message.payload);\n        }\n    }\n\n    /**\n     * Process pending subscriptions\n     */\n    processPendingSubscriptions() {\n        if (!this.connected || this.pendingSubscriptions.size === 0) {\n            return;\n        }\n\n        console.log(`Processing ${this.pendingSubscriptions.size} pending subscriptions`);\n\n        for (const topic of this.pendingSubscriptions) {\n            // Get parameters for this topic if available\n            const params = this.subscriptionParams.get(topic) || {};\n            this.subscribe(topic, params);\n        }\n\n        this.pendingSubscriptions.clear();\n    }\n\n    /**\n     * Subscribe to a topic\n     *\n     * @param {string} topic Topic to subscribe to\n     * @param {Object} params Additional parameters to include in the subscription\n     * @returns {boolean} Whether the subscription request was sent\n     */\n    subscribe(topic, params = {}) {\n        if (!this.connected) {\n            console.log(`WebSocket not connected, queueing subscription to ${topic}`);\n            this.pendingSubscriptions.add(topic);\n            this.connect();\n            return false;\n        }\n\n        if (this.subscriptions.has(topic)) {\n            console.log(`Already subscribed to ${topic}, updating parameters`);\n            // Continue with the subscription to update parameters\n        }\n\n        console.log(`Subscribing to ${topic} with params:`, params);\n\n        // Store parameters for this topic\n        this.subscriptionParams.set(topic, params);\n\n        // Include client_id in the payload to ensure server knows who's subscribing\n        const payload = {\n            client_id: this.clientId,\n            ...params\n        };\n\n        const success = this.send('subscribe', topic, payload);\n        if (success) {\n            this.subscriptions.add(topic);\n        } else {\n            this.pendingSubscriptions.add(topic);\n        }\n\n        return success;\n    }\n\n    /**\n     * Unsubscribe from a topic\n     *\n     * @param {string} topic Topic to unsubscribe from\n     * @returns {boolean} Whether the unsubscription request was sent\n     */\n    unsubscribe(topic) {\n        if (!this.connected) {\n            console.log(`WebSocket not connected, cannot unsubscribe from ${topic}`);\n            this.pendingSubscriptions.delete(topic);\n            return false;\n        }\n\n        if (!this.subscriptions.has(topic)) {\n            console.log(`Not subscribed to ${topic}`);\n            return true;\n        }\n\n        console.log(`Unsubscribing from ${topic}`);\n\n        const success = this.send('unsubscribe', topic, {});\n        if (success) {\n            this.subscriptions.delete(topic);\n            // Remove stored parameters for this topic\n            this.subscriptionParams.delete(topic);\n        }\n\n        return success;\n    }\n\n    /**\n     * Handle an incoming WebSocket message\n     *\n     * @param {string} data Message data\n     */\n    handleMessage(data) {\n        console.log('Raw WebSocket message received:', data);\n\n        try {\n            const message = JSON.parse(data);\n\n            if (!message.type || !message.topic) {\n                console.error('Invalid WebSocket message format:', message);\n                return;\n            }\n\n            console.log(`Received WebSocket message: ${message.type} ${message.topic}`, message);\n\n            // Debug log for progress and result messages\n            if (message.type === 'progress' || message.type === 'result') {\n                console.log(`Received ${message.type} message for topic ${message.topic}:`, message.payload);\n            }\n\n            // Always try to parse payload if it's a string (could be JSON)\n            if (typeof message.payload === 'string') {\n                try {\n                    const parsedPayload = JSON.parse(message.payload);\n                    console.log(`Parsed payload for ${message.type}:${message.topic}:`, parsedPayload);\n                    // Replace the string payload with the parsed object\n                    message.payload = parsedPayload;\n                } catch (e) {\n                    // Not JSON, keep as string\n                    console.log(`Payload for ${message.type}:${message.topic} is not JSON, keeping as string`);\n                }\n            }\n\n            // Handle welcome message\n            if (message.type === 'welcome' && message.topic === 'system') {\n                console.log('Received welcome message:', message);\n\n                // The payload might be a string that needs to be parsed\n                let payload = message.payload;\n                console.log('Welcome payload type:', typeof payload);\n\n                // If payload is a string, try to parse it as JSON\n                if (typeof payload === 'string') {\n                    try {\n                        payload = JSON.parse(payload);\n                        console.log('Parsed welcome payload:', payload);\n                    } catch (e) {\n                        console.error('Error parsing welcome payload as JSON:', e);\n                        console.log('Raw payload string:', payload);\n                    }\n                }\n\n                if (!payload || !payload.client_id) {\n                    console.error('Welcome message missing client_id:', payload);\n                } else {\n                    // Extract client ID from payload\n                    this.clientId = payload.client_id;\n                    console.log(`WebSocket client ID received from server: ${this.clientId}`);\n\n                    // Process pending subscriptions\n                    this.pendingSubscriptions = new Set([...this.subscriptions]);\n                    this.subscriptions.clear();\n                    this.processPendingSubscriptions();\n\n                    // Process any queued messages\n                    this.processMessageQueue();\n\n                    // Notify any waiting operations\n                    console.log(`Notifying ${this.clientIdCallbacks.length} waiting operations about client ID`);\n\n                    // Call all callbacks waiting for client ID\n                    const callbacks = [...this.clientIdCallbacks];\n                    this.clientIdCallbacks = [];\n                    for (const callback of callbacks) {\n                        try {\n                            callback(this.clientId);\n                        } catch (error) {\n                            console.error('Error in client ID callback:', error);\n                        }\n                    }\n                }\n                return;\n            }\n\n            // Handle other messages\n            const key = `${message.type}:${message.topic}`;\n            const handlers = this.handlers[key] || [];\n\n            for (const handler of handlers) {\n                try {\n                    handler(message.payload);\n                } catch (error) {\n                    console.error(`Error in WebSocket message handler for ${key}:`, error);\n                }\n            }\n        } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n        }\n    }\n\n    /**\n     * Register a message handler\n     *\n     * @param {string} type Message type\n     * @param {string} topic Message topic\n     * @param {Function} handler Message handler\n     */\n    on(type, topic, handler) {\n        const key = `${type}:${topic}`;\n\n        if (!this.handlers[key]) {\n            this.handlers[key] = [];\n        }\n\n        this.handlers[key].push(handler);\n\n        // Subscribe to topic if not already subscribed\n        if (type !== 'welcome' && type !== 'ack' && type !== 'error') {\n            this.subscribe(topic);\n        }\n    }\n\n    /**\n     * Unregister a message handler\n     *\n     * @param {string} type Message type\n     * @param {string} topic Message topic\n     * @param {Function} handler Message handler\n     */\n    off(type, topic, handler) {\n        const key = `${type}:${topic}`;\n\n        if (!this.handlers[key]) {\n            return;\n        }\n\n        if (handler) {\n            this.handlers[key] = this.handlers[key].filter(h => h !== handler);\n        } else {\n            this.handlers[key] = [];\n        }\n\n        // Unsubscribe from topic if no more handlers\n        if (this.handlers[key].length === 0 && type !== 'welcome' && type !== 'ack' && type !== 'error') {\n            this.unsubscribe(topic);\n        }\n    }\n\n    /**\n     * Get the client ID\n     *\n     * @param {Function} callback Optional callback to call when client ID is available\n     * @returns {string|null} Client ID or null if not connected\n     */\n    getClientId(callback) {\n        if (this.clientId) {\n            // If we already have a client ID, return it immediately\n            if (callback) {\n                callback(this.clientId);\n            }\n            return this.clientId;\n        } else if (callback) {\n            // If we don't have a client ID yet, add the callback to the queue\n            console.log('Client ID not available yet, adding callback to queue');\n            this.clientIdCallbacks.push(callback);\n\n            // Make sure we're connected to get a client ID\n            if (!this.connected && !this.connecting) {\n                console.log('Not connected, connecting now to get client ID');\n                this.connect();\n            }\n            return null;\n        }\n        return null;\n    }\n\n    /**\n     * Add a connection change listener\n     *\n     * @param {Function} listener Function to call when connection state changes\n     */\n    addConnectionChangeListener(listener) {\n        if (typeof listener !== 'function') {\n            console.error('Connection change listener must be a function');\n            return;\n        }\n\n        // Add listener if it doesn't already exist\n        if (!this.connectionChangeListeners.includes(listener)) {\n            this.connectionChangeListeners.push(listener);\n            console.log('Added connection change listener');\n\n            // Call the listener immediately with the current connection state\n            try {\n                listener(this.connected);\n            } catch (error) {\n                console.error('Error in connection change listener:', error);\n            }\n        }\n    }\n\n    /**\n     * Remove a connection change listener\n     *\n     * @param {Function} listener Function to remove\n     */\n    removeConnectionChangeListener(listener) {\n        const index = this.connectionChangeListeners.indexOf(listener);\n        if (index !== -1) {\n            this.connectionChangeListeners.splice(index, 1);\n            console.log('Removed connection change listener');\n        }\n    }\n\n    /**\n     * Notify all connection change listeners\n     *\n     * @param {boolean} connected Whether the connection is established\n     */\n    notifyConnectionChangeListeners(connected) {\n        console.log(`Notifying ${this.connectionChangeListeners.length} connection change listeners: connected=${connected}`);\n\n        for (const listener of this.connectionChangeListeners) {\n            try {\n                listener(connected);\n            } catch (error) {\n                console.error('Error in connection change listener:', error);\n            }\n        }\n    }\n\n    /**\n     * Check if connected to the WebSocket server\n     *\n     * @returns {boolean} Whether connected to the WebSocket server\n     */\n    isConnected() {\n        return this.connected;\n    }\n}\n\n/**\n * BatchDeleteRecordingsClient class\n * Handles batch delete recordings operations via WebSocket\n */\nexport class BatchDeleteRecordingsClient {\n    /**\n     * Create a new BatchDeleteRecordingsClient\n     *\n     * @param {WebSocketClient} wsClient WebSocket client\n     */\n    constructor(wsClient) {\n        this.wsClient = wsClient;\n        this.topic = 'recordings/batch-delete';\n        this.progressHandlers = [];\n        this.resultHandlers = [];\n        this.errorHandlers = [];\n        this._httpFallbackTimeout = null; // Store timeout ID for HTTP fallback\n\n        // Subscribe to topic\n        this.wsClient.subscribe(this.topic);\n\n        // Register handlers\n        this.wsClient.on('progress', this.topic, (payload) => {\n            this.handleProgress(payload);\n        });\n\n        this.wsClient.on('result', this.topic, (payload) => {\n            this.handleResult(payload);\n        });\n\n        this.wsClient.on('error', this.topic, (payload) => {\n            this.handleError(payload);\n        });\n    }\n\n    /**\n     * Delete recordings with progress updates\n     *\n     * @param {Object} params Delete parameters (ids or filter)\n     * @returns {Promise<Object>} Promise that resolves when the operation is complete\n     */\n    deleteWithProgress(params) {\n        return new Promise((resolve, reject) => {\n            console.log('Starting batch delete operation with params:', params);\n\n            // Check if WebSocket is connected\n            if (!this.wsClient.isConnected()) {\n                console.error('WebSocket not connected, attempting to connect');\n                this.wsClient.connect();\n\n                // Wait for connection and retry\n                setTimeout(() => {\n                    if (this.wsClient.isConnected()) {\n                        console.log('WebSocket connected, retrying batch delete');\n                        this.deleteWithProgress(params)\n                            .then(resolve)\n                            .catch(reject);\n                    } else {\n                        console.error('WebSocket still not connected, falling back to HTTP');\n                        // Fallback to HTTP if available\n                        if (typeof batchDeleteRecordingsByHttpRequest === 'function') {\n                            batchDeleteRecordingsByHttpRequest(params)\n                                .then(resolve)\n                                .catch(reject);\n                        } else {\n                            reject(new Error('WebSocket not connected and HTTP fallback not available'));\n                        }\n                    }\n                }, 1000);\n                return;\n            }\n\n            // Get client ID from the WebSocket client\n            // This will either return the client ID immediately or call our callback when it's available\n            const getClientIdAndProceed = (clientId) => {\n                console.log('Using WebSocket client ID for batch delete:', clientId);\n\n                console.log('Registering WebSocket handlers for batch delete');\n\n    // Register one-time result handler\n    const resultHandler = (payload) => {\n        console.log('Batch delete result received:', payload);\n        this.wsClient.off('result', this.topic, resultHandler);\n\n        // Log the full payload details for debugging\n        console.log('Batch delete result details:', JSON.stringify(payload, null, 2));\n\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received a result');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        resolve(payload);\n    };\n\n    // Register one-time error handler\n    const errorHandler = (payload) => {\n        console.error('Batch delete error received:', payload);\n        this.wsClient.off('error', this.topic, errorHandler);\n\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received an error');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        reject(new Error(payload.error || 'Unknown error'));\n    };\n\n                // Register handlers for both result and progress\n                this.wsClient.on('result', this.topic, resultHandler);\n                this.wsClient.on('error', this.topic, errorHandler);\n\n                // Make sure we're subscribed to the topic\n                // Use an empty object as payload to avoid issues\n                if (!this.wsClient.subscriptions.has(this.topic)) {\n                    console.log(`Subscribing to ${this.topic} before sending request`);\n\n                    // Create a subscription message with client_id\n                    const subscribePayload = { client_id: clientId };\n                    console.log(`Subscription payload:`, subscribePayload);\n\n                    // Send subscription directly to ensure it works\n                    if (this.wsClient.socket && this.wsClient.socket.readyState === WebSocket.OPEN) {\n                        const subscribeMsg = {\n                            type: 'subscribe',\n                            topic: this.topic,\n                            payload: subscribePayload\n                        };\n                        this.wsClient.socket.send(JSON.stringify(subscribeMsg));\n                        console.log('Subscription sent directly via socket');\n                    } else {\n                        this.wsClient.send('subscribe', this.topic, subscribePayload);\n                    }\n\n                    this.wsClient.subscriptions.add(this.topic);\n\n                    // Add a longer delay to ensure subscription is processed\n                    setTimeout(() => {\n                        // Send the actual delete request with client ID\n                        this.sendDeleteRequest(params, clientId, resolve, reject, resultHandler, errorHandler);\n                    }, 1000);\n                } else {\n                    console.log(`Already subscribed to ${this.topic}, sending request immediately`);\n                    // Already subscribed, send request immediately\n                    this.sendDeleteRequest(params, clientId, resolve, reject, resultHandler, errorHandler);\n                }\n            };\n\n            // Get the client ID, which will either return it immediately or call our callback when available\n            const clientId = this.wsClient.getClientId(getClientIdAndProceed);\n            if (clientId) {\n                // If we got the client ID immediately, proceed with the operation\n                getClientIdAndProceed(clientId);\n            }\n        });\n    }\n\n    /**\n     * Send the actual delete request\n     *\n     * @param {Object} params Delete parameters\n     * @param {string} clientId Client ID\n     * @param {Function} resolve Promise resolve function\n     * @param {Function} reject Promise reject function\n     * @param {Function} resultHandler Result handler to unregister on failure\n     * @param {Function} errorHandler Error handler to unregister on failure\n     */\n    sendDeleteRequest(params, clientId, resolve, reject, resultHandler, errorHandler) {\n        console.log('Sending batch delete request');\n\n        // Validate params\n        if (!params.ids && !params.filter) {\n            console.error('Missing ids or filter in batch delete params');\n            this.wsClient.off('result', this.topic, resultHandler);\n            this.wsClient.off('error', this.topic, errorHandler);\n            reject(new Error('Missing ids or filter in batch delete params'));\n            return;\n        }\n\n        // Log the IDs if present for debugging\n        if (params.ids) {\n            console.log(`Deleting ${params.ids.length} recordings with IDs:`, params.ids);\n        } else if (params.filter) {\n            console.log('Deleting recordings with filter:', params.filter);\n        }\n\n        // Validate client ID - it should be a pointer value from the server\n        if (!clientId || !clientId.startsWith('0x')) {\n            console.error(`Invalid client ID format: ${clientId}. Expected a pointer value like 0x12345678`);\n            this.wsClient.off('result', this.topic, resultHandler);\n            this.wsClient.off('error', this.topic, errorHandler);\n            reject(new Error('Invalid client ID format. Please try again.'));\n            return;\n        }\n\n        // Include the client ID in the request payload\n        const requestParams = {\n            ...params,\n            client_id: clientId // Add client ID to the request\n        };\n\n        // Log the full request details for debugging\n        console.log('Full request params:', JSON.stringify(requestParams, null, 2));\n\n        // Create the complete message\n        const message = {\n            type: 'request',\n            topic: this.topic,\n            payload: requestParams\n        };\n\n        // Log the complete message\n        console.log('Complete WebSocket message:', JSON.stringify(message, null, 2));\n\n        // Debug the client ID format\n        console.log('Client ID format check:', {\n            clientId,\n            startsWithHex: clientId.startsWith('0x'),\n            length: clientId.length,\n            isValid: clientId.startsWith('0x') && clientId.length > 2\n        });\n\n        // If we have a total count from the filter, simulate an initial progress update\n        // This helps the UI show progress even if the server doesn't send updates\n        if (params.filter && params.totalCount && typeof window.updateBatchDeleteProgress === 'function') {\n            console.log('Simulating initial progress update with total count:', params.totalCount);\n            window.updateBatchDeleteProgress({\n                current: 0,\n                total: params.totalCount,\n                succeeded: 0,\n                failed: 0,\n                status: `Starting batch delete operation for ${params.totalCount} recordings...`,\n                complete: false\n            });\n        } else if (params.ids && typeof window.updateBatchDeleteProgress === 'function') {\n            // Also simulate initial progress for IDs-based delete\n            console.log('Simulating initial progress update with IDs count:', params.ids.length);\n            window.updateBatchDeleteProgress({\n                current: 0,\n                total: params.ids.length,\n                succeeded: 0,\n                failed: 0,\n                status: `Starting batch delete operation for ${params.ids.length} recordings...`,\n                complete: false\n            });\n        }\n\n        // Send the request\n        try {\n            if (this.wsClient.socket && this.wsClient.socket.readyState === WebSocket.OPEN) {\n                // Double check the client ID is included in the payload\n                if (!message.payload.client_id || message.payload.client_id !== clientId) {\n                    console.warn('Client ID missing or incorrect in payload, fixing it');\n                    message.payload.client_id = clientId;\n                }\n\n                // Send directly to ensure it works\n                this.wsClient.socket.send(JSON.stringify(message));\n                console.log('Batch delete request sent successfully via direct socket send');\n\n                // Set a longer timeout to check if we get a response\n                // Some operations might take longer to start processing\n                this._httpFallbackTimeout = setTimeout(() => {\n                    // If we haven't received a response after 30 seconds, try HTTP fallback\n                    console.warn('No response received after 30 seconds, trying HTTP fallback');\n                    this._httpFallbackTimeout = null;\n                    if (typeof batchDeleteRecordingsByHttpRequest === 'function') {\n                        console.log('Falling back to HTTP for batch delete');\n                        batchDeleteRecordingsByHttpRequest(params)\n                            .then(resolve)\n                            .catch(reject);\n                    }\n                }, 30000); // Increased from 10000 to 30000 ms to allow more time for server processing\n\n                return true;\n            } else {\n                // Fall back to the send method\n                const success = this.wsClient.send('request', this.topic, requestParams);\n\n                if (!success) {\n                    console.error('Failed to send batch delete request');\n                    this.wsClient.off('result', this.topic, resultHandler);\n                    this.wsClient.off('error', this.topic, errorHandler);\n\n                    // Try HTTP fallback\n                    if (typeof batchDeleteRecordingsByHttpRequest === 'function') {\n                        console.log('Falling back to HTTP for batch delete');\n                        batchDeleteRecordingsByHttpRequest(params)\n                            .then(resolve)\n                            .catch(reject);\n                    } else {\n                        reject(new Error('Failed to send batch delete request'));\n                    }\n                } else {\n                    console.log('Batch delete request sent successfully via send method');\n                }\n\n                return success;\n            }\n        } catch (error) {\n            console.error('Error sending batch delete request:', error);\n            this.wsClient.off('result', this.topic, resultHandler);\n            this.wsClient.off('error', this.topic, errorHandler);\n            reject(error);\n            return false;\n        }\n    }\n\n    /**\n     * Handle progress update\n     *\n     * @param {Object} payload Progress payload\n     */\n    handleProgress(payload) {\n        console.log('Batch delete progress update received:', payload);\n\n        // Ensure payload is an object\n        let progressData = payload;\n\n        // If payload is still a string (wasn't parsed in handleMessage), try to parse it here\n        if (typeof payload === 'string') {\n            try {\n                progressData = JSON.parse(payload);\n                console.log('Parsed progress payload:', progressData);\n            } catch (e) {\n                console.error('Error parsing progress payload:', e);\n                // Keep original payload if parsing fails\n                progressData = { error: 'Failed to parse progress data' };\n            }\n        }\n\n        // If we received a progress update, we know the WebSocket connection is working\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received a progress update');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        // Directly update the progress UI with the progress data\n        // This ensures the progress bar is updated even if the registered handlers don't work\n        if (typeof window.updateBatchDeleteProgress === 'function' && progressData) {\n            try {\n                console.log('Directly updating progress UI with:', progressData);\n                window.updateBatchDeleteProgress(progressData);\n            } catch (error) {\n                console.error('Error directly updating progress UI:', error);\n            }\n        }\n\n        // Call all registered progress handlers with the progress data\n        for (const handler of this.progressHandlers) {\n            try {\n                handler(progressData);\n            } catch (error) {\n                console.error('Error in progress handler:', error);\n            }\n        }\n    }\n\n    /**\n     * Handle result\n     *\n     * @param {Object} payload Result payload\n     */\n    handleResult(payload) {\n        console.log('Batch delete result received:', payload);\n\n        // If we received a result, we know the WebSocket connection is working\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received a result');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        // Ensure payload is an object\n        let resultData = payload;\n\n        // If payload is still a string (wasn't parsed in handleMessage), try to parse it here\n        if (typeof payload === 'string') {\n            try {\n                resultData = JSON.parse(payload);\n                console.log('Parsed result payload:', resultData);\n            } catch (e) {\n                console.error('Error parsing result payload:', e);\n                // Keep original payload if parsing fails\n                resultData = { error: 'Failed to parse result data' };\n            }\n        }\n\n        // Also update the progress UI with the final result data\n        // This ensures the progress bar shows 100% even if no progress updates were received\n        if (typeof window.updateBatchDeleteProgress === 'function' && resultData) {\n            try {\n                // Create a progress update from the result data\n                const progressUpdate = {\n                    current: resultData.total || 0,\n                    total: resultData.total || 0,\n                    succeeded: resultData.succeeded || 0,\n                    failed: resultData.failed || 0,\n                    status: 'Batch delete operation complete',\n                    complete: true\n                };\n\n                console.log('Updating progress UI with final result:', progressUpdate);\n                window.updateBatchDeleteProgress(progressUpdate);\n            } catch (error) {\n                console.error('Error updating progress UI from result:', error);\n            }\n        }\n\n        // Call all registered result handlers with the result data\n        for (const handler of this.resultHandlers) {\n            try {\n                handler(resultData);\n            } catch (error) {\n                console.error('Error in result handler:', error);\n            }\n        }\n    }\n\n    /**\n     * Handle error\n     *\n     * @param {Object} payload Error payload\n     */\n    handleError(payload) {\n        console.log('Batch delete error received:', payload);\n\n        // If we received an error, we know the WebSocket connection is working\n        // Clear any pending HTTP fallback timeouts\n        if (this._httpFallbackTimeout) {\n            console.log('Clearing HTTP fallback timeout because we received an error');\n            clearTimeout(this._httpFallbackTimeout);\n            this._httpFallbackTimeout = null;\n        }\n\n        // Ensure payload is an object\n        let errorData = payload;\n\n        // If payload is still a string (wasn't parsed in handleMessage), try to parse it here\n        if (typeof payload === 'string') {\n            try {\n                errorData = JSON.parse(payload);\n                console.log('Parsed error payload:', errorData);\n            } catch (e) {\n                console.error('Error parsing error payload:', e);\n                // Keep original payload if parsing fails\n                errorData = { error: typeof payload === 'string' ? payload : 'Unknown error' };\n            }\n        }\n\n        // Update the progress UI to show the error\n        if (typeof window.updateBatchDeleteProgress === 'function') {\n            try {\n                // Create a progress update from the error data\n                const progressUpdate = {\n                    current: 0,\n                    total: 0,\n                    succeeded: 0,\n                    failed: 0,\n                    status: `Error: ${errorData.error || 'Unknown error'}`,\n                    complete: true,\n                    error: true\n                };\n\n                console.log('Updating progress UI with error:', progressUpdate);\n                window.updateBatchDeleteProgress(progressUpdate);\n            } catch (error) {\n                console.error('Error updating progress UI from error:', error);\n            }\n        }\n\n        // Call all registered error handlers with the error data\n        for (const handler of this.errorHandlers) {\n            try {\n                handler(errorData);\n            } catch (error) {\n                console.error('Error in error handler:', error);\n            }\n        }\n    }\n\n    /**\n     * Register progress handler\n     *\n     * @param {Function} handler Progress handler\n     * @returns {Function} Function to unregister the handler\n     */\n    onProgress(handler) {\n        this.progressHandlers.push(handler);\n\n        return () => {\n            this.progressHandlers = this.progressHandlers.filter(h => h !== handler);\n        };\n    }\n\n    /**\n     * Register result handler\n     *\n     * @param {Function} handler Result handler\n     * @returns {Function} Function to unregister the handler\n     */\n    onResult(handler) {\n        this.resultHandlers.push(handler);\n\n        return () => {\n            this.resultHandlers = this.resultHandlers.filter(h => h !== handler);\n        };\n    }\n\n    /**\n     * Register error handler\n     *\n     * @param {Function} handler Error handler\n     * @returns {Function} Function to unregister the handler\n     */\n    onError(handler) {\n        this.errorHandlers.push(handler);\n\n        return () => {\n            this.errorHandlers = this.errorHandlers.filter(h => h !== handler);\n        };\n    }\n}\n"],"names":["WebSocketClient","c","r","protocol","wsUrl","connectTimeout","event","error","fallbackEvent","delay","type","topic","payload","message","queue","params","success","data","parsedPayload","e","callbacks","callback","key","handlers","handler","h","listener","index","connected","BatchDeleteRecordingsClient","wsClient","resolve","reject","getClientIdAndProceed","clientId","resultHandler","errorHandler","subscribePayload","subscribeMsg","requestParams","progressData","resultData","progressUpdate","errorData"],"mappings":"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"}