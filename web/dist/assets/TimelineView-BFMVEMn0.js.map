{"version":3,"file":"TimelineView-BFMVEMn0.js","sources":["../../js/components/preact/timeline/TimelineControls.js","../../js/components/preact/timeline/TimelineRuler.js","../../js/components/preact/timeline/TimelineSegments.js","../../js/components/preact/timeline/TimelineCursor.js","../../js/components/preact/timeline/SpeedControls.js","../../js/components/preact/timeline/TimelinePlayer.js","../../js/components/preact/timeline/TimelinePage.js","../../js/components/preact/timeline/TimelineView.js"],"sourcesContent":["/**\n * LightNVR Timeline Controls Component\n * Handles play/pause and zoom controls for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelineControls component\n * @returns {JSX.Element} TimelineControls component\n */\nexport function TimelineControls() {\n  // Local state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineControls: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineControls: Received state update:', state);\n      console.log('TimelineControls: Is playing:', state.isPlaying);\n      console.log('TimelineControls: Zoom level:', state.zoomLevel);\n      console.log('TimelineControls: Segments count:', state.timelineSegments?.length || 0);\n      \n      setIsPlaying(state.isPlaying);\n      setZoomLevel(state.zoomLevel);\n    });\n    \n    // Log initial state\n    console.log('TimelineControls: Initial timelineState:', timelineState);\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Toggle playback (play/pause)\n  const togglePlayback = () => {\n    if (isPlaying) {\n      pausePlayback();\n    } else {\n      resumePlayback();\n    }\n  };\n\n  // Pause playback\n  const pausePlayback = () => {\n    timelineState.setState({ isPlaying: false });\n    \n    // If there's a video player, pause it\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      videoPlayer.pause();\n    }\n  };\n\n  // Resume playback\n  const resumePlayback = () => {\n    // If no segments, show message and return\n    if (!timelineState.timelineSegments || timelineState.timelineSegments.length === 0) {\n      showStatusMessage('No recordings to play', 'warning');\n      return;\n    }\n    \n    // Find the earliest segment in the timeline\n    let earliestSegmentIndex = 0;\n    let earliestTimestamp = Number.MAX_SAFE_INTEGER;\n    \n    timelineState.timelineSegments.forEach((segment, index) => {\n      if (segment.start_timestamp < earliestTimestamp) {\n        earliestTimestamp = segment.start_timestamp;\n        earliestSegmentIndex = index;\n      }\n    });\n    \n    console.log(`Starting from earliest segment (index ${earliestSegmentIndex})`);\n    \n    // Start playing from the earliest segment\n    timelineState.setState({ \n      currentSegmentIndex: earliestSegmentIndex,\n      currentTime: timelineState.timelineSegments[earliestSegmentIndex].start_timestamp,\n      isPlaying: true,\n      forceReload: true // Force reload to ensure video player updates\n    });\n    \n    // Force load the earliest segment's video\n    const segment = timelineState.timelineSegments[earliestSegmentIndex];\n    const videoPlayer = document.querySelector('#video-player video');\n    \n    if (videoPlayer) {\n      console.log('Loading earliest segment video:', segment);\n      \n      // Pause any current playback\n      videoPlayer.pause();\n      \n      // Clear the source and reload\n      videoPlayer.removeAttribute('src');\n      videoPlayer.load();\n      \n      // Set the new source with a timestamp to prevent caching\n      videoPlayer.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n      \n      // Set the current time and play\n      videoPlayer.onloadedmetadata = () => {\n        videoPlayer.currentTime = 0;\n        videoPlayer.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      };\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index) => {\n    // This function will be implemented in the TimelinePlayer component\n    // Here we just update the state\n    timelineState.setState({ \n      currentSegmentIndex: index,\n      isPlaying: true \n    });\n  };\n\n  // Zoom in on timeline\n  const zoomIn = () => {\n    if (zoomLevel < 8) {\n      const newZoomLevel = zoomLevel * 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed in: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  // Zoom out on timeline\n  const zoomOut = () => {\n    if (zoomLevel > 1) {\n      const newZoomLevel = zoomLevel / 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed out: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  return html`\n    <div class=\"timeline-controls flex justify-between items-center mb-2\">\n      <div class=\"flex items-center\">\n        <button \n          id=\"play-button\" \n          class=\"w-10 h-10 rounded-full bg-green-600 hover:bg-green-700 text-white flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-offset-1 transition-colors shadow-sm mr-2\"\n          onClick=${togglePlayback}\n          title=${isPlaying ? 'Pause' : 'Play from earliest recording'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            ${isPlaying \n              ? html`\n                <!-- Pause icon - two vertical bars -->\n                <rect x=\"6\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n                <rect x=\"14\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n              `\n              : html`\n                <!-- Play icon - triangle -->\n                <path d=\"M8 5.14v14l11-7-11-7z\" fill=\"white\" />\n              `\n            }\n          </svg>\n        </button>\n        <span class=\"text-xs text-gray-600 dark:text-gray-300\">Play from earliest recording</span>\n      </div>\n      \n      <div class=\"flex items-center gap-1\">\n        <span class=\"text-xs text-gray-600 dark:text-gray-300 mr-1\">Zoom:</span>\n        <button \n          id=\"zoom-out-button\" \n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomOut}\n          title=\"Zoom Out (Show more time)\"\n          disabled=${zoomLevel <= 1}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n        <button \n          id=\"zoom-in-button\" \n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomIn}\n          title=\"Zoom In (Show less time)\"\n          disabled=${zoomLevel >= 8}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Ruler Component\n * Displays the time ruler with hour markers\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineRuler component\n * @returns {JSX.Element} TimelineRuler component\n */\nexport function TimelineRuler() {\n  // Local state\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineRuler: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineRuler: Received state update:', state);\n      console.log('TimelineRuler: Zoom level:', state.zoomLevel);\n      \n      // Calculate time range based on zoom level\n      const hoursPerView = 24 / state.zoomLevel;\n      console.log('TimelineRuler: Hours per view:', hoursPerView);\n      \n      // Calculate the center hour based on current time or segments\n      let centerHour = 12; // Default to noon\n      \n      if (state.currentTime !== null) {\n        // If we have a current time, use it as the center\n        const currentDate = new Date(state.currentTime * 1000);\n        centerHour = currentDate.getHours() + (currentDate.getMinutes() / 60) + (currentDate.getSeconds() / 3600);\n      } else if (state.timelineSegments && state.timelineSegments.length > 0) {\n        // If we have segments but no current time, use the middle of the segments\n        let earliestHour = 24;\n        let latestHour = 0;\n        \n        state.timelineSegments.forEach(segment => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n          \n          const startHour = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n          const endHour = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n          \n          earliestHour = Math.min(earliestHour, startHour);\n          latestHour = Math.max(latestHour, endHour);\n        });\n        \n        centerHour = (earliestHour + latestHour) / 2;\n      }\n      \n      // Calculate start and end hours based on center and zoom level\n      let newStartHour = Math.max(0, centerHour - (hoursPerView / 2));\n      let newEndHour = Math.min(24, newStartHour + hoursPerView);\n      \n      // Adjust start hour if end hour is at the limit\n      if (newEndHour === 24 && hoursPerView < 24) {\n        newStartHour = Math.max(0, 24 - hoursPerView);\n        newEndHour = 24;\n      } else if (newStartHour === 0 && hoursPerView < 24) {\n        newEndHour = Math.min(24, hoursPerView);\n      }\n      \n      console.log('TimelineRuler: New hour range:', { newStartHour, newEndHour });\n      \n      // Update local state\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setZoomLevel(state.zoomLevel);\n      \n      // Only update global state if the values have actually changed\n      // to prevent infinite recursion\n      if (timelineState.timelineStartHour !== newStartHour || \n          timelineState.timelineEndHour !== newEndHour) {\n        timelineState.setState({\n          timelineStartHour: newStartHour,\n          timelineEndHour: newEndHour\n        });\n      }\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Generate hour markers and labels\n  const generateHourMarkers = () => {\n    const markers = [];\n    const hourWidth = 100 / (endHour - startHour);\n    \n    // Add hour markers and labels\n    for (let hour = Math.floor(startHour); hour <= Math.ceil(endHour); hour++) {\n      if (hour >= 0 && hour <= 24) {\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        \n        // Add hour marker\n        markers.push(html`\n          <div \n            key=\"tick-${hour}\" \n            class=\"absolute top-0 w-px h-5 bg-gray-500 dark:bg-gray-400\" \n            style=\"left: ${position}%;\"\n          ></div>\n        `);\n        \n        // Add hour label\n        markers.push(html`\n          <div \n            key=\"label-${hour}\" \n            class=\"absolute top-0 text-xs text-gray-600 dark:text-gray-300 transform -translate-x-1/2\" \n            style=\"left: ${position}%;\"\n          >\n            ${hour}:00\n          </div>\n        `);\n        \n        // Add half-hour marker if not the last hour and we're zoomed in enough\n        if (hour < 24 && zoomLevel >= 2) {\n          const halfHourPosition = ((hour + 0.5 - startHour) / (endHour - startHour)) * 100;\n          markers.push(html`\n            <div \n              key=\"tick-${hour}-30\" \n              class=\"absolute top-2 w-px h-3 bg-gray-400 dark:bg-gray-500\" \n              style=\"left: ${halfHourPosition}%;\"\n            ></div>\n          `);\n          \n          // Add 15-minute markers if zoomed in even more\n          if (zoomLevel >= 4) {\n            const quarterHourPosition1 = ((hour + 0.25 - startHour) / (endHour - startHour)) * 100;\n            const quarterHourPosition3 = ((hour + 0.75 - startHour) / (endHour - startHour)) * 100;\n            \n            markers.push(html`\n              <div \n                key=\"tick-${hour}-15\" \n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\" \n                style=\"left: ${quarterHourPosition1}%;\"\n              ></div>\n            `);\n            \n            markers.push(html`\n              <div \n                key=\"tick-${hour}-45\" \n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\" \n                style=\"left: ${quarterHourPosition3}%;\"\n              ></div>\n            `);\n          }\n        }\n      }\n    }\n    \n    return markers;\n  };\n\n  return html`\n    <div class=\"timeline-ruler relative w-full h-8 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-600\">\n      ${generateHourMarkers()}\n      <div class=\"absolute bottom-0 left-0 text-xs text-gray-500 px-1\">\n        Zoom: ${zoomLevel}x (${Math.round(24 / zoomLevel)} hours)\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Segments Component\n * Displays recording segments on the timeline\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineSegments component\n * @returns {JSX.Element} TimelineSegments component\n */\nexport function TimelineSegments() {\n  // Local state\n  const [segments, setSegments] = useState([]);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  \n  // Refs\n  const containerRef = useRef(null);\n  const isDragging = useRef(false);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('TimelineSegments: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineSegments: Received state update');\n      \n      // Update segments\n      if (state.timelineSegments) {\n        console.log(`TimelineSegments: Updating segments (${state.timelineSegments.length})`);\n        setSegments(state.timelineSegments);\n      }\n      \n      // Update other state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n      setCurrentSegmentIndex(state.currentSegmentIndex || -1);\n    });\n    \n    // Check if we already have segments in the timelineState\n    if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n      console.log(`TimelineSegments: Initial segments available (${timelineState.timelineSegments.length})`);\n      setSegments(timelineState.timelineSegments);\n      setCurrentSegmentIndex(timelineState.currentSegmentIndex || 0);\n    }\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set up drag handling\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    \n    const handleMouseDown = (e) => {\n      // Only handle clicks on the container itself, not on segments\n      if (e.target === container || e.target.classList.contains('timeline-clickable-area')) {\n        isDragging.current = true;\n        handleTimelineClick(e);\n        \n        // Add event listeners for drag\n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n      }\n    };\n    \n    const handleMouseMove = (e) => {\n      if (!isDragging.current) return;\n      handleTimelineClick(e);\n    };\n    \n    const handleMouseUp = () => {\n      isDragging.current = false;\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n    \n    container.addEventListener('mousedown', handleMouseDown);\n    \n    return () => {\n      container.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [startHour, endHour, segments]);\n\n  // Handle click on timeline for seeking\n  const handleTimelineClick = (event) => {\n    const container = containerRef.current;\n    if (!container) return;\n    \n    // Get click position relative to container\n    const rect = container.getBoundingClientRect();\n    const clickX = event.clientX - rect.left;\n    const containerWidth = rect.width;\n    \n    // Calculate time based on click position\n    const clickPercent = clickX / containerWidth;\n    const clickHour = startHour + (clickPercent * (endHour - startHour));\n    \n    // Find the segment that contains this time\n    const clickDate = new Date(timelineState.selectedDate);\n    clickDate.setHours(Math.floor(clickHour));\n    clickDate.setMinutes(Math.floor((clickHour % 1) * 60));\n    clickDate.setSeconds(Math.floor(((clickHour % 1) * 60) % 1 * 60));\n    \n    const clickTimestamp = clickDate.getTime() / 1000;\n    \n    // Find segment that contains this timestamp\n    let foundSegment = false;\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n      \n      if (clickTimestamp >= startTimestamp && clickTimestamp <= endTimestamp) {\n        console.log(`TimelineSegments: Found segment ${i} containing timestamp`);\n        \n        // Calculate relative time within the segment\n        const relativeTime = clickTimestamp - startTimestamp;\n        \n        // Update current segment index\n        setCurrentSegmentIndex(i);\n        \n        // Play this segment starting at the clicked time\n        playSegment(i, relativeTime);\n        foundSegment = true;\n        break;\n      }\n    }\n    \n    if (!foundSegment) {\n      if (segments.length > 0) {\n        console.log('TimelineSegments: No segment contains the timestamp, finding closest segment');\n        // Find the closest segment\n        let closestSegment = -1;\n        let minDistance = Infinity;\n        \n        for (let i = 0; i < segments.length; i++) {\n          const segment = segments[i];\n          // Use local timestamps if available, otherwise fall back to regular timestamps\n          const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n          const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n          \n          const startDistance = Math.abs(startTimestamp - clickTimestamp);\n          const endDistance = Math.abs(endTimestamp - clickTimestamp);\n          const distance = Math.min(startDistance, endDistance);\n          \n          if (distance < minDistance) {\n            minDistance = distance;\n            closestSegment = i;\n          }\n        }\n        \n        if (closestSegment >= 0) {\n          console.log(`TimelineSegments: Playing closest segment ${closestSegment}`);\n          \n          // Play the closest segment\n          playSegment(closestSegment);\n        }\n      } else {\n        // No segments found, just update the currentTime\n        console.log('TimelineSegments: No segments found, just updating currentTime');\n        timelineState.setState({ \n          currentTime: clickTimestamp,\n          prevCurrentTime: timelineState.currentTime\n        });\n      }\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index, relativeTime = null) => {\n    console.log(`TimelineSegments: playSegment(${index}, ${relativeTime})`);\n    \n    if (index < 0 || index >= segments.length) {\n      console.warn(`TimelineSegments: Invalid segment index: ${index}`);\n      return;\n    }\n    \n    const segment = segments[index];\n    \n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n    \n    // Calculate absolute timestamp for currentTime\n    const absoluteTime = relativeTime !== null \n      ? startTimestamp + relativeTime \n      : startTimestamp;\n    \n    // First, pause any current playback and reset the segment index\n    timelineState.setState({ \n      isPlaying: false,\n      currentSegmentIndex: -1\n    });\n    \n    // Force a synchronous DOM update\n    document.body.offsetHeight;\n    \n    // Now set the new segment index and start playing\n    setTimeout(() => {\n      timelineState.setState({ \n        currentSegmentIndex: index,\n        currentTime: absoluteTime,\n        isPlaying: true,\n        forceReload: true\n      });\n      \n      // Force the video player to reload\n      setTimeout(() => {\n        const videoElement = document.querySelector('#video-player video');\n        if (videoElement) {\n          // Pause any current playback\n          videoElement.pause();\n          \n          // Clear the source and reload\n          videoElement.removeAttribute('src');\n          videoElement.load();\n          \n          // Set the new source\n          videoElement.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n          \n          // Set the current time and play\n          videoElement.onloadedmetadata = () => {\n            const seekTime = relativeTime !== null ? relativeTime : 0;\n            videoElement.currentTime = seekTime;\n            videoElement.play().catch(e => console.error('Error playing video:', e));\n          };\n        }\n      }, 50);\n    }, 50);\n  };\n\n  // Render segments\n  const renderSegments = () => {\n    console.log(`TimelineSegments: Rendering ${segments.length} segments`);\n    \n    if (!segments || segments.length === 0) {\n      return null;\n    }\n    \n    const visibleSegments = [];\n    const hourMap = new Map();\n    \n    // First pass: collect all segments by hour\n    segments.forEach((segment, index) => {\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n      \n      // Convert timestamps to Date objects\n      const startTime = new Date(startTimestamp * 1000);\n      const endTime = new Date(endTimestamp * 1000);\n      \n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n      \n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n      \n      // Mark each hour that this segment spans\n      const startFloorHour = Math.floor(startHourFloat);\n      const endCeilHour = Math.min(Math.ceil(endHourFloat), 24);\n      \n      for (let h = startFloorHour; h < endCeilHour; h++) {\n        if (h >= startHour && h <= endHour) {\n          if (!hourMap.has(h)) {\n            hourMap.set(h, []);\n          }\n          hourMap.get(h).push(index);\n        }\n      }\n    });\n    \n    // Preprocess segments to merge adjacent ones\n    const mergedSegments = [];\n    let currentMergedSegment = null;\n    \n    // Sort segments by start time (using local timestamps if available)\n    const sortedSegments = [...segments].sort((a, b) => {\n      const aStart = a.local_start_timestamp || a.start_timestamp;\n      const bStart = b.local_start_timestamp || b.start_timestamp;\n      return aStart - bStart;\n    });\n    \n    // Merge adjacent segments (no gap or very small gap)\n    sortedSegments.forEach((segment, index) => {\n      if (!currentMergedSegment) {\n        // First segment\n        currentMergedSegment = { ...segment, originalIndices: [index] };\n      } else {\n        // Check if this segment is adjacent to the current merged segment\n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const segmentStart = segment.local_start_timestamp || segment.start_timestamp;\n        const mergedEnd = currentMergedSegment.local_end_timestamp || currentMergedSegment.end_timestamp;\n        \n        // Allow a small gap (1 second) to account for rounding errors\n        const gap = segmentStart - mergedEnd;\n        \n        if (gap <= 1) {\n          // Merge with current segment\n          // Update both regular and local timestamps\n          currentMergedSegment.end_timestamp = segment.end_timestamp;\n          if (segment.local_end_timestamp) {\n            currentMergedSegment.local_end_timestamp = segment.local_end_timestamp;\n          }\n          currentMergedSegment.originalIndices.push(index);\n          \n          // If this segment has detection, mark the merged segment as having detection\n          if (segment.has_detection) {\n            currentMergedSegment.has_detection = true;\n          }\n        } else {\n          // Gap is too large, start a new merged segment\n          mergedSegments.push(currentMergedSegment);\n          currentMergedSegment = { ...segment, originalIndices: [index] };\n        }\n      }\n    });\n    \n    // Add the last merged segment\n    if (currentMergedSegment) {\n      mergedSegments.push(currentMergedSegment);\n    }\n    \n    console.log(`TimelineSegments: Merged ${segments.length} segments into ${mergedSegments.length} segments`);\n    \n    // Second pass: add visible segments\n    mergedSegments.forEach((segment, mergedIndex) => {\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const segStartTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const segEndTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n      \n      // Convert timestamps to Date objects\n      const startTime = new Date(segStartTimestamp * 1000);\n      const endTime = new Date(segEndTimestamp * 1000);\n      \n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n      \n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n      \n      // Adjust start and end to fit within visible range\n      const visibleStartHour = Math.max(startHourFloat, startHour);\n      const visibleEndHour = Math.min(endHourFloat, endHour);\n      \n      // Calculate position and width as percentages\n      const startPercent = ((visibleStartHour - startHour) / (endHour - startHour)) * 100;\n      const widthPercent = ((visibleEndHour - visibleStartHour) / (endHour - startHour)) * 100;\n      \n      // Format duration for tooltip\n      const duration = Math.round(segEndTimestamp - segStartTimestamp);\n      const durationStr = `${duration}s`;\n      \n      // Format times for tooltip\n      const startTimeStr = startTime.toLocaleTimeString();\n      const endTimeStr = endTime.toLocaleTimeString();\n      \n      // Use a consistent height for all segments\n      const heightPercent = 80; // 80% height for all segments\n      \n      visibleSegments.push(html`\n        <div \n          key=\"segment-${mergedIndex}\"\n          class=\"timeline-segment absolute rounded-sm transition-all duration-200 ${segment.has_detection ? 'bg-red-500' : 'bg-blue-500'}\"\n          style=\"left: ${startPercent}%; width: ${widthPercent}%; height: ${heightPercent}%; top: 50%; transform: translateY(-50%);\"\n          title=\"${startTimeStr} - ${endTimeStr} (${durationStr})\"\n        ></div>\n      `);\n    });\n    \n    // Third pass: fill in gaps with clickable areas\n    for (let hour = Math.floor(startHour); hour < Math.ceil(endHour); hour++) {\n      if (!hourMap.has(hour)) {\n        // No segments in this hour, create a clickable area\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        const width = 100 / (endHour - startHour);\n        \n        visibleSegments.push(html`\n          <div \n            key=\"clickable-${hour}\"\n            class=\"timeline-clickable-area absolute h-full cursor-pointer\"\n            style=\"left: ${position}%; width: ${width}%;\"\n            data-hour=${hour}\n          ></div>\n        `);\n      }\n    }\n    \n    return visibleSegments;\n  };\n\n  return html`\n    <div \n      class=\"timeline-segments relative w-full h-16 pt-2\"\n      ref=${containerRef}\n    >\n      ${renderSegments()}\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Cursor Component\n * Displays the playback cursor on the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineCursor component\n * @returns {JSX.Element} TimelineCursor component\n */\nexport function TimelineCursor() {\n  // Local state\n  const [position, setPosition] = useState(0);\n  const [visible, setVisible] = useState(false);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentTime, setCurrentTime] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n  \n  // Refs\n  const cursorRef = useRef(null);\n  const containerRef = useRef(null);\n  const dragStartXRef = useRef(0);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n      setCurrentTime(state.currentTime);\n      \n      // Update time display\n      updateTimeDisplay(state.currentTime);\n      \n      // Update cursor position (only if not dragging)\n      if (!isDragging) {\n        updateCursorPosition(state.currentTime, state.timelineStartHour || 0, state.timelineEndHour || 24);\n      }\n    });\n    \n    return () => unsubscribe();\n  }, [isDragging]);\n\n  // Set up drag handling\n  useEffect(() => {\n    const cursor = cursorRef.current;\n    if (!cursor) return;\n    \n    const handleMouseDown = (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      // Store the starting X position\n      dragStartXRef.current = e.clientX;\n      \n      setIsDragging(true);\n      \n      // Add event listeners for drag\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    };\n    \n    const handleMouseMove = (e) => {\n      if (!isDragging) return;\n      \n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n      \n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n      \n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      setPosition(positionPercent);\n      \n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      \n      // Convert hour to timestamp\n      const date = new Date(timelineState.selectedDate);\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      \n      const timestamp = date.getTime() / 1000;\n      \n      // Update time display\n      updateTimeDisplay(timestamp);\n    };\n    \n    const handleMouseUp = (e) => {\n      if (!isDragging) return;\n      \n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n      \n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n      \n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      \n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      \n      // Convert hour to timestamp\n      const date = new Date(timelineState.selectedDate);\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      \n      const timestamp = date.getTime() / 1000;\n      \n      // Reset dragging state FIRST\n      setIsDragging(false);\n      \n      // Remove event listeners\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      \n      // Find segment that contains this timestamp\n      const segments = timelineState.timelineSegments || [];\n      let foundSegment = false;\n      \n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n        const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n        \n        if (timestamp >= startTimestamp && timestamp <= endTimestamp) {\n          // Calculate relative time within the segment\n          const relativeTime = timestamp - startTimestamp;\n          \n          // Update timeline state\n          timelineState.setState({ \n            currentSegmentIndex: i,\n            currentTime: timestamp,\n            prevCurrentTime: timelineState.currentTime,\n            isPlaying: true\n          });\n          \n          foundSegment = true;\n          break;\n        }\n      }\n      \n      // If no segment found, find the closest one\n      if (!foundSegment && segments.length > 0) {\n        let closestSegment = 0;\n        let minDistance = Infinity;\n        \n        for (let i = 0; i < segments.length; i++) {\n          const segment = segments[i];\n          // Use local timestamps if available, otherwise fall back to regular timestamps\n          const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n          const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n          \n          const startDistance = Math.abs(startTimestamp - timestamp);\n          const endDistance = Math.abs(endTimestamp - timestamp);\n          const distance = Math.min(startDistance, endDistance);\n          \n          if (distance < minDistance) {\n            minDistance = distance;\n            closestSegment = i;\n          }\n        }\n        \n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const closestSegmentObj = segments[closestSegment];\n        const startTimestamp = closestSegmentObj.local_start_timestamp || closestSegmentObj.start_timestamp;\n        \n        // Update timeline state\n        timelineState.setState({ \n          currentSegmentIndex: closestSegment,\n          currentTime: startTimestamp,\n          prevCurrentTime: timelineState.currentTime,\n          isPlaying: true\n        });\n      }\n    };\n    \n    // Add event listeners\n    cursor.addEventListener('mousedown', handleMouseDown);\n    \n    return () => {\n      cursor.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [cursorRef.current, startHour, endHour, isDragging]);\n\n  // Update cursor position\n  const updateCursorPosition = (time, startHr, endHr) => {\n    if (time === null) {\n      setVisible(false);\n      return;\n    }\n    \n    // Calculate cursor position\n    const date = new Date(time * 1000);\n    const hour = date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n    \n    // Check if the current time is within the visible range\n    if (hour < startHr || hour > endHr) {\n      setVisible(false);\n      return;\n    }\n    \n    // Calculate position as percentage\n    const position = ((hour - startHr) / (endHr - startHr)) * 100;\n    \n    // Update cursor position\n    setPosition(position);\n    setVisible(true);\n  };\n\n  // Update time display\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  // Force the cursor to be visible on initial render\n  useEffect(() => {\n    // Set visible to true after a short delay\n    setTimeout(() => {\n      if (timelineState.currentTime) {\n        setVisible(true);\n        updateCursorPosition(\n          timelineState.currentTime, \n          timelineState.timelineStartHour || 0, \n          timelineState.timelineEndHour || 24\n        );\n      }\n    }, 500);\n  }, []);\n\n  return html`\n    <div \n      ref=${cursorRef}\n      class=\"timeline-cursor absolute top-0 h-full z-50 transition-all duration-100 cursor-ew-resize\"\n      style=\"left: ${position}%; display: ${visible ? 'block' : 'none'}; pointer-events: auto; width: 7px; margin-left: -3.5px;\"\n    >\n      <!-- Invisible wider clickable area -->\n      <div class=\"absolute top-0 bottom-0 left-0 w-full\"></div>\n      \n      <!-- Skinnier needle with no middle chunk -->\n      <div class=\"absolute top-0 bottom-0 w-0.5 bg-orange-500 left-1/2 transform -translate-x-1/2 pointer-events-none\"></div>\n      \n      <!-- Top handle (black) -->\n      <div class=\"absolute top-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 -translate-y-1/2 shadow-md pointer-events-none\"></div>\n      \n      <!-- Bottom handle (black) -->\n      <div class=\"absolute bottom-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 translate-y-1/2 shadow-md pointer-events-none\"></div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Speed Controls Component\n * Handles playback speed controls for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * SpeedControls component\n * @returns {JSX.Element} SpeedControls component\n */\nexport function SpeedControls() {\n  // Local state\n  const [currentSpeed, setCurrentSpeed] = useState(1.0);\n  \n  // Available speeds\n  const speeds = [0.25, 0.5, 1.0, 1.5, 2.0, 4.0];\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    console.log('SpeedControls: Setting up subscription to timelineState');\n    \n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('SpeedControls: Received state update:', state);\n      console.log('SpeedControls: Playback speed:', state.playbackSpeed);\n      \n      setCurrentSpeed(state.playbackSpeed);\n    });\n    \n    // Log initial state\n    console.log('SpeedControls: Initial timelineState:', timelineState);\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set playback speed\n  const setPlaybackSpeed = (speed) => {\n    // Update video playback rate\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      // Store the current playback rate for debugging\n      const oldRate = videoPlayer.playbackRate;\n      \n      // Set the new playback rate\n      videoPlayer.playbackRate = speed;\n      \n      console.log(`Setting video playback rate from ${oldRate}x to ${speed}x`, videoPlayer);\n      console.log(`Actual playback rate after setting: ${videoPlayer.playbackRate}x`);\n      \n      // Force the playback rate again after a short delay\n      setTimeout(() => {\n        videoPlayer.playbackRate = speed;\n        console.log(`Re-setting playback rate to ${speed}x, actual rate: ${videoPlayer.playbackRate}x`);\n      }, 100);\n    } else {\n      console.warn('Video player element not found');\n    }\n    \n    // Update timeline state\n    timelineState.setState({ playbackSpeed: speed });\n    \n    // Show status message\n    showStatusMessage(`Playback speed: ${speed}x`, 'info');\n  };\n\n  return html`\n    <div class=\"mt-2 mb-4 p-2 border border-green-500 rounded-lg bg-white dark:bg-gray-800 shadow-sm\">\n      <div class=\"flex flex-col items-center\">\n        <div class=\"text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300\">Playback Speed</div>\n        \n        <div class=\"flex flex-wrap justify-center gap-1\">\n          ${speeds.map(speed => html`\n            <button \n              key=${`speed-${speed}`}\n              class=${`speed-btn px-2 py-1 text-sm rounded-full ${speed === currentSpeed \n                ? 'bg-green-500 text-white' \n                : 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600'} \n                font-medium transition-all focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-opacity-50`}\n              data-speed=${speed}\n              onClick=${() => setPlaybackSpeed(speed)}\n            >\n              ${speed === 1.0 ? '1× (Normal)' : `${speed}×`}\n            </button>\n          `)}\n        </div>\n        \n        <div class=\"mt-1 text-xs font-medium text-green-600 dark:text-green-400\">\n          Current: ${currentSpeed}× ${currentSpeed === 1.0 ? '(Normal)' : ''}\n        </div>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Player Component\n * Handles video playback for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelinePlayer component\n * @returns {JSX.Element} TimelinePlayer component\n */\nexport function TimelinePlayer() {\n  // Local state\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [segments, setSegments] = useState([]);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n\n  // Refs\n  const videoRef = useRef(null);\n  const lastTimeUpdateRef = useRef(null);\n  const lastSegmentIdRef = useRef(null);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setCurrentSegmentIndex(state.currentSegmentIndex);\n      setIsPlaying(state.isPlaying);\n      setSegments(state.timelineSegments || []);\n      setPlaybackSpeed(state.playbackSpeed);\n\n      // Handle video playback\n      handleVideoPlayback(state);\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Handle video playback based on state changes\n  const handleVideoPlayback = (state) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have valid segments and segment index\n    if (!state.timelineSegments || \n        state.timelineSegments.length === 0 || \n        state.currentSegmentIndex < 0 || \n        state.currentSegmentIndex >= state.timelineSegments.length) {\n      return;\n    }\n    \n    // Get current segment\n    const segment = state.timelineSegments[state.currentSegmentIndex];\n    if (!segment) return;\n    \n    // Check if we need to load a new segment\n    const segmentChanged = lastSegmentIdRef.current !== segment.id;\n    \n    // IMPORTANT: Only reload if the segment has actually changed\n    // This prevents constant reloading\n    const needsReload = segmentChanged;\n    \n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n    \n    // Calculate relative time within the segment\n    const relativeTime = state.currentTime !== null && \n                         state.currentTime >= startTimestamp\n      ? state.currentTime - startTimestamp\n      : 0;\n    \n    // Only update the video if:\n    // 1. We need to load a new segment, OR\n    // 2. The user is dragging the cursor (indicated by a significant time change)\n    const timeChanged = state.prevCurrentTime !== null && \n                        Math.abs(state.currentTime - state.prevCurrentTime) > 1;\n    \n    // Update last segment ID\n    if (segmentChanged) {\n      console.log(`Segment changed from ${lastSegmentIdRef.current} to ${segment.id}`);\n      lastSegmentIdRef.current = segment.id;\n    }\n    \n    // Handle playback\n    if (needsReload) {\n      // Load new segment\n      console.log(`Loading new segment ${segment.id} (segmentChanged: ${segmentChanged})`);\n      loadSegment(segment, relativeTime, state.isPlaying);\n    } else if (timeChanged) {\n      // User is dragging the cursor, just update the current time\n      console.log(`Seeking to ${relativeTime}s within current segment`);\n      video.currentTime = relativeTime;\n    } else if (state.isPlaying && video.paused) {\n      // Resume playback if needed\n      video.play().catch(error => {\n        console.error('Error playing video:', error);\n      });\n    } else if (!state.isPlaying && !video.paused) {\n      // Pause playback if needed\n      video.pause();\n    }\n    \n    // Update playback speed if needed\n    if (video.playbackRate !== state.playbackSpeed) {\n      video.playbackRate = state.playbackSpeed;\n    }\n  };\n\n  // Load a segment\n  const loadSegment = (segment, seekTime = 0, autoplay = false) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    console.log(`Loading segment ${segment.id} at time ${seekTime}s, autoplay: ${autoplay}`);\n    \n    // Pause current playback\n    video.pause();\n    \n    // Set new source with timestamp to prevent caching\n    const recordingUrl = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n    \n    // Set up event listeners for the new video\n    const onLoadedMetadata = () => {\n      console.log('Video metadata loaded');\n      \n      // Set current time\n      video.currentTime = seekTime;\n      \n      // Set playback speed\n      video.playbackRate = playbackSpeed;\n      \n      // Play if needed\n      if (autoplay) {\n        video.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      }\n      \n      // Remove event listener\n      video.removeEventListener('loadedmetadata', onLoadedMetadata);\n    };\n    \n    // Add event listener for metadata loaded\n    video.addEventListener('loadedmetadata', onLoadedMetadata);\n    \n    // Set new source\n    video.src = recordingUrl;\n    video.load();\n  };\n\n  // Handle video ended event\n  const handleEnded = () => {\n    console.log('Video ended');\n    \n    // Check if we have a next segment\n    if (currentSegmentIndex < segments.length - 1) {\n      // Play next segment\n      const nextIndex = currentSegmentIndex + 1;\n      console.log(`Playing next segment ${nextIndex}`);\n      \n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const nextSegment = segments[nextIndex];\n      const startTimestamp = nextSegment.local_start_timestamp || nextSegment.start_timestamp;\n      \n      // Update timeline state\n      timelineState.setState({\n        currentSegmentIndex: nextIndex,\n        currentTime: startTimestamp,\n        isPlaying: true,\n        forceReload: true\n      });\n    } else {\n      // End of all segments\n      console.log('End of all segments');\n      \n      // Update timeline state\n      timelineState.setState({\n        isPlaying: false\n      });\n    }\n  };\n\n  // Handle video time update event\n  const handleTimeUpdate = () => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have a valid segment\n    if (currentSegmentIndex < 0 || \n        !segments || \n        segments.length === 0 || \n        currentSegmentIndex >= segments.length) {\n      return;\n    }\n    \n    const segment = segments[currentSegmentIndex];\n    if (!segment) return;\n    \n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n    \n    // Calculate current timestamp\n    const currentTime = startTimestamp + video.currentTime;\n    \n    // Directly update the time display as well\n    updateTimeDisplay(currentTime);\n    \n    // Update timeline state with the current time\n    timelineState.setState({\n      currentTime: currentTime,\n      prevCurrentTime: lastTimeUpdateRef.current\n    });\n    \n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n  };\n\n  // Add a direct time display update function\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  return html`\n    <div class=\"timeline-player-container mb-2\" id=\"video-player\">\n      <div class=\"relative w-full bg-black rounded-lg shadow-md\" style=\"aspect-ratio: 16/9;\">\n        <video\n            ref=${videoRef}\n            class=\"w-full h-full object-contain\"\n            controls\n            autoplay=${false}\n            muted=${false}\n            playsInline\n            onended=${handleEnded}\n            ontimeupdate=${handleTimeUpdate}\n        ></video>\n        \n        <!-- Add a message for invalid segments -->\n        <div \n          class=\"absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-center p-4 ${currentSegmentIndex >= 0 && segments.length > 0 ? 'hidden' : ''}\"\n        >\n          <div>\n            <p class=\"mb-2\">No valid segment selected.</p>\n            <p class=\"text-sm\">Click on a segment in the timeline or use the play button to start playback.</p>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Playback speed controls -->\n    <${SpeedControls} />\n  `;\n}\n","/**\n * LightNVR Timeline Page Component\n * Main component for the timeline view\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { TimelineControls } from './TimelineControls.js';\nimport { TimelineRuler } from './TimelineRuler.js';\nimport { TimelineSegments } from './TimelineSegments.js';\nimport { TimelineCursor } from './TimelineCursor.js';\nimport { TimelinePlayer } from './TimelinePlayer.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\nimport { LoadingIndicator } from '../LoadingIndicator.js';\nimport { useQuery } from '../../../query-client.js';\n\n// Global timeline state for child components\nconst timelineState = {\n  streams: [],\n  timelineSegments: [],\n  selectedStream: null,\n  selectedDate: null,\n  isPlaying: false,\n  currentSegmentIndex: -1,\n  zoomLevel: 1, // 1 = 1 hour, 2 = 30 minutes, 4 = 15 minutes\n  timelineStartHour: 0,\n  timelineEndHour: 24,\n  currentTime: null,\n  prevCurrentTime: null,\n  playbackSpeed: 1.0,\n  showOnlySegments: true,\n  forceReload: false,\n  listeners: new Set(),\n\n  // Update state and notify listeners\n  setState(newState) {\n    Object.assign(this, newState);\n    this.notifyListeners();\n  },\n\n  // Subscribe to state changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  },\n\n  // Notify all listeners of state change\n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this));\n  }\n};\n\n/**\n * Format date for input element\n */\nfunction formatDateForInput(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/**\n * Parse URL parameters\n */\nfunction parseUrlParams() {\n  const params = new URLSearchParams(window.location.search);\n  return {\n    stream: params.get('stream') || '',\n    date: params.get('date') || formatDateForInput(new Date())\n  };\n}\n\n/**\n * Update URL parameters\n */\nfunction updateUrlParams(stream, date) {\n  if (!stream) return;\n  const url = new URL(window.location.href);\n  url.searchParams.set('stream', stream);\n  url.searchParams.set('date', date);\n  window.history.replaceState({}, '', url);\n}\n\n/**\n * TimelinePage component\n */\nexport function TimelinePage() {\n  // Get initial values from URL parameters\n  const urlParams = parseUrlParams();\n\n  // State\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamsList, setStreamsList] = useState([]);\n  const [selectedStream, setSelectedStream] = useState(urlParams.stream);\n  const [selectedDate, setSelectedDate] = useState(urlParams.date);\n  const [segments, setSegments] = useState([]);\n\n  // Refs\n  const timelineContainerRef = useRef(null);\n  const initialLoadRef = useRef(false);\n\n  // Load streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery('streams', '/api/streams', {\n    timeout: 15000, // 15 second timeout\n    retries: 2,     // Retry twice\n    retryDelay: 1000 // 1 second between retries\n  });\n\n  // Handle initial data load when streams are available\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData) && streamsData.length > 0 && !initialLoadRef.current) {\n      console.log('TimelinePage: Streams loaded, initializing data');\n      initialLoadRef.current = true;\n\n      // Update streamsList state\n      setStreamsList(streamsData);\n\n      // Update global state for child components\n      timelineState.setState({ streams: streamsData });\n\n      // Check if the selected stream from URL exists\n      const streamExists = streamsData.some(s => s.name === selectedStream);\n\n      if (streamExists && selectedStream) {\n        console.log(`TimelinePage: Using stream from URL: ${selectedStream}`);\n      } else if (streamsData.length > 0) {\n        // Use first stream if URL stream doesn't exist\n        const firstStream = streamsData[0].name;\n        console.log(`TimelinePage: Using first stream: ${firstStream}`);\n        setSelectedStream(firstStream);\n      }\n    }\n  }, [streamsData]);\n\n  // Handle streams error\n  useEffect(() => {\n    if (streamsError) {\n      console.error('TimelinePage: Error loading streams:', streamsError);\n      showStatusMessage('Error loading streams: ' + streamsError.message, 'error');\n    }\n  }, [streamsError]);\n\n  // Calculate time range for timeline data\n  const getTimeRange = (date) => {\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n\n    const endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n\n    return {\n      startTime: startDate.toISOString(),\n      endTime: endDate.toISOString()\n    };\n  };\n\n  // Update URL and global state when stream or date changes\n  useEffect(() => {\n    if (selectedStream) {\n      // Update URL\n      updateUrlParams(selectedStream, selectedDate);\n\n      // Update global state\n      timelineState.setState({\n        selectedStream,\n        selectedDate\n      });\n    }\n  }, [selectedStream, selectedDate]);\n\n  // Get time range for current date\n  const { startTime, endTime } = getTimeRange(selectedDate);\n\n  // Fetch timeline segments using preact-query\n  const {\n    data: timelineData,\n    isLoading: isLoadingTimeline,\n    error: timelineError,\n    refetch: refetchTimeline\n  } = useQuery(\n    ['timeline-segments', selectedStream, selectedDate],\n    selectedStream ? `/api/timeline/segments?stream=${encodeURIComponent(selectedStream)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}` : null,\n    {\n      timeout: 30000, // 30 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    },\n    {\n      enabled: !!selectedStream, // Only run query if we have a selected stream\n      onSuccess: (data) => {\n        console.log('TimelinePage: Timeline data received:', data);\n        const timelineSegments = data.segments || [];\n        console.log(`TimelinePage: Received ${timelineSegments.length} segments`);\n\n        if (timelineSegments.length === 0) {\n          console.log('TimelinePage: No segments found');\n          setSegments([]);\n\n          // Update global state\n          timelineState.setState({\n            timelineSegments: [],\n            currentSegmentIndex: -1,\n            currentTime: null,\n            isPlaying: false\n          });\n\n          showStatusMessage('No recordings found for the selected date', 'warning');\n          return;\n        }\n\n        console.log('TimelinePage: Setting segments');\n        setSegments(timelineSegments);\n\n        // Update global state with the first segment selected\n        const initialTime = timelineSegments[0].start_timestamp;\n        timelineState.setState({\n          timelineSegments,\n          currentSegmentIndex: 0,\n          currentTime: initialTime,\n          prevCurrentTime: initialTime,\n          isPlaying: false\n        });\n\n        // Preload the first segment's video\n        const videoPlayer = document.querySelector('#video-player video');\n        if (videoPlayer) {\n          videoPlayer.src = `/api/recordings/play/${timelineSegments[0].id}`;\n          videoPlayer.load();\n        }\n\n        showStatusMessage(`Loaded ${timelineSegments.length} recording segments`, 'success');\n      },\n      onError: (error) => {\n        console.error('TimelinePage: Error loading timeline data:', error);\n        showStatusMessage('Error loading timeline data: ' + error.message, 'error');\n        setSegments([]);\n      }\n    }\n  );\n\n  // Handle stream selection change\n  const handleStreamChange = (e) => {\n    const newStream = e.target.value;\n    console.log(`TimelinePage: Stream changed to ${newStream}`);\n    setSelectedStream(newStream);\n  };\n\n  // Handle date selection change\n  const handleDateChange = (e) => {\n    const newDate = e.target.value;\n    console.log(`TimelinePage: Date changed to ${newDate}`);\n    setSelectedDate(newDate);\n  };\n\n  // Render content based on state\n  const renderContent = () => {\n    if (isLoadingTimeline) {\n      return html`<${LoadingIndicator} message=\"Loading timeline data...\" />`;\n    }\n\n    if (segments.length === 0) {\n      return html`\n        <div class=\"flex flex-col items-center justify-center py-12 text-center\">\n          <svg class=\"w-16 h-16 text-gray-400 dark:text-gray-600 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path>\n          </svg>\n          <p class=\"text-gray-600 dark:text-gray-400 text-lg\">No recordings found for the selected date and stream</p>\n        </div>\n      `;\n    }\n\n    return html`\n      <!-- Video player -->\n      <${TimelinePlayer} />\n\n      <!-- Playback controls -->\n      <${TimelineControls} />\n\n        <!-- Timeline -->\n        <div\n            id=\"timeline-container\"\n            class=\"relative w-full h-24 bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg mb-6 overflow-hidden\"\n            ref=${timelineContainerRef}\n        >\n          <${TimelineRuler} />\n          <${TimelineSegments} />\n          <${TimelineCursor} />\n\n          <!-- Instructions for cursor -->\n          <div class=\"absolute bottom-1 right-2 text-xs text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 px-2 py-1 rounded\">\n            Drag the orange dial to navigate\n          </div>\n        </div>\n    `;\n  };\n\n  return html`\n    <div class=\"timeline-page\">\n      <div class=\"flex items-center mb-4\">\n        <h1 class=\"text-2xl font-bold\">Timeline Playback</h1>\n        <div class=\"ml-4 flex\">\n          <a href=\"recordings.html\" class=\"px-3 py-1 bg-gray-300 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-l-md\">Table View</a>\n          <a href=\"timeline.html\" class=\"px-3 py-1 bg-blue-500 text-white rounded-r-md\">Timeline View</a>\n        </div>\n      </div>\n\n      <!-- Stream selector and date picker -->\n      <div class=\"flex flex-wrap gap-4 mb-2\">\n        <div class=\"stream-selector flex-grow\">\n          <div class=\"flex justify-between items-center mb-2\">\n            <label for=\"stream-selector\">Stream</label>\n            <button\n              class=\"text-xs bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 px-2 py-1 rounded\"\n              onClick=${() => refetchTimeline()}\n            >\n              Reload Data\n            </button>\n          </div>\n          <select\n              id=\"stream-selector\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedStream || ''}\n              onChange=${handleStreamChange}\n          >\n            <option value=\"\" disabled>Select a stream (${streamsList.length} available)</option>\n            ${streamsList.map(stream => html`\n              <option key=${stream.name} value=${stream.name}>${stream.name}</option>\n            `)}\n          </select>\n        </div>\n\n        <div class=\"date-selector flex-grow\">\n          <label for=\"timeline-date\" class=\"block mb-2\">Date</label>\n          <input\n              type=\"date\"\n              id=\"timeline-date\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedDate}\n              onChange=${handleDateChange}\n          />\n        </div>\n      </div>\n\n      <!-- Auto-load message -->\n      <div class=\"mb-4 text-sm text-gray-500 dark:text-gray-400 italic\">\n        ${isLoadingTimeline ? 'Loading...' : 'Recordings auto-load when stream or date changes'}\n      </div>\n\n      <!-- Current time display -->\n      <div class=\"flex justify-between items-center mb-2\">\n        <div id=\"time-display\" class=\"timeline-time-display bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded font-mono text-base\">00:00:00</div>\n      </div>\n\n      <!-- Debug info -->\n      <div class=\"mb-2 text-xs text-gray-500\">\n        Debug - isLoading: ${isLoadingTimeline ? 'true' : 'false'},\n        Streams: ${streamsList.length},\n        Segments: ${segments.length}\n      </div>\n\n      <!-- Content -->\n      ${renderContent()}\n\n      <!-- Instructions -->\n      <div class=\"mt-6 p-4 bg-gray-200 dark:bg-gray-800 rounded\">\n        <h3 class=\"text-lg font-semibold mb-2\">How to use the timeline:</h3>\n        <ul class=\"list-disc pl-5\">\n          <li>Select a stream and date to load recordings</li>\n          <li>Click on the timeline to seek to a specific time</li>\n          <li>Click on a segment (blue bar) to play that recording</li>\n          <li>Use the play/pause button to control playback</li>\n          <li>Use the zoom buttons to adjust the timeline scale</li>\n        </ul>\n      </div>\n    </div>\n  `;\n}\n\n// Export the timeline state for use in other components\nexport { timelineState };\n","/**\n * LightNVR Timeline View Component\n * Loads the Timeline page component into the main content area\n */\n\nimport { render } from 'preact';\nimport { html } from '../../../html-helper.js';\nimport { TimelinePage } from './TimelinePage.js';\nimport { QueryClientProvider, queryClient } from '../../../query-client.js';\n\n/**\n * Load TimelineView component\n */\nexport function loadTimelineView() {\n  const mainContent = document.getElementById('main-content');\n  if (!mainContent) return;\n\n  // Clear any existing content\n  mainContent.innerHTML = '';\n\n  // Render the TimelinePage component to the container wrapped with QueryClientProvider\n  render(\n    html`<${QueryClientProvider} client=${queryClient}>\n      <${TimelinePage} />\n    <//>`,\n    mainContent\n  );\n}"],"names":["TimelineControls","isPlaying","setIsPlaying","useState","zoomLevel","setZoomLevel","useEffect","unsubscribe","timelineState","state","_a","togglePlayback","pausePlayback","resumePlayback","videoPlayer","showStatusMessage","earliestSegmentIndex","earliestTimestamp","segment","index","error","zoomIn","newZoomLevel","zoomOut","html","_c","__template","_b","TimelineRuler","startHour","setStartHour","endHour","setEndHour","hoursPerView","centerHour","currentDate","earliestHour","latestHour","startTime","endTime","newStartHour","newEndHour","generateHourMarkers","markers","hour","position","_d","_e","halfHourPosition","_f","quarterHourPosition1","quarterHourPosition3","_g","_h","_i","TimelineSegments","segments","setSegments","currentSegmentIndex","setCurrentSegmentIndex","containerRef","useRef","isDragging","container","handleMouseDown","e","handleTimelineClick","handleMouseMove","handleMouseUp","event","rect","clickX","containerWidth","clickPercent","clickHour","clickDate","clickTimestamp","foundSegment","i","startTimestamp","endTimestamp","relativeTime","playSegment","closestSegment","minDistance","startDistance","endDistance","distance","absoluteTime","videoElement","seekTime","renderSegments","visibleSegments","hourMap","startHourFloat","endHourFloat","startFloorHour","endCeilHour","h","mergedSegments","currentMergedSegment","a","b","aStart","bStart","segmentStart","mergedEnd","mergedIndex","segStartTimestamp","segEndTimestamp","visibleStartHour","visibleEndHour","startPercent","widthPercent","duration","durationStr","startTimeStr","endTimeStr","_j","width","_k","_l","TimelineCursor","setPosition","visible","setVisible","currentTime","setCurrentTime","setIsDragging","cursorRef","dragStartXRef","updateTimeDisplay","updateCursorPosition","cursor","positionPercent","hourRange","date","timestamp","closestSegmentObj","time","startHr","endHr","timeDisplay","hours","minutes","seconds","_m","SpeedControls","currentSpeed","setCurrentSpeed","speeds","setPlaybackSpeed","speed","oldRate","_o","_n","TimelinePlayer","playbackSpeed","videoRef","lastTimeUpdateRef","lastSegmentIdRef","handleVideoPlayback","video","segmentChanged","needsReload","timeChanged","loadSegment","autoplay","recordingUrl","onLoadedMetadata","handleEnded","nextIndex","nextSegment","handleTimeUpdate","_p","newState","listener","formatDateForInput","year","month","day","parseUrlParams","params","updateUrlParams","stream","url","TimelinePage","urlParams","isLoading","setIsLoading","streamsList","setStreamsList","selectedStream","setSelectedStream","selectedDate","setSelectedDate","timelineContainerRef","initialLoadRef","streamsData","isLoadingStreams","streamsError","useQuery","s","firstStream","getTimeRange","startDate","endDate","timelineData","isLoadingTimeline","timelineError","refetchTimeline","data","timelineSegments","initialTime","handleStreamChange","newStream","handleDateChange","newDate","renderContent","_q","LoadingIndicator","_r","_s","_u","_t","loadTimelineView","mainContent","render","_v","QueryClientProvider","queryClient"],"mappings":"uQAeO,SAASA,IAAmB,CAEjC,KAAM,CAACC,EAAWC,CAAY,EAAIC,EAAS,EAAK,EAC1C,CAACC,EAAWC,CAAY,EAAIF,EAAS,CAAC,EAG5CG,EAAU,IAAM,CACd,QAAQ,IAAI,4DAA4D,EAExE,MAAMC,EAAcC,EAAc,UAAUC,GAAS,OACnD,QAAQ,IAAI,2CAA4CA,CAAK,EAC7D,QAAQ,IAAI,gCAAiCA,EAAM,SAAS,EAC5D,QAAQ,IAAI,gCAAiCA,EAAM,SAAS,EAC5D,QAAQ,IAAI,sCAAqCC,EAAAD,EAAM,mBAAN,YAAAC,EAAwB,SAAU,CAAC,EAEpFR,EAAaO,EAAM,SAAS,EAC5BJ,EAAaI,EAAM,SAAS,CAClC,CAAK,EAGD,eAAQ,IAAI,2CAA4CD,CAAa,EAE9D,IAAMD,EAAa,CAC3B,EAAE,EAAE,EAGL,MAAMI,EAAiB,IAAM,CACvBV,EACFW,EAAe,EAEfC,EAAgB,CAEnB,EAGKD,EAAgB,IAAM,CAC1BJ,EAAc,SAAS,CAAE,UAAW,EAAK,CAAE,EAG3C,MAAMM,EAAc,SAAS,cAAc,qBAAqB,EAC5DA,GACFA,EAAY,MAAO,CAEtB,EAGKD,EAAiB,IAAM,CAE3B,GAAI,CAACL,EAAc,kBAAoBA,EAAc,iBAAiB,SAAW,EAAG,CAClFO,EAAkB,wBAAyB,SAAS,EACpD,MACN,CAGI,IAAIC,EAAuB,EACvBC,EAAoB,OAAO,iBAE/BT,EAAc,iBAAiB,QAAQ,CAACU,EAASC,IAAU,CACrDD,EAAQ,gBAAkBD,IAC5BA,EAAoBC,EAAQ,gBAC5BF,EAAuBG,EAE/B,CAAK,EAED,QAAQ,IAAI,yCAAyC,OAAAH,EAAoB,IAAG,EAG5ER,EAAc,SAAS,CACrB,oBAAqBQ,EACrB,YAAaR,EAAc,iBAAiBQ,CAAoB,EAAE,gBAClE,UAAW,GACX,YAAa,EACnB,CAAK,EAGD,MAAME,EAAUV,EAAc,iBAAiBQ,CAAoB,EAC7DF,EAAc,SAAS,cAAc,qBAAqB,EAE5DA,IACF,QAAQ,IAAI,kCAAmCI,CAAO,EAGtDJ,EAAY,MAAO,EAGnBA,EAAY,gBAAgB,KAAK,EACjCA,EAAY,KAAM,EAGlBA,EAAY,IAAM,wBAAwB,OAAAI,EAAQ,GAAE,OAAM,YAAK,IAAG,GAGlEJ,EAAY,iBAAmB,IAAM,CACnCA,EAAY,YAAc,EAC1BA,EAAY,KAAI,EAAG,MAAMM,GAAS,CAChC,QAAQ,MAAM,uBAAwBA,CAAK,EAC3CL,EAAkB,wBAA0BK,EAAM,QAAS,OAAO,CAC5E,CAAS,CACF,EAEJ,EAaKC,EAAS,IAAM,CACnB,GAAIjB,EAAY,EAAG,CACjB,MAAMkB,EAAelB,EAAY,EACjCI,EAAc,SAAS,CAAE,UAAWc,CAAY,CAAE,EAClDP,EAAkB,cAAc,UAAKO,EAAY,eAAe,MAAM,CAC5E,CACG,EAGKC,EAAU,IAAM,CACpB,GAAInB,EAAY,EAAG,CACjB,MAAMkB,EAAelB,EAAY,EACjCI,EAAc,SAAS,CAAE,UAAWc,CAAY,CAAE,EAClDP,EAAkB,eAAe,UAAKO,EAAY,eAAe,MAAM,CAC7E,CACG,EAED,OAAOE,EAAAC,MAAIC,EAAA,0ZAMqB,qBACoC,sJAatE,wjBAW2B,qEAEQ,ukBAST,oEAES,oWAtCff,EACFV,EAAY,QAAU,+BAG1BA,EACEuB,EAAAd,MAAIgB,EAAA,kPAKJF,EAAAG,MAAID,EAAA,wIAeAH,EAECnB,GAAa,EASdiB,EAECjB,GAAa,EASlC,oBCzLO,SAASwB,IAAgB,CAE9B,KAAM,CAACC,EAAWC,CAAY,EAAI3B,EAAS,CAAC,EACtC,CAAC4B,EAASC,CAAU,EAAI7B,EAAS,EAAE,EACnC,CAACC,EAAWC,CAAY,EAAIF,EAAS,CAAC,EAG5CG,EAAU,IAAM,CACd,QAAQ,IAAI,yDAAyD,EAErE,MAAMC,EAAcC,EAAc,UAAUC,GAAS,CACnD,QAAQ,IAAI,wCAAyCA,CAAK,EAC1D,QAAQ,IAAI,6BAA8BA,EAAM,SAAS,EAGzD,MAAMwB,EAAe,GAAKxB,EAAM,UAChC,QAAQ,IAAI,iCAAkCwB,CAAY,EAG1D,IAAIC,EAAa,GAEjB,GAAIzB,EAAM,cAAgB,KAAM,CAE9B,MAAM0B,EAAc,IAAI,KAAK1B,EAAM,YAAc,GAAI,EACrDyB,EAAaC,EAAY,SAAU,EAAIA,EAAY,aAAe,GAAOA,EAAY,WAAU,EAAK,IAC5G,SAAiB1B,EAAM,kBAAoBA,EAAM,iBAAiB,OAAS,EAAG,CAEtE,IAAI2B,EAAe,GACfC,EAAa,EAEjB5B,EAAM,iBAAiB,QAAQS,GAAW,CACxC,MAAMoB,EAAY,IAAI,KAAKpB,EAAQ,gBAAkB,GAAI,EACnDqB,EAAU,IAAI,KAAKrB,EAAQ,cAAgB,GAAI,EAE/CW,EAAYS,EAAU,SAAQ,EAAMA,EAAU,aAAe,GAAOA,EAAU,WAAU,EAAK,KAC7FP,EAAUQ,EAAQ,SAAQ,EAAMA,EAAQ,aAAe,GAAOA,EAAQ,WAAU,EAAK,KAE3FH,EAAe,KAAK,IAAIA,EAAcP,CAAS,EAC/CQ,EAAa,KAAK,IAAIA,EAAYN,CAAO,CACnD,CAAS,EAEDG,GAAcE,EAAeC,GAAc,CACnD,CAGM,IAAIG,EAAe,KAAK,IAAI,EAAGN,EAAcD,EAAe,CAAE,EAC1DQ,EAAa,KAAK,IAAI,GAAID,EAAeP,CAAY,EAGrDQ,IAAe,IAAMR,EAAe,IACtCO,EAAe,KAAK,IAAI,EAAG,GAAKP,CAAY,EAC5CQ,EAAa,IACJD,IAAiB,GAAKP,EAAe,KAC9CQ,EAAa,KAAK,IAAI,GAAIR,CAAY,GAGxC,QAAQ,IAAI,iCAAkC,CAAE,aAAAO,EAAc,WAAAC,CAAU,CAAE,EAG1EX,EAAaU,CAAY,EACzBR,EAAWS,CAAU,EACrBpC,EAAaI,EAAM,SAAS,GAIxBD,EAAc,oBAAsBgC,GACpChC,EAAc,kBAAoBiC,IACpCjC,EAAc,SAAS,CACrB,kBAAmBgC,EACnB,gBAAiBC,CAC3B,CAAS,CAET,CAAK,EAED,MAAO,IAAMlC,EAAa,CAC3B,EAAE,EAAE,EAGL,MAAMmC,EAAsB,IAAM,CAChC,MAAMC,EAAU,CAAE,EAIlB,QAASC,EAAO,KAAK,MAAMf,CAAS,EAAGe,GAAQ,KAAK,KAAKb,CAAO,EAAGa,IACjE,GAAIA,GAAQ,GAAKA,GAAQ,GAAI,CAC3B,MAAMC,GAAaD,EAAOf,IAAcE,EAAUF,GAAc,IAuBhE,GApBAc,EAAQ,KAAKnB,EAAAsB,MAAIpB,EAAA,6CAEG,2GAEO,sCAFXkB,EAEGC,EAElB,EAGDF,EAAQ,KAAKnB,EAAAuB,MAAIrB,EAAA,8CAEI,yIAEM,iCAEjB,qCAJOkB,EAEEC,EAEbD,EAEL,EAGGA,EAAO,IAAMxC,GAAa,EAAG,CAC/B,MAAM4C,GAAqBJ,EAAO,GAAMf,IAAcE,EAAUF,GAAc,IAU9E,GATAc,EAAQ,KAAKnB,EAAAyB,MAAIvB,EAAA,iDAEG,kHAEe,0CAFnBkB,EAEGI,EAElB,EAGG5C,GAAa,EAAG,CAClB,MAAM8C,GAAyBN,EAAO,IAAOf,IAAcE,EAAUF,GAAc,IAC7EsB,GAAyBP,EAAO,IAAOf,IAAcE,EAAUF,GAAc,IAEnFc,EAAQ,KAAKnB,EAAA4B,QAAI1B,EAAA,qDAEG,sHAEmB,8CAFvBkB,EAEGM,EAElB,EAEDP,EAAQ,KAAKnB,EAAA6B,QAAI3B,EAAA,qDAEG,sHAEmB,8CAFvBkB,EAEGO,EAElB,CACb,CACA,CACA,CAGI,OAAOR,CACR,EAED,OAAOnB,EAAA8B,QAAI5B,EAAA,6IAEgB,4FAEJ,MAAgC,2CAFjDgB,EAAqB,EAEbtC,EAAe,KAAK,MAAM,GAAKA,CAAS,EAIxD,cC1JO,SAASmD,IAAmB,CAEjC,KAAM,CAACC,EAAUC,CAAW,EAAItD,EAAS,CAAA,CAAE,EACrC,CAAC0B,EAAWC,CAAY,EAAI3B,EAAS,CAAC,EACtC,CAAC4B,EAASC,CAAU,EAAI7B,EAAS,EAAE,EACnC,CAACuD,EAAqBC,CAAsB,EAAIxD,EAAS,EAAE,EAG3DyD,EAAeC,EAAO,IAAI,EAC1BC,EAAaD,EAAO,EAAK,EAG/BvD,EAAU,IAAM,CACd,QAAQ,IAAI,4DAA4D,EAExE,MAAMC,EAAcC,EAAc,UAAUC,GAAS,CACnD,QAAQ,IAAI,yCAAyC,EAGjDA,EAAM,mBACR,QAAQ,IAAI,wCAAwC,OAAAA,EAAM,iBAAiB,OAAM,IAAG,EACpFgD,EAAYhD,EAAM,gBAAgB,GAIpCqB,EAAarB,EAAM,mBAAqB,CAAC,EACzCuB,EAAWvB,EAAM,iBAAmB,EAAE,EACtCkD,EAAuBlD,EAAM,qBAAuB,EAAE,CAC5D,CAAK,EAGD,OAAID,EAAc,kBAAoBA,EAAc,iBAAiB,OAAS,IAC5E,QAAQ,IAAI,iDAAiD,OAAAA,EAAc,iBAAiB,OAAM,IAAG,EACrGiD,EAAYjD,EAAc,gBAAgB,EAC1CmD,EAAuBnD,EAAc,qBAAuB,CAAC,GAGxD,IAAMD,EAAa,CAC3B,EAAE,EAAE,EAGLD,EAAU,IAAM,CACd,MAAMyD,EAAYH,EAAa,QAC/B,GAAI,CAACG,EAAW,OAEhB,MAAMC,EAAmBC,GAAM,EAEzBA,EAAE,SAAWF,GAAaE,EAAE,OAAO,UAAU,SAAS,yBAAyB,KACjFH,EAAW,QAAU,GACrBI,EAAoBD,CAAC,EAGrB,SAAS,iBAAiB,YAAaE,CAAe,EACtD,SAAS,iBAAiB,UAAWC,CAAa,EAErD,EAEKD,EAAmBF,GAAM,CACxBH,EAAW,SAChBI,EAAoBD,CAAC,CACtB,EAEKG,EAAgB,IAAM,CAC1BN,EAAW,QAAU,GACrB,SAAS,oBAAoB,YAAaK,CAAe,EACzD,SAAS,oBAAoB,UAAWC,CAAa,CACtD,EAED,OAAAL,EAAU,iBAAiB,YAAaC,CAAe,EAEhD,IAAM,CACXD,EAAU,oBAAoB,YAAaC,CAAe,EAC1D,SAAS,oBAAoB,YAAaG,CAAe,EACzD,SAAS,oBAAoB,UAAWC,CAAa,CACtD,CACF,EAAE,CAACvC,EAAWE,EAASyB,CAAQ,CAAC,EAGjC,MAAMU,EAAuBG,GAAU,CACrC,MAAMN,EAAYH,EAAa,QAC/B,GAAI,CAACG,EAAW,OAGhB,MAAMO,EAAOP,EAAU,sBAAuB,EACxCQ,EAASF,EAAM,QAAUC,EAAK,KAC9BE,EAAiBF,EAAK,MAGtBG,EAAeF,EAASC,EACxBE,EAAY7C,EAAa4C,GAAgB1C,EAAUF,GAGnD8C,EAAY,IAAI,KAAKnE,EAAc,YAAY,EACrDmE,EAAU,SAAS,KAAK,MAAMD,CAAS,CAAC,EACxCC,EAAU,WAAW,KAAK,MAAOD,EAAY,EAAK,EAAE,CAAC,EACrDC,EAAU,WAAW,KAAK,MAAQD,EAAY,EAAK,GAAM,EAAI,EAAE,CAAC,EAEhE,MAAME,EAAiBD,EAAU,QAAO,EAAK,IAG7C,IAAIE,EAAe,GACnB,QAASC,EAAI,EAAGA,EAAItB,EAAS,OAAQsB,IAAK,CACxC,MAAM5D,EAAUsC,EAASsB,CAAC,EAEpBC,EAAiB7D,EAAQ,uBAAyBA,EAAQ,gBAC1D8D,EAAe9D,EAAQ,qBAAuBA,EAAQ,cAE5D,GAAI0D,GAAkBG,GAAkBH,GAAkBI,EAAc,CACtE,QAAQ,IAAI,mCAAmC,OAAAF,EAAC,wBAAuB,EAGvE,MAAMG,EAAeL,EAAiBG,EAGtCpB,EAAuBmB,CAAC,EAGxBI,EAAYJ,EAAGG,CAAY,EAC3BJ,EAAe,GACf,KACR,CACA,CAEI,GAAI,CAACA,EACH,GAAIrB,EAAS,OAAS,EAAG,CACvB,QAAQ,IAAI,8EAA8E,EAE1F,IAAI2B,EAAiB,GACjBC,EAAc,IAElB,QAASN,EAAI,EAAGA,EAAItB,EAAS,OAAQsB,IAAK,CACxC,MAAM5D,EAAUsC,EAASsB,CAAC,EAEpBC,EAAiB7D,EAAQ,uBAAyBA,EAAQ,gBAC1D8D,EAAe9D,EAAQ,qBAAuBA,EAAQ,cAEtDmE,EAAgB,KAAK,IAAIN,EAAiBH,CAAc,EACxDU,EAAc,KAAK,IAAIN,EAAeJ,CAAc,EACpDW,EAAW,KAAK,IAAIF,EAAeC,CAAW,EAEhDC,EAAWH,IACbA,EAAcG,EACdJ,EAAiBL,EAE7B,CAEYK,GAAkB,IACpB,QAAQ,IAAI,6CAA6C,OAAAA,EAAgB,EAGzED,EAAYC,CAAc,EAEpC,MAEQ,QAAQ,IAAI,gEAAgE,EAC5E3E,EAAc,SAAS,CACrB,YAAaoE,EACb,gBAAiBpE,EAAc,WACzC,CAAS,CAGN,EAGK0E,EAAc,CAAC/D,EAAO8D,EAAe,OAAS,CAGlD,GAFA,QAAQ,IAAI,iCAAiC,OAAA9D,EAAK,MAAK,OAAA8D,EAAY,IAAG,EAElE9D,EAAQ,GAAKA,GAASqC,EAAS,OAAQ,CACzC,QAAQ,KAAK,4CAA4C,OAAArC,EAAO,EAChE,MACN,CAEI,MAAMD,EAAUsC,EAASrC,CAAK,EAGxB4D,EAAiB7D,EAAQ,uBAAyBA,EAAQ,gBAG1DsE,EAAeP,IAAiB,KAClCF,EAAiBE,EACjBF,EAGJvE,EAAc,SAAS,CACrB,UAAW,GACX,oBAAqB,EAC3B,CAAK,EAGD,SAAS,KAAK,aAGd,WAAW,IAAM,CACfA,EAAc,SAAS,CACrB,oBAAqBW,EACrB,YAAaqE,EACb,UAAW,GACX,YAAa,EACrB,CAAO,EAGD,WAAW,IAAM,CACf,MAAMC,EAAe,SAAS,cAAc,qBAAqB,EAC7DA,IAEFA,EAAa,MAAO,EAGpBA,EAAa,gBAAgB,KAAK,EAClCA,EAAa,KAAM,EAGnBA,EAAa,IAAM,wBAAwB,OAAAvE,EAAQ,GAAE,OAAM,YAAK,IAAG,GAGnEuE,EAAa,iBAAmB,IAAM,CACpC,MAAMC,EAAWT,IAAiB,KAAOA,EAAe,EACxDQ,EAAa,YAAcC,EAC3BD,EAAa,KAAM,EAAC,MAAMxB,GAAK,QAAQ,MAAM,uBAAwBA,CAAC,CAAC,CACxE,EAEJ,EAAE,EAAE,CACN,EAAE,EAAE,CACN,EAGK0B,EAAiB,IAAM,CAG3B,GAFA,QAAQ,IAAI,+BAA+B,OAAAnC,EAAS,OAAM,YAAW,EAEjE,CAACA,GAAYA,EAAS,SAAW,EACnC,OAAO,KAGT,MAAMoC,EAAkB,CAAE,EACpBC,EAAU,IAAI,IAGpBrC,EAAS,QAAQ,CAACtC,EAASC,IAAU,CAEnC,MAAM4D,EAAiB7D,EAAQ,uBAAyBA,EAAQ,gBAC1D8D,EAAe9D,EAAQ,qBAAuBA,EAAQ,cAGtDoB,EAAY,IAAI,KAAKyC,EAAiB,GAAI,EAC1CxC,EAAU,IAAI,KAAKyC,EAAe,GAAI,EAGtCc,EAAiBxD,EAAU,SAAQ,EAAMA,EAAU,aAAe,GAAOA,EAAU,WAAU,EAAK,KAClGyD,EAAexD,EAAQ,SAAQ,EAAMA,EAAQ,aAAe,GAAOA,EAAQ,WAAU,EAAK,KAGhG,GAAIwD,EAAelE,GAAaiE,EAAiB/D,EAC/C,OAIF,MAAMiE,EAAiB,KAAK,MAAMF,CAAc,EAC1CG,EAAc,KAAK,IAAI,KAAK,KAAKF,CAAY,EAAG,EAAE,EAExD,QAASG,EAAIF,EAAgBE,EAAID,EAAaC,IACxCA,GAAKrE,GAAaqE,GAAKnE,IACpB8D,EAAQ,IAAIK,CAAC,GAChBL,EAAQ,IAAIK,EAAG,EAAE,EAEnBL,EAAQ,IAAIK,CAAC,EAAE,KAAK/E,CAAK,EAGnC,CAAK,EAGD,MAAMgF,EAAiB,CAAE,EACzB,IAAIC,EAAuB,KAGJ,CAAC,GAAG5C,CAAQ,EAAE,KAAK,CAAC6C,EAAGC,IAAM,CAClD,MAAMC,EAASF,EAAE,uBAAyBA,EAAE,gBACtCG,EAASF,EAAE,uBAAyBA,EAAE,gBAC5C,OAAOC,EAASC,CACtB,CAAK,EAGc,QAAQ,CAACtF,EAASC,IAAU,CACzC,GAAI,CAACiF,EAEHA,EAAuB,CAAE,GAAGlF,EAAS,gBAAiB,CAACC,CAAK,CAAG,MAC1D,CAGL,MAAMsF,EAAevF,EAAQ,uBAAyBA,EAAQ,gBACxDwF,EAAYN,EAAqB,qBAAuBA,EAAqB,cAGvEK,EAAeC,GAEhB,GAGTN,EAAqB,cAAgBlF,EAAQ,cACzCA,EAAQ,sBACVkF,EAAqB,oBAAsBlF,EAAQ,qBAErDkF,EAAqB,gBAAgB,KAAKjF,CAAK,EAG3CD,EAAQ,gBACVkF,EAAqB,cAAgB,MAIvCD,EAAe,KAAKC,CAAoB,EACxCA,EAAuB,CAAE,GAAGlF,EAAS,gBAAiB,CAACC,CAAK,CAAG,EAEzE,CACA,CAAK,EAGGiF,GACFD,EAAe,KAAKC,CAAoB,EAG1C,QAAQ,IAAI,4BAA4B,OAAA5C,EAAS,OAAM,mBAAkB,OAAA2C,EAAe,OAAM,YAAW,EAGzGA,EAAe,QAAQ,CAACjF,EAASyF,IAAgB,CAE/C,MAAMC,EAAoB1F,EAAQ,uBAAyBA,EAAQ,gBAC7D2F,EAAkB3F,EAAQ,qBAAuBA,EAAQ,cAGzDoB,EAAY,IAAI,KAAKsE,EAAoB,GAAI,EAC7CrE,EAAU,IAAI,KAAKsE,EAAkB,GAAI,EAGzCf,EAAiBxD,EAAU,SAAQ,EAAMA,EAAU,aAAe,GAAOA,EAAU,WAAU,EAAK,KAClGyD,EAAexD,EAAQ,SAAQ,EAAMA,EAAQ,aAAe,GAAOA,EAAQ,WAAU,EAAK,KAGhG,GAAIwD,EAAelE,GAAaiE,EAAiB/D,EAC/C,OAIF,MAAM+E,EAAmB,KAAK,IAAIhB,EAAgBjE,CAAS,EACrDkF,EAAiB,KAAK,IAAIhB,EAAchE,CAAO,EAG/CiF,GAAiBF,EAAmBjF,IAAcE,EAAUF,GAAc,IAC1EoF,GAAiBF,EAAiBD,IAAqB/E,EAAUF,GAAc,IAG/EqF,EAAW,KAAK,MAAML,EAAkBD,CAAiB,EACzDO,EAAc,GAAG,OAAAD,EAAQ,KAGzBE,EAAe9E,EAAU,mBAAoB,EAC7C+E,EAAa9E,EAAQ,mBAAoB,EAK/CqD,EAAgB,KAAKpE,EAAA8F,QAAI5F,EAAA,4CAEK,wFACoG,6BACnG,aAAyB,cAA2B,gEAC1D,MAAgB,KAAgB,iCAHtCiF,EAC2DzF,EAAQ,cAAgB,aAAe,cAClG8F,EAAyBC,EANtB,GAOTG,EAAkBC,EAAeF,EAE7C,CACP,CAAK,EAGD,QAASvE,EAAO,KAAK,MAAMf,CAAS,EAAGe,EAAO,KAAK,KAAKb,CAAO,EAAGa,IAChE,GAAI,CAACiD,EAAQ,IAAIjD,CAAI,EAAG,CAEtB,MAAMC,GAAaD,EAAOf,IAAcE,EAAUF,GAAc,IAC1D0F,EAAQ,KAAOxF,EAAUF,GAE/B+D,EAAgB,KAAKpE,EAAAgG,QAAI9F,EAAA,kDAEA,2GAEE,aAAkB,8BACzB,mCAHCkB,EAEFC,EAAqB0E,EACxB3E,EAEf,CACT,CAGI,OAAOgD,CACR,EAED,OAAOpE,EAAAiG,QAAI/F,EAAA,sFAGW,kBAEA,sBAFZkC,EAEJ+B,EAAgB,EAGxB,QC9YO,SAAS+B,IAAiB,CAE/B,KAAM,CAAC7E,EAAU8E,CAAW,EAAIxH,EAAS,CAAC,EACpC,CAACyH,EAASC,CAAU,EAAI1H,EAAS,EAAK,EACtC,CAAC0B,EAAWC,CAAY,EAAI3B,EAAS,CAAC,EACtC,CAAC4B,EAASC,CAAU,EAAI7B,EAAS,EAAE,EACnC,CAAC2H,EAAaC,CAAc,EAAI5H,EAAS,IAAI,EAC7C,CAAC2D,EAAYkE,CAAa,EAAI7H,EAAS,EAAK,EAG5C8H,EAAYpE,EAAO,IAAI,EACRA,EAAO,IAAI,EAChC,MAAMqE,EAAgBrE,EAAO,CAAC,EAG9BvD,EAAU,IAAM,CACd,MAAMC,EAAcC,EAAc,UAAUC,GAAS,CAEnDqB,EAAarB,EAAM,mBAAqB,CAAC,EACzCuB,EAAWvB,EAAM,iBAAmB,EAAE,EACtCsH,EAAetH,EAAM,WAAW,EAGhC0H,EAAkB1H,EAAM,WAAW,EAG9BqD,GACHsE,EAAqB3H,EAAM,YAAaA,EAAM,mBAAqB,EAAGA,EAAM,iBAAmB,EAAE,CAEzG,CAAK,EAED,MAAO,IAAMF,EAAa,CAC9B,EAAK,CAACuD,CAAU,CAAC,EAGfxD,EAAU,IAAM,CACd,MAAM+H,EAASJ,EAAU,QACzB,GAAI,CAACI,EAAQ,OAEb,MAAMrE,EAAmBC,GAAM,CAC7BA,EAAE,eAAgB,EAClBA,EAAE,gBAAiB,EAGnBiE,EAAc,QAAUjE,EAAE,QAE1B+D,EAAc,EAAI,EAGlB,SAAS,iBAAiB,YAAa7D,CAAe,EACtD,SAAS,iBAAiB,UAAWC,CAAa,CACnD,EAEKD,EAAmBF,GAAM,CAC7B,GAAI,CAACH,EAAY,OAGjB,MAAMC,EAAYsE,EAAO,cACzB,GAAI,CAACtE,EAAW,OAEhB,MAAMO,EAAOP,EAAU,sBAAuB,EACxCQ,EAAS,KAAK,IAAI,EAAG,KAAK,IAAIN,EAAE,QAAUK,EAAK,KAAMA,EAAK,KAAK,CAAC,EAChEE,EAAiBF,EAAK,MAGtBgE,EAAmB/D,EAASC,EAAkB,IACpDmD,EAAYW,CAAe,EAG3B,MAAMC,EAAYxG,EAAUF,EACtBe,EAAOf,EAAayG,EAAkB,IAAOC,EAG7CC,EAAO,IAAI,KAAKhI,EAAc,YAAY,EAChDgI,EAAK,SAAS,KAAK,MAAM5F,CAAI,CAAC,EAC9B4F,EAAK,WAAW,KAAK,MAAO5F,EAAO,EAAK,EAAE,CAAC,EAC3C4F,EAAK,WAAW,KAAK,MAAQ5F,EAAO,EAAK,GAAM,EAAI,EAAE,CAAC,EAEtD,MAAM6F,EAAYD,EAAK,QAAO,EAAK,IAGnCL,EAAkBM,CAAS,CAC5B,EAEKrE,EAAiBH,GAAM,CAC3B,GAAI,CAACH,EAAY,OAGjB,MAAMC,EAAYsE,EAAO,cACzB,GAAI,CAACtE,EAAW,OAEhB,MAAMO,EAAOP,EAAU,sBAAuB,EACxCQ,EAAS,KAAK,IAAI,EAAG,KAAK,IAAIN,EAAE,QAAUK,EAAK,KAAMA,EAAK,KAAK,CAAC,EAChEE,EAAiBF,EAAK,MAGtBgE,EAAmB/D,EAASC,EAAkB,IAG9C+D,EAAYxG,EAAUF,EACtBe,EAAOf,EAAayG,EAAkB,IAAOC,EAG7CC,EAAO,IAAI,KAAKhI,EAAc,YAAY,EAChDgI,EAAK,SAAS,KAAK,MAAM5F,CAAI,CAAC,EAC9B4F,EAAK,WAAW,KAAK,MAAO5F,EAAO,EAAK,EAAE,CAAC,EAC3C4F,EAAK,WAAW,KAAK,MAAQ5F,EAAO,EAAK,GAAM,EAAI,EAAE,CAAC,EAEtD,MAAM6F,EAAYD,EAAK,QAAO,EAAK,IAGnCR,EAAc,EAAK,EAGnB,SAAS,oBAAoB,YAAa7D,CAAe,EACzD,SAAS,oBAAoB,UAAWC,CAAa,EAGrD,MAAMZ,EAAWhD,EAAc,kBAAoB,CAAE,EACrD,IAAIqE,EAAe,GAEnB,QAASC,EAAI,EAAGA,EAAItB,EAAS,OAAQsB,IAAK,CACxC,MAAM5D,EAAUsC,EAASsB,CAAC,EAEpBC,EAAiB7D,EAAQ,uBAAyBA,EAAQ,gBAC1D8D,EAAe9D,EAAQ,qBAAuBA,EAAQ,cAE5D,GAAIuH,GAAa1D,GAAkB0D,GAAazD,EAAc,CAK5DxE,EAAc,SAAS,CACrB,oBAAqBsE,EACrB,YAAa2D,EACb,gBAAiBjI,EAAc,YAC/B,UAAW,EACvB,CAAW,EAEDqE,EAAe,GACf,KACV,CACA,CAGM,GAAI,CAACA,GAAgBrB,EAAS,OAAS,EAAG,CACxC,IAAI2B,EAAiB,EACjBC,EAAc,IAElB,QAASN,EAAI,EAAGA,EAAItB,EAAS,OAAQsB,IAAK,CACxC,MAAM5D,EAAUsC,EAASsB,CAAC,EAEpBC,GAAiB7D,EAAQ,uBAAyBA,EAAQ,gBAC1D8D,GAAe9D,EAAQ,qBAAuBA,EAAQ,cAEtDmE,GAAgB,KAAK,IAAIN,GAAiB0D,CAAS,EACnDnD,GAAc,KAAK,IAAIN,GAAeyD,CAAS,EAC/ClD,EAAW,KAAK,IAAIF,GAAeC,EAAW,EAEhDC,EAAWH,IACbA,EAAcG,EACdJ,EAAiBL,EAE7B,CAGQ,MAAM4D,EAAoBlF,EAAS2B,CAAc,EAC3CJ,EAAiB2D,EAAkB,uBAAyBA,EAAkB,gBAGpFlI,EAAc,SAAS,CACrB,oBAAqB2E,EACrB,YAAaJ,EACb,gBAAiBvE,EAAc,YAC/B,UAAW,EACrB,CAAS,CACT,CACK,EAGD,OAAA6H,EAAO,iBAAiB,YAAarE,CAAe,EAE7C,IAAM,CACXqE,EAAO,oBAAoB,YAAarE,CAAe,EACvD,SAAS,oBAAoB,YAAaG,CAAe,EACzD,SAAS,oBAAoB,UAAWC,CAAa,CACtD,CACL,EAAK,CAAC6D,EAAU,QAASpG,EAAWE,EAAS+B,CAAU,CAAC,EAGtD,MAAMsE,EAAuB,CAACO,EAAMC,EAASC,IAAU,CACrD,GAAIF,IAAS,KAAM,CACjBd,EAAW,EAAK,EAChB,MACN,CAGI,MAAMW,EAAO,IAAI,KAAKG,EAAO,GAAI,EAC3B/F,EAAO4F,EAAK,SAAQ,EAAMA,EAAK,aAAe,GAAOA,EAAK,WAAU,EAAK,KAG/E,GAAI5F,EAAOgG,GAAWhG,EAAOiG,EAAO,CAClChB,EAAW,EAAK,EAChB,MACN,CAGI,MAAMhF,GAAaD,EAAOgG,IAAYC,EAAQD,GAAY,IAG1DjB,EAAY9E,CAAQ,EACpBgF,EAAW,EAAI,CAChB,EAGKM,EAAqBQ,GAAS,CAClC,GAAIA,IAAS,KAAM,OAEnB,MAAMG,EAAc,SAAS,eAAe,cAAc,EAC1D,GAAI,CAACA,EAAa,OAElB,MAAMN,EAAO,IAAI,KAAKG,EAAO,GAAI,EAG3BI,EAAQP,EAAK,SAAU,EAAC,SAAQ,EAAG,SAAS,EAAG,GAAG,EAClDQ,EAAUR,EAAK,WAAY,EAAC,SAAQ,EAAG,SAAS,EAAG,GAAG,EACtDS,EAAUT,EAAK,WAAY,EAAC,SAAQ,EAAG,SAAS,EAAG,GAAG,EAG5DM,EAAY,YAAc,GAAG,OAAAC,EAAK,KAAI,OAAAC,EAAO,KAAI,OAAAC,EAClD,EAGD3I,OAAAA,EAAU,IAAM,CAEd,WAAW,IAAM,CACXE,EAAc,cAChBqH,EAAW,EAAI,EACfO,EACE5H,EAAc,YACdA,EAAc,mBAAqB,EACnCA,EAAc,iBAAmB,EAClC,EAEJ,EAAE,GAAG,CACP,EAAE,EAAE,EAEEgB,EAAA0H,QAAIxH,EAAA,2BAEQ,+HAEQ,eAAyC,mxBAF1DuG,EAESpF,EAAuB+E,EAAU,QAAU,OAehE,WCzQO,SAASuB,IAAgB,CAE9B,KAAM,CAACC,EAAcC,CAAe,EAAIlJ,EAAS,CAAG,EAG9CmJ,EAAS,CAAC,IAAM,GAAK,EAAK,IAAK,EAAK,CAAG,EAG7ChJ,EAAU,IAAM,CACd,QAAQ,IAAI,yDAAyD,EAErE,MAAMC,EAAcC,EAAc,UAAUC,GAAS,CACnD,QAAQ,IAAI,wCAAyCA,CAAK,EAC1D,QAAQ,IAAI,iCAAkCA,EAAM,aAAa,EAEjE4I,EAAgB5I,EAAM,aAAa,CACzC,CAAK,EAGD,eAAQ,IAAI,wCAAyCD,CAAa,EAE3D,IAAMD,EAAa,CAC3B,EAAE,EAAE,EAGL,MAAMgJ,EAAoBC,GAAU,CAElC,MAAM1I,EAAc,SAAS,cAAc,qBAAqB,EAChE,GAAIA,EAAa,CAEf,MAAM2I,EAAU3I,EAAY,aAG5BA,EAAY,aAAe0I,EAE3B,QAAQ,IAAI,oCAAoC,OAAAC,EAAO,SAAQ,OAAAD,EAAK,KAAK1I,CAAW,EACpF,QAAQ,IAAI,uCAAuC,OAAAA,EAAY,aAAY,IAAG,EAG9E,WAAW,IAAM,CACfA,EAAY,aAAe0I,EAC3B,QAAQ,IAAI,+BAA+B,OAAAA,EAAK,oBAAmB,OAAA1I,EAAY,aAAY,IAAG,CAC/F,EAAE,GAAG,CACZ,MACM,QAAQ,KAAK,gCAAgC,EAI/CN,EAAc,SAAS,CAAE,cAAegJ,CAAK,CAAE,EAG/CzI,EAAkB,mBAAmB,OAAAyI,EAAK,KAAK,MAAM,CACtD,EAED,OAAOhI,EAAAkI,QAAIhI,EAAA,oVAkBD,qIAIqB,KAA2C,oDAhBhE4H,EAAO,IAAIE,GAAShI,EAAAmI,QAAIjI,EAAA,8CAEA,yBAIkF,8BACtF,2BACqB,kCAEM,yCARvC,SAAS,OAAA8H,GACP,4CAA4C,OAAAA,IAAUJ,EAC1D,0BACA,2FAA0F,4HAEjFI,EACH,IAAMD,EAAiBC,CAAK,EAEpCA,IAAU,EAAM,cAAgB,GAAG,OAAAA,EAAK,KAE7C,EAIUJ,EAAiBA,IAAiB,EAAM,WAAa,GAK1E,QChFO,SAASQ,IAAiB,CAE/B,KAAM,CAAClG,EAAqBC,CAAsB,EAAIxD,EAAS,EAAE,EAC3D,CAACF,EAAWC,CAAY,EAAIC,EAAS,EAAK,EAC1C,CAACqD,EAAUC,CAAW,EAAItD,EAAS,CAAA,CAAE,EACrC,CAAC0J,EAAeN,CAAgB,EAAIpJ,EAAS,CAAG,EAGhD2J,EAAWjG,EAAO,IAAI,EACtBkG,EAAoBlG,EAAO,IAAI,EAC/BmG,EAAmBnG,EAAO,IAAI,EAGpCvD,EAAU,IAAM,CACd,MAAMC,EAAcC,EAAc,UAAUC,GAAS,CAEnDkD,EAAuBlD,EAAM,mBAAmB,EAChDP,EAAaO,EAAM,SAAS,EAC5BgD,EAAYhD,EAAM,kBAAoB,EAAE,EACxC8I,EAAiB9I,EAAM,aAAa,EAGpCwJ,EAAoBxJ,CAAK,CAC/B,CAAK,EAED,MAAO,IAAMF,EAAa,CAC3B,EAAE,EAAE,EAGL,MAAM0J,EAAuBxJ,GAAU,CACrC,MAAMyJ,EAAQJ,EAAS,QAIvB,GAHI,CAACI,GAGD,CAACzJ,EAAM,kBACPA,EAAM,iBAAiB,SAAW,GAClCA,EAAM,oBAAsB,GAC5BA,EAAM,qBAAuBA,EAAM,iBAAiB,OACtD,OAIF,MAAMS,EAAUT,EAAM,iBAAiBA,EAAM,mBAAmB,EAChE,GAAI,CAACS,EAAS,OAGd,MAAMiJ,EAAiBH,EAAiB,UAAY9I,EAAQ,GAItDkJ,EAAcD,EAGdpF,EAAiB7D,EAAQ,uBAAyBA,EAAQ,gBAG1D+D,EAAexE,EAAM,cAAgB,MACtBA,EAAM,aAAesE,EACtCtE,EAAM,YAAcsE,EACpB,EAKEsF,EAAc5J,EAAM,kBAAoB,MAC1B,KAAK,IAAIA,EAAM,YAAcA,EAAM,eAAe,EAAI,EAGtE0J,IACF,QAAQ,IAAI,wBAAwB,OAAAH,EAAiB,QAAO,QAAO,OAAA9I,EAAQ,GAAI,EAC/E8I,EAAiB,QAAU9I,EAAQ,IAIjCkJ,GAEF,QAAQ,IAAI,uBAAuB,OAAAlJ,EAAQ,GAAE,sBAAqB,OAAAiJ,EAAc,IAAG,EACnFG,EAAYpJ,EAAS+D,EAAcxE,EAAM,SAAS,GACzC4J,GAET,QAAQ,IAAI,cAAc,OAAApF,EAAY,2BAA0B,EAChEiF,EAAM,YAAcjF,GACXxE,EAAM,WAAayJ,EAAM,OAElCA,EAAM,KAAI,EAAG,MAAM9I,GAAS,CAC1B,QAAQ,MAAM,uBAAwBA,CAAK,CACnD,CAAO,EACQ,CAACX,EAAM,WAAa,CAACyJ,EAAM,QAEpCA,EAAM,MAAO,EAIXA,EAAM,eAAiBzJ,EAAM,gBAC/ByJ,EAAM,aAAezJ,EAAM,cAE9B,EAGK6J,EAAc,CAACpJ,EAASwE,EAAW,EAAG6E,EAAW,KAAU,CAC/D,MAAML,EAAQJ,EAAS,QACvB,GAAI,CAACI,EAAO,OAEZ,QAAQ,IAAI,mBAAmB,OAAAhJ,EAAQ,GAAE,aAAY,OAAAwE,EAAQ,iBAAgB,OAAA6E,EAAU,EAGvFL,EAAM,MAAO,EAGb,MAAMM,EAAe,wBAAwB,OAAAtJ,EAAQ,GAAE,OAAM,YAAK,IAAG,GAG/DuJ,EAAmB,IAAM,CAC7B,QAAQ,IAAI,uBAAuB,EAGnCP,EAAM,YAAcxE,EAGpBwE,EAAM,aAAeL,EAGjBU,GACFL,EAAM,KAAI,EAAG,MAAM9I,GAAS,CAC1B,QAAQ,MAAM,uBAAwBA,CAAK,EAC3CL,EAAkB,wBAA0BK,EAAM,QAAS,OAAO,CAC5E,CAAS,EAIH8I,EAAM,oBAAoB,iBAAkBO,CAAgB,CAC7D,EAGDP,EAAM,iBAAiB,iBAAkBO,CAAgB,EAGzDP,EAAM,IAAMM,EACZN,EAAM,KAAM,CACb,EAGKQ,EAAc,IAAM,CAIxB,GAHA,QAAQ,IAAI,aAAa,EAGrBhH,EAAsBF,EAAS,OAAS,EAAG,CAE7C,MAAMmH,EAAYjH,EAAsB,EACxC,QAAQ,IAAI,wBAAwB,OAAAiH,EAAW,EAG/C,MAAMC,EAAcpH,EAASmH,CAAS,EAChC5F,EAAiB6F,EAAY,uBAAyBA,EAAY,gBAGxEpK,EAAc,SAAS,CACrB,oBAAqBmK,EACrB,YAAa5F,EACb,UAAW,GACX,YAAa,EACrB,CAAO,CACP,MAEM,QAAQ,IAAI,qBAAqB,EAGjCvE,EAAc,SAAS,CACrB,UAAW,EACnB,CAAO,CAEJ,EAGKqK,EAAmB,IAAM,CAC7B,MAAMX,EAAQJ,EAAS,QAIvB,GAHI,CAACI,GAGDxG,EAAsB,GACtB,CAACF,GACDA,EAAS,SAAW,GACpBE,GAAuBF,EAAS,OAClC,OAGF,MAAMtC,EAAUsC,EAASE,CAAmB,EAC5C,GAAI,CAACxC,EAAS,OAMd,MAAM4G,GAHiB5G,EAAQ,uBAAyBA,EAAQ,iBAG3BgJ,EAAM,YAG3C/B,EAAkBL,CAAW,EAG7BtH,EAAc,SAAS,CACrB,YAAasH,EACb,gBAAiBiC,EAAkB,OACzC,CAAK,EAGDA,EAAkB,QAAUjC,CAC7B,EAGKK,EAAqBQ,GAAS,CAClC,GAAIA,IAAS,KAAM,OAEnB,MAAMG,EAAc,SAAS,eAAe,cAAc,EAC1D,GAAI,CAACA,EAAa,OAElB,MAAMN,EAAO,IAAI,KAAKG,EAAO,GAAI,EAG3BI,EAAQP,EAAK,SAAU,EAAC,SAAQ,EAAG,SAAS,EAAG,GAAG,EAClDQ,EAAUR,EAAK,WAAY,EAAC,SAAQ,EAAG,SAAS,EAAG,GAAG,EACtDS,EAAUT,EAAK,WAAY,EAAC,SAAQ,EAAG,SAAS,EAAG,GAAG,EAG5DM,EAAY,YAAc,GAAG,OAAAC,EAAK,KAAI,OAAAC,EAAO,KAAI,OAAAC,EAClD,EAED,OAAOzH,EAAAsJ,QAAIpJ,EAAA,yMAIa,kGAGE,uBACH,kDAEQ,8BACU,2NAK2I,wTAWlK,aAvBFoI,EAGK,GACH,GAEEY,EACKG,EAK4FnH,GAAuB,GAAKF,EAAS,OAAS,EAAI,SAAW,GAW7K2F,GAEP,CC5PA,MAAM3I,EAAgB,CACpB,QAAS,CAAE,EACX,iBAAkB,CAAE,EACpB,eAAgB,KAChB,aAAc,KACd,UAAW,GACX,oBAAqB,GACrB,UAAW,EACX,kBAAmB,EACnB,gBAAiB,GACjB,YAAa,KACb,gBAAiB,KACjB,cAAe,EACf,iBAAkB,GAClB,YAAa,GACb,UAAW,IAAI,IAGf,SAASuK,EAAU,CACjB,OAAO,OAAO,KAAMA,CAAQ,EAC5B,KAAK,gBAAiB,CACvB,EAGD,UAAUC,EAAU,CAClB,YAAK,UAAU,IAAIA,CAAQ,EACpB,IAAM,KAAK,UAAU,OAAOA,CAAQ,CAC5C,EAGD,iBAAkB,CAChB,KAAK,UAAU,QAAQA,GAAYA,EAAS,IAAI,CAAC,CACrD,CACA,EAKA,SAASC,GAAmBzC,EAAM,CAChC,MAAM0C,EAAO1C,EAAK,YAAa,EACzB2C,EAAQ,OAAO3C,EAAK,SAAQ,EAAK,CAAC,EAAE,SAAS,EAAG,GAAG,EACnD4C,EAAM,OAAO5C,EAAK,QAAS,CAAA,EAAE,SAAS,EAAG,GAAG,EAClD,MAAO,GAAG,OAAA0C,EAAI,KAAI,OAAAC,EAAK,KAAI,OAAAC,EAC7B,CAKA,SAASC,IAAiB,CACxB,MAAMC,EAAS,IAAI,gBAAgB,OAAO,SAAS,MAAM,EACzD,MAAO,CACL,OAAQA,EAAO,IAAI,QAAQ,GAAK,GAChC,KAAMA,EAAO,IAAI,MAAM,GAAKL,GAAmB,IAAI,IAAM,CAC1D,CACH,CAKA,SAASM,GAAgBC,EAAQhD,EAAM,CACrC,GAAI,CAACgD,EAAQ,OACb,MAAMC,EAAM,IAAI,IAAI,OAAO,SAAS,IAAI,EACxCA,EAAI,aAAa,IAAI,SAAUD,CAAM,EACrCC,EAAI,aAAa,IAAI,OAAQjD,CAAI,EACjC,OAAO,QAAQ,aAAa,CAAA,EAAI,GAAIiD,CAAG,CACzC,oBAKO,SAASC,IAAe,CAE7B,MAAMC,EAAYN,GAAgB,EAG5B,CAACO,EAAWC,CAAY,EAAI1L,EAAS,EAAK,EAC1C,CAAC2L,EAAaC,CAAc,EAAI5L,EAAS,CAAA,CAAE,EAC3C,CAAC6L,EAAgBC,CAAiB,EAAI9L,EAASwL,EAAU,MAAM,EAC/D,CAACO,EAAcC,CAAe,EAAIhM,EAASwL,EAAU,IAAI,EACzD,CAACnI,EAAUC,CAAW,EAAItD,EAAS,CAAA,CAAE,EAGrCiM,EAAuBvI,EAAO,IAAI,EAClCwI,EAAiBxI,EAAO,EAAK,EAG7B,CACJ,KAAMyI,EACN,UAAWC,EACX,MAAOC,CACX,EAAMC,EAAS,UAAW,eAAgB,CACtC,QAAS,KACT,QAAS,EACT,WAAY,GAChB,CAAG,EAGDnM,EAAU,IAAM,CACd,GAAIgM,GAAe,MAAM,QAAQA,CAAW,GAAKA,EAAY,OAAS,GAAK,CAACD,EAAe,SAazF,GAZA,QAAQ,IAAI,iDAAiD,EAC7DA,EAAe,QAAU,GAGzBN,EAAeO,CAAW,EAG1B9L,EAAc,SAAS,CAAE,QAAS8L,CAAW,CAAE,EAG1BA,EAAY,KAAKI,GAAKA,EAAE,OAASV,CAAc,GAEhDA,EAClB,QAAQ,IAAI,wCAAwC,OAAAA,EAAgB,UAC3DM,EAAY,OAAS,EAAG,CAEjC,MAAMK,EAAcL,EAAY,CAAC,EAAE,KACnC,QAAQ,IAAI,qCAAqC,OAAAK,EAAa,EAC9DV,EAAkBU,CAAW,CACrC,EAEA,EAAK,CAACL,CAAW,CAAC,EAGhBhM,EAAU,IAAM,CACVkM,IACF,QAAQ,MAAM,uCAAwCA,CAAY,EAClEzL,EAAkB,0BAA4ByL,EAAa,QAAS,OAAO,EAEjF,EAAK,CAACA,CAAY,CAAC,EAGjB,MAAMI,EAAgBpE,GAAS,CAC7B,MAAMqE,EAAY,IAAI,KAAKrE,CAAI,EAC/BqE,EAAU,SAAS,EAAG,EAAG,EAAG,CAAC,EAE7B,MAAMC,EAAU,IAAI,KAAKtE,CAAI,EAC7B,OAAAsE,EAAQ,SAAS,GAAI,GAAI,GAAI,GAAG,EAEzB,CACL,UAAWD,EAAU,YAAa,EAClC,QAASC,EAAQ,YAAW,CAC7B,CACF,EAGDxM,EAAU,IAAM,CACV0L,IAEFT,GAAgBS,EAAgBE,CAAY,EAG5C1L,EAAc,SAAS,CACrB,eAAAwL,EACA,aAAAE,CACR,CAAO,EAEP,EAAK,CAACF,EAAgBE,CAAY,CAAC,EAGjC,KAAM,CAAE,UAAA5J,EAAW,QAAAC,GAAYqK,EAAaV,CAAY,EAGlD,CACJ,KAAMa,EACN,UAAWC,EACX,MAAOC,EACP,QAASC,CACb,EAAMT,EACF,CAAC,oBAAqBT,EAAgBE,CAAY,EAClDF,EAAiB,iCAAiC,0BAAmBA,CAAc,EAAC,WAAU,0BAAmB1J,CAAS,EAAC,SAAQ,0BAAmBC,CAAO,GAAM,KACnK,CACE,QAAS,IACT,QAAS,EACT,WAAY,GACb,EACD,CACE,QAAS,CAAC,CAACyJ,EACX,UAAYmB,GAAS,CACnB,QAAQ,IAAI,wCAAyCA,CAAI,EACzD,MAAMC,EAAmBD,EAAK,UAAY,CAAE,EAG5C,GAFA,QAAQ,IAAI,0BAA0B,OAAAC,EAAiB,OAAM,YAAW,EAEpEA,EAAiB,SAAW,EAAG,CACjC,QAAQ,IAAI,iCAAiC,EAC7C3J,EAAY,CAAA,CAAE,EAGdjD,EAAc,SAAS,CACrB,iBAAkB,CAAE,EACpB,oBAAqB,GACrB,YAAa,KACb,UAAW,EACvB,CAAW,EAEDO,EAAkB,4CAA6C,SAAS,EACxE,MACV,CAEQ,QAAQ,IAAI,gCAAgC,EAC5C0C,EAAY2J,CAAgB,EAG5B,MAAMC,EAAcD,EAAiB,CAAC,EAAE,gBACxC5M,EAAc,SAAS,CACrB,iBAAA4M,EACA,oBAAqB,EACrB,YAAaC,EACb,gBAAiBA,EACjB,UAAW,EACrB,CAAS,EAGD,MAAMvM,EAAc,SAAS,cAAc,qBAAqB,EAC5DA,IACFA,EAAY,IAAM,wBAAwB,OAAAsM,EAAiB,CAAC,EAAE,IAC9DtM,EAAY,KAAM,GAGpBC,EAAkB,UAAU,OAAAqM,EAAiB,OAAM,uBAAuB,SAAS,CACpF,EACD,QAAUhM,GAAU,CAClB,QAAQ,MAAM,6CAA8CA,CAAK,EACjEL,EAAkB,gCAAkCK,EAAM,QAAS,OAAO,EAC1EqC,EAAY,CAAA,CAAE,CACtB,CACA,CACG,EAGK6J,EAAsBrJ,GAAM,CAChC,MAAMsJ,EAAYtJ,EAAE,OAAO,MAC3B,QAAQ,IAAI,mCAAmC,OAAAsJ,EAAW,EAC1DtB,EAAkBsB,CAAS,CAC5B,EAGKC,EAAoBvJ,GAAM,CAC9B,MAAMwJ,EAAUxJ,EAAE,OAAO,MACzB,QAAQ,IAAI,iCAAiC,OAAAwJ,EAAS,EACtDtB,EAAgBsB,CAAO,CACxB,EAGKC,EAAgB,IAChBV,EACKxL,EAAAmM,QAAIjM,EAAA,KAAoB,4CAAhBkM,IAGbpK,EAAS,SAAW,EACfhC,EAAAqM,QAAInM,EAAA,ilBAUNF,EAAAsM,QAAIpM,EAAA,0CAEQ,mDAGE,2PAMa,2BAEZ,mBACG,mBACF,sTAblBkI,GAGA5J,GAMSoM,EAELxK,GACA2B,GACAmE,IAUX,OAAOlG,EAAAuM,QAAIrM,EAAA,m6BAiBkC,0QAQL,4BACC,yEAEgC,qCAG7D,2WAUoB,4BACO,uKAOsD,4XAU9B,uBAC5B,wBACF,mDAIZ,8lBAhDC,IAAMwL,EAAiB,EAQzBlB,GAAkB,GACfsB,EAEgCxB,EAAY,OACvDA,EAAY,IAAIN,GAAUhK,EAAAwM,QAAItM,EAAA,gCACL,UAAqB,IAAe,6BAA/C8J,EAAO,KAAcA,EAAO,KAAQA,EAAO,KAC1D,EAUSU,EACGsB,EAOfR,EAAoB,aAAe,mDAUhBA,EAAoB,OAAS,QACvClB,EAAY,OACXtI,EAAS,OAIrBkK,EAAe,EAevB,QClXO,SAASO,IAAmB,CACjC,MAAMC,EAAc,SAAS,eAAe,cAAc,EACrDA,IAGLA,EAAY,UAAY,GAGxBC,GACE3M,EAAA4M,QAAI1M,EAAA,KAAuB,WAAsB,aAChC,mBADT2M,GAA8BC,GACjC5C,IAELwC,CACD,EACH"}