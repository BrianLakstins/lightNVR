{"version":3,"file":"index-B_EEASYg.js","sources":["../../js/components/preact/WebRTCVideoCell.jsx","../../js/components/preact/WebRTCView.jsx","../../js/pages/index-page.jsx"],"sourcesContent":["/**\n * WebRTCVideoCell Component\n * A reusable component for displaying a WebRTC video stream\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { startDetectionPolling } from './DetectionOverlay.js';\nimport { SnapshotButton } from './SnapshotManager.jsx';\n\n// Add CSS for spinner animation\nconst spinnerStyle = `\n  @keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n`;\n\n// Add the style to the document\nif (typeof document !== 'undefined') {\n  const style = document.createElement('style');\n  style.textContent = spinnerStyle;\n  document.head.appendChild(style);\n}\n\n/**\n * WebRTCVideoCell component\n * @param {Object} props - Component props\n * @param {Object} props.stream - Stream object\n * @param {Function} props.onTakeSnapshot - Snapshot handler\n * @param {Function} props.onToggleFullscreen - Fullscreen toggle handler\n * @param {Object} props.webrtcConnections - Reference to WebRTC connections\n * @param {Object} props.detectionIntervals - Reference to detection intervals\n * @param {Function} props.initializeWebRTCPlayer - Function to initialize WebRTC player\n * @param {Function} props.cleanupWebRTCPlayer - Function to cleanup WebRTC player\n * @returns {JSX.Element} WebRTCVideoCell component\n */\nexport function WebRTCVideoCell({\n  stream,\n  onTakeSnapshot,\n  onToggleFullscreen,\n  webrtcConnections,\n  detectionIntervals,\n  initializeWebRTCPlayer,\n  cleanupWebRTCPlayer\n}) {\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const cellRef = useRef(null);\n\n  // Initialize WebRTC player when component mounts\n  useEffect(() => {\n    if (!stream) return;\n\n    console.log(`WebRTCVideoCell: Initializing player for stream ${stream.name}`);\n\n    // Check if this stream already has a connection\n    const hasExistingConnection = webrtcConnections.current[stream.name];\n    if (hasExistingConnection) {\n      console.log(`WebRTCVideoCell: Stream ${stream.name} already has a connection, skipping initialization`);\n      setIsLoading(false);\n      return;\n    }\n\n    // Initialize WebRTC player with a short delay to ensure DOM is ready\n    console.log(`WebRTCVideoCell: Will initialize stream ${stream.name} after a short delay`);\n\n    const initTimeout = setTimeout(() => {\n      if (videoRef.current && canvasRef.current) {\n        console.log(`WebRTCVideoCell: Now initializing stream ${stream.name}`);\n        initializeWebRTCPlayer(stream, videoRef.current, canvasRef.current, {\n          onLoadedData: () => {\n            console.log(`Video data loaded for stream ${stream.name}`);\n            setIsLoading(false);\n          },\n          onPlaying: () => {\n            console.log(`Video playing for stream ${stream.name}`);\n            setIsLoading(false);\n\n            // Start detection polling if enabled\n            if (stream.detection_based_recording && stream.detection_model && canvasRef.current) {\n              console.log(`Starting detection polling for stream ${stream.name}`);\n              startDetectionPolling(stream.name, canvasRef.current, videoRef.current, detectionIntervals);\n            }\n          },\n          onError: (errorMessage) => {\n            console.error(`Video error for stream ${stream.name}:`, errorMessage);\n            setError(errorMessage || 'Video playback error');\n            setIsLoading(false);\n          }\n        });\n      }\n    }, 100); // Short 100ms delay to ensure DOM is ready\n\n    // Cleanup function\n    return () => {\n      clearTimeout(initTimeout);\n      if (stream) {\n        console.log(`WebRTCVideoCell: Cleaning up player for stream ${stream.name}`);\n        cleanupWebRTCPlayer(stream.name);\n      }\n    };\n  }, [stream.name]); // Only depend on stream.name to prevent unnecessary re-renders\n\n  // Handle retry button click\n  const handleRetry = () => {\n    if (!stream) return;\n\n    console.log(`Retrying connection for stream ${stream.name}`);\n    setIsLoading(true);\n    setError(null);\n\n    // Clean up existing connection\n    cleanupWebRTCPlayer(stream.name);\n\n    // Force a small delay to ensure cleanup is complete\n    setTimeout(() => {\n      if (videoRef.current && canvasRef.current) {\n        console.log(`Reinitializing WebRTC player for stream ${stream.name}`);\n        initializeWebRTCPlayer(stream, videoRef.current, canvasRef.current, {\n          onLoadedData: () => {\n            console.log(`Video data loaded for stream ${stream.name}`);\n            setIsLoading(false);\n          },\n          onPlaying: () => {\n            console.log(`Video playing for stream ${stream.name}`);\n            setIsLoading(false);\n          },\n          onError: (errorMessage) => {\n            console.error(`Video error for stream ${stream.name}:`, errorMessage);\n            // Try one more time with a longer delay\n            console.log(`Trying one more time for stream ${stream.name} with a longer delay`);\n\n            setTimeout(() => {\n              if (videoRef.current && canvasRef.current) {\n                initializeWebRTCPlayer(stream, videoRef.current, canvasRef.current, {\n                  onLoadedData: () => {\n                    console.log(`Video data loaded for stream ${stream.name} on second attempt`);\n                    setIsLoading(false);\n                  },\n                  onPlaying: () => {\n                    console.log(`Video playing for stream ${stream.name} on second attempt`);\n                    setIsLoading(false);\n                  },\n                  onError: (secondErrorMessage) => {\n                    console.error(`Video error for stream ${stream.name} on second attempt:`, secondErrorMessage);\n                    setError(secondErrorMessage || 'Video playback error');\n                    setIsLoading(false);\n                  }\n                });\n              }\n            }, 1000); // Try again after 1 second\n          }\n        });\n      }\n    }, 200);\n  };\n\n  return (\n    <div\n      className=\"video-cell\"\n      data-stream-name={stream.name}\n      data-stream-id={stream.id || stream.name}\n      ref={cellRef}\n      style={{ position: 'relative' }}\n    >\n      {/* Video element */}\n      <video\n        id={`video-${stream.name.replace(/\\s+/g, '-')}`}\n        className=\"video-element\"\n        ref={videoRef}\n        playsInline\n        autoPlay\n        muted\n        style={{ pointerEvents: 'none', width: '100%', height: '100%', objectFit: 'contain' }}\n      />\n\n      {/* Canvas overlay for detection */}\n      <canvas\n        id={`canvas-${stream.name.replace(/\\s+/g, '-')}`}\n        className=\"detection-overlay\"\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          pointerEvents: 'none',\n          zIndex: 5\n        }}\n      />\n\n      {/* Stream name overlay */}\n      <div\n        className=\"stream-name-overlay\"\n        style={{\n          position: 'absolute',\n          top: '10px',\n          left: '10px',\n          padding: '5px 10px',\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n          color: 'white',\n          borderRadius: '4px',\n          fontSize: '14px',\n          zIndex: 15,\n          pointerEvents: 'none'\n        }}\n      >\n        {stream.name}\n      </div>\n\n      {/* Stream controls */}\n      <div\n        className=\"stream-controls\"\n        style={{\n          position: 'absolute',\n          bottom: '10px',\n          right: '10px',\n          display: 'flex',\n          gap: '10px',\n          zIndex: 30,\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n          padding: '5px',\n          borderRadius: '4px',\n          pointerEvents: 'auto'\n        }}\n      >\n        <div\n          style={{\n            backgroundColor: 'transparent',\n            padding: '5px',\n            borderRadius: '4px',\n            position: 'relative',\n            zIndex: 30\n          }}\n          onMouseOver={(e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'}\n          onMouseOut={(e) => e.currentTarget.style.backgroundColor = 'transparent'}\n        >\n          <SnapshotButton\n            streamId={stream.id || stream.name}\n            streamName={stream.name}\n          />\n        </div>\n        <button\n          className=\"fullscreen-btn\"\n          title=\"Toggle Fullscreen\"\n          data-id={stream.id || stream.name}\n          data-name={stream.name}\n          onClick={(e) => onToggleFullscreen(stream.name, e)}\n          style={{\n            backgroundColor: 'transparent',\n            border: 'none',\n            padding: '5px',\n            borderRadius: '4px',\n            color: 'white',\n            cursor: 'pointer',\n            position: 'relative',\n            zIndex: 30\n          }}\n          onMouseOver={(e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'}\n          onMouseOut={(e) => e.currentTarget.style.backgroundColor = 'transparent'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path></svg>\n        </button>\n      </div>\n\n      {/* Loading indicator */}\n      {isLoading && (\n        <div\n          className=\"loading-indicator\"\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            width: '100%',\n            height: '100%',\n            display: 'flex',\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            backgroundColor: 'rgba(0, 0, 0, 0.7)',\n            color: 'white',\n            zIndex: 20,\n            pointerEvents: 'none',\n            textAlign: 'center'\n          }}\n        >\n          <div\n            className=\"loading-content\"\n            style={{\n              display: 'flex',\n              flexDirection: 'column',\n              justifyContent: 'center',\n              alignItems: 'center',\n              padding: '20px',\n              borderRadius: '8px',\n              backgroundColor: 'rgba(0, 0, 0, 0.5)'\n            }}\n          >\n            <div className=\"spinner\" style={{\n              width: '40px',\n              height: '40px',\n              border: '4px solid rgba(255, 255, 255, 0.3)',\n              borderRadius: '50%',\n              borderTop: '4px solid white',\n              animation: 'spin 1s linear infinite',\n              marginBottom: '15px'\n            }}></div>\n            <p style={{\n              fontSize: '14px',\n              fontWeight: 'bold'\n            }}>Connecting...</p>\n          </div>\n        </div>\n      )}\n\n      {/* Error indicator */}\n      {error && (\n        <div\n          className=\"error-indicator\"\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            width: '100%',\n            height: '100%',\n            display: 'flex',\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            backgroundColor: 'rgba(0, 0, 0, 0.7)',\n            color: 'white',\n            zIndex: 20,\n            pointerEvents: 'auto',\n            textAlign: 'center'\n          }}\n        >\n          <div\n            className=\"error-content\"\n            style={{\n              display: 'flex',\n              flexDirection: 'column',\n              justifyContent: 'center',\n              alignItems: 'center',\n              width: '80%',\n              maxWidth: '300px',\n              padding: '20px',\n              borderRadius: '8px',\n              backgroundColor: 'rgba(0, 0, 0, 0.5)'\n            }}\n          >\n            <div\n              className=\"error-icon\"\n              style={{\n                fontSize: '28px',\n                marginBottom: '15px',\n                fontWeight: 'bold',\n                width: '40px',\n                height: '40px',\n                lineHeight: '40px',\n                borderRadius: '50%',\n                backgroundColor: 'rgba(220, 38, 38, 0.8)',\n                textAlign: 'center'\n              }}\n            >\n              !\n            </div>\n            <p style={{\n              marginBottom: '20px',\n              textAlign: 'center',\n              width: '100%',\n              fontSize: '14px',\n              lineHeight: '1.4'\n            }}>\n              {error}\n            </p>\n            <button\n              className=\"retry-button\"\n              onClick={handleRetry}\n              style={{\n                padding: '8px 20px',\n                backgroundColor: '#2563eb',\n                color: 'white',\n                borderRadius: '4px',\n                border: 'none',\n                cursor: 'pointer',\n                fontWeight: 'bold',\n                fontSize: '14px',\n                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',\n                transition: 'background-color 0.2s ease'\n              }}\n              onMouseOver={(e) => e.currentTarget.style.backgroundColor = '#1d4ed8'}\n              onMouseOut={(e) => e.currentTarget.style.backgroundColor = '#2563eb'}\n            >\n              Retry\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n","/**\n * LightNVR Web Interface WebRTCView Component\n * Preact component for the WebRTC view page\n */\n\n\nimport { useState, useEffect, useRef, useCallback } from 'preact/hooks';\nimport { showSnapshotPreview, setupModals, addModalStyles } from './UI.jsx';\nimport { showStatusMessage } from './ToastContainer.jsx';\nimport { useFullscreenManager, FullscreenManager } from './FullscreenManager.jsx';\nimport { startDetectionPolling, cleanupDetectionPolling } from './DetectionOverlay.js';\nimport { useMutation, useQuery, useQueryClient } from '../../query-client.js';\nimport { WebRTCVideoCell } from './WebRTCVideoCell.jsx';\nimport { SnapshotManager, useSnapshotManager } from './SnapshotManager.jsx';\n\n/**\n * WebRTCView component\n * @returns {JSX.Element} WebRTCView component\n */\nexport function WebRTCView() {\n  // Use the snapshot manager hook\n  const { takeSnapshot } = useSnapshotManager();\n  // Use the fullscreen manager hook\n  const { isFullscreen, setIsFullscreen, toggleFullscreen } = useFullscreenManager();\n  // WebRTC offer mutation hook - we don't specify the URL here as it will be dynamic based on the stream\n  const webrtcOfferMutation = useMutation({\n    mutationFn: async (data) => {\n      const { streamName, ...offerData } = data;\n      const auth = localStorage.getItem('auth');\n\n      const response = await fetch(`/api/webrtc?src=${encodeURIComponent(streamName)}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(auth ? { 'Authorization': 'Basic ' + auth } : {})\n        },\n        body: JSON.stringify(offerData),\n        signal: data.signal\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to send offer: ${response.status} ${response.statusText}`);\n      }\n\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch (jsonError) {\n        console.error(`Error parsing JSON for stream ${streamName}:`, jsonError);\n        console.log(`Raw response text: ${text}`);\n        throw new Error(`Failed to parse WebRTC answer: ${jsonError.message}`);\n      }\n    },\n    onError: (error, variables) => {\n      console.error(`Error sending WebRTC offer for stream ${variables.streamName}:`, error);\n    }\n  });\n\n  const [streams, setStreams] = useState([]);\n  // Initialize layout from URL or sessionStorage if available\n  const [layout, setLayout] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const layoutParam = urlParams.get('layout');\n    if (layoutParam) {\n      return layoutParam;\n    }\n    // Check sessionStorage as a backup\n    const storedLayout = sessionStorage.getItem('webrtc_layout');\n    return storedLayout || '4';\n  });\n\n  // Initialize selectedStream from URL or sessionStorage if available\n  const [selectedStream, setSelectedStream] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const streamParam = urlParams.get('stream');\n    if (streamParam) {\n      return streamParam;\n    }\n    // Check sessionStorage as a backup\n    const storedStream = sessionStorage.getItem('webrtc_selected_stream');\n    return storedStream || '';\n  });\n\n  // isFullscreen state is now managed by useFullscreenManager\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Initialize currentPage from URL or sessionStorage if available (URL uses 1-based indexing, internal state uses 0-based)\n  const [currentPage, setCurrentPage] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const pageParam = urlParams.get('page');\n    if (pageParam) {\n      // Convert from 1-based (URL) to 0-based (internal)\n      return Math.max(0, parseInt(pageParam, 10) - 1);\n    }\n    // Check sessionStorage as a backup\n    const storedPage = sessionStorage.getItem('webrtc_current_page');\n    if (storedPage) {\n      // Convert from 1-based (stored) to 0-based (internal)\n      return Math.max(0, parseInt(storedPage, 10) - 1);\n    }\n    return 0;\n  });\n  const videoGridRef = useRef(null);\n  const webrtcConnections = useRef({});\n  const detectionIntervals = useRef({});\n\n  // Set up event listeners and UI components\n  useEffect(() => {\n    // Set up modals for snapshot preview\n    setupModals();\n    addModalStyles();\n\n    // Add event listener to preserve URL parameters when page is reloaded\n    const handleBeforeUnload = () => {\n      console.log('Preserving URL parameters before page reload');\n\n      // Create a URL with the current parameters\n      const url = new URL(window.location);\n\n      // Ensure page parameter is set correctly (convert from 0-based internal to 1-based URL)\n      if (currentPage > 0) {\n        url.searchParams.set('page', currentPage + 1);\n      } else {\n        url.searchParams.delete('page');\n      }\n\n      // Ensure layout parameter is set if not default\n      if (layout !== '4') {\n        url.searchParams.set('layout', layout);\n      } else {\n        url.searchParams.delete('layout');\n      }\n\n      // Ensure stream parameter is set if in single stream mode\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without triggering navigation\n      window.history.replaceState({}, '', url);\n\n      // Store the current page in sessionStorage as a backup\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      // Store layout in sessionStorage\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      // Store selected stream in sessionStorage\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    };\n\n    // Register the beforeunload handler\n    window.addEventListener('beforeunload', handleBeforeUnload);\n\n    // Set up periodic connection check\n    const connectionCheckInterval = setInterval(() => {\n      Object.keys(webrtcConnections.current).forEach(streamName => {\n        const pc = webrtcConnections.current[streamName];\n        if (pc) {\n          // Log connection state for debugging\n          console.debug(`WebRTC connection state for ${streamName}: ${pc.connectionState}, ICE state: ${pc.iceConnectionState}`);\n\n          // If connection is failed or disconnected for too long, try to reconnect\n          if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n            console.warn(`WebRTC connection for ${streamName} is in ${pc.iceConnectionState} state, will attempt reconnect`);\n\n            // Clean up the old connection\n            cleanupWebRTCPlayer(streamName);\n\n            // Find the stream info and reinitialize\n            const stream = streams.find(s => s.name === streamName);\n            if (stream) {\n              console.log(`Attempting to reconnect WebRTC for stream ${streamName}`);\n              initializeWebRTCPlayer(stream);\n            }\n          }\n        }\n      });\n    }, 30000); // Check every 30 seconds\n\n    // Cleanup\n    return () => {\n      // Remove event listeners\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      clearInterval(connectionCheckInterval);\n      stopAllWebRTCStreams();\n    };\n  }, [streams, currentPage, layout, selectedStream]); // Add all relevant dependencies\n\n  // Get query client for fetching and invalidating queries\n  const queryClient = useQueryClient();\n\n  // Fetch streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery(\n    'streams',\n    '/api/streams',\n    {\n      timeout: 15000, // 15 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    }\n  );\n\n  // Update loading state based on streams query status\n  useEffect(() => {\n    setIsLoading(isLoadingStreams);\n  }, [isLoadingStreams]);\n\n  // Process streams data when it's loaded\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData)) {\n      // Process the streams data\n      const processStreams = async () => {\n        try {\n          // Filter and process the streams\n          const filteredStreams = await filterStreamsForWebRTC(streamsData);\n\n          if (filteredStreams.length > 0) {\n            setStreams(filteredStreams);\n\n            // Set selectedStream based on URL parameter if it exists and is valid\n            const urlParams = new URLSearchParams(window.location.search);\n            const streamParam = urlParams.get('stream');\n\n            if (streamParam && filteredStreams.some(stream => stream.name === streamParam)) {\n              // If the stream from URL exists in the loaded streams, use it\n              setSelectedStream(streamParam);\n            } else if (!selectedStream || !filteredStreams.some(stream => stream.name === selectedStream)) {\n              // Otherwise use the first stream if selectedStream is not set or invalid\n              setSelectedStream(filteredStreams[0].name);\n            }\n          } else {\n            console.warn('No streams available for WebRTC view after filtering');\n          }\n        } catch (error) {\n          console.error('Error processing streams:', error);\n          showStatusMessage('Error processing streams: ' + error.message);\n        }\n      };\n\n      processStreams();\n    }\n  }, [streamsData, selectedStream, queryClient]);\n\n  // Use a ref to track previous values to prevent unnecessary updates\n  const previousValues = useRef({ layout, selectedStream, currentPage, streamsLength: streams.length });\n\n  useEffect(() => {\n    // Only update if something actually changed\n    const prev = previousValues.current;\n    if (\n      prev.layout !== layout ||\n      prev.selectedStream !== selectedStream ||\n      prev.currentPage !== currentPage ||\n      prev.streamsLength !== streams.length\n    ) {\n      console.log('Layout, selectedStream, currentPage, or streams changed, updating video grid');\n      updateVideoGrid();\n\n      // Update previous values\n      previousValues.current = { layout, selectedStream, currentPage, streamsLength: streams.length };\n    }\n  }, [layout, selectedStream, streams, currentPage]);\n\n  // Update URL when layout, page, or selectedStream changes\n  useEffect(() => {\n    // Don't update URL during initial load or when streams are empty\n    if (streams.length === 0) return;\n\n    // Use a debounce to prevent multiple URL updates in quick succession\n    const updateURLTimeout = setTimeout(() => {\n      console.log('Updating URL parameters');\n      const url = new URL(window.location);\n\n      // Handle page parameter (convert from 0-based internal to 1-based URL)\n      if (currentPage === 0) {\n        url.searchParams.delete('page');\n      } else {\n        // Add 1 to convert from 0-based (internal) to 1-based (URL)\n        url.searchParams.set('page', currentPage + 1);\n      }\n\n      // Handle layout parameter\n      if (layout !== '4') { // Only set if not the default\n        url.searchParams.set('layout', layout);\n      } else {\n        // Remove layout parameter if it's the default value\n        url.searchParams.delete('layout');\n      }\n\n      // Handle selectedStream parameter\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        // Remove stream parameter if not in single stream mode\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without reloading the page\n      window.history.replaceState({}, '', url);\n\n      // Also update sessionStorage\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    }, 300); // 300ms debounce\n\n    // Clean up the timeout if the component re-renders before the timeout completes\n    return () => clearTimeout(updateURLTimeout);\n  }, [currentPage, layout, selectedStream, streams.length]);\n\n  /**\n   * Filter streams for WebRTC view\n   * @param {Array} streams - Array of streams\n   * @returns {Promise<Array>} Promise resolving to filtered array of streams\n   */\n  const filterStreamsForWebRTC = async (streams) => {\n    try {\n      if (!streams || !Array.isArray(streams)) {\n        console.warn('No streams data provided to filter');\n        return [];\n      }\n\n      // For WebRTC view, we need to fetch full details for each stream\n      const streamPromises = streams.map(async (stream) => {\n        try {\n          const streamId = stream.id || stream.name;\n\n          const streamDetails = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamId],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamId)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to load details for stream ${stream.name}`);\n              }\n              return response.json();\n            },\n            staleTime: 30000 // 30 seconds\n          });\n\n          return streamDetails;\n        } catch (error) {\n          console.error(`Error loading details for stream ${stream.name}:`, error);\n          // Return the basic stream info if we can't get details\n          return stream;\n        }\n      });\n\n      const detailedStreams = await Promise.all(streamPromises);\n      console.log('Loaded detailed streams for WebRTC view:', detailedStreams);\n\n      // Filter out streams that are soft deleted, inactive, or not configured for streaming\n      const filteredStreams = detailedStreams.filter(stream => {\n        // Filter out soft deleted streams\n        if (stream.is_deleted) {\n          console.log(`Stream ${stream.name} is soft deleted, filtering out`);\n          return false;\n        }\n\n        // Filter out inactive streams\n        if (!stream.enabled) {\n          console.log(`Stream ${stream.name} is inactive, filtering out`);\n          return false;\n        }\n\n        // Filter out streams not configured for streaming\n        if (!stream.streaming_enabled) {\n          console.log(`Stream ${stream.name} is not configured for streaming, filtering out`);\n          return false;\n        }\n\n        return true;\n      });\n\n      console.log('Filtered streams for WebRTC view:', filteredStreams);\n\n      return filteredStreams || [];\n    } catch (error) {\n      console.error('Error filtering streams for WebRTC view:', error);\n      showStatusMessage('Error processing streams: ' + error.message);\n      return [];\n    }\n  };\n\n  /**\n   * Get maximum number of streams to display based on layout\n   * @returns {number} Maximum number of streams\n   */\n  const getMaxStreamsForLayout = () => {\n    switch (layout) {\n      case '1': return 1;  // Single view\n      case '2': return 2;  // 2x1 grid\n      case '4': return 4;  // 2x2 grid\n      case '6': return 6;  // 2x3 grid\n      case '9': return 9;  // 3x3 grid\n      case '16': return 16; // 4x4 grid\n      default: return 4;\n    }\n  };\n\n  /**\n   * Get streams to show based on layout, selected stream, and pagination\n   * @returns {Array} Streams to show\n   */\n  const getStreamsToShow = () => {\n    // Filter streams based on layout and selected stream\n    let streamsToShow = streams;\n    if (layout === '1' && selectedStream) {\n      streamsToShow = streams.filter(stream => stream.name === selectedStream);\n    } else {\n      // Apply pagination\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      // Ensure current page is valid\n      if (currentPage >= totalPages && totalPages > 0) {\n        // We'll handle this in updateVideoGrid\n        return [];\n      }\n\n      // Get streams for current page\n      const startIdx = currentPage * maxStreams;\n      const endIdx = Math.min(startIdx + maxStreams, streams.length);\n      streamsToShow = streams.slice(startIdx, endIdx);\n    }\n\n    return streamsToShow;\n  };\n\n  /**\n   * Update video grid based on layout, streams, and pagination\n   */\n  const updateVideoGrid = () => {\n    if (!videoGridRef.current) return;\n\n    // Filter streams based on layout and selected stream\n    let streamsToShow = getStreamsToShow();\n\n    // If no streams to show and we have streams, check if page is invalid\n    if (streamsToShow.length === 0 && streams.length > 0) {\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      if (currentPage >= totalPages) {\n        setCurrentPage(Math.max(0, totalPages - 1));\n        return; // Will re-render with corrected page\n      }\n    }\n\n    // Get the names of streams that should be shown\n    const streamsToShowNames = streamsToShow.map(stream => stream.name);\n\n    // Log page change for debugging\n    console.log(`Updating video grid for page ${currentPage + 1}, showing streams:`, streamsToShowNames);\n\n    // Clean up connections for streams that are no longer visible\n    const connectionsToCleanup = Object.keys(webrtcConnections.current).filter(\n      streamName => !streamsToShowNames.includes(streamName)\n    );\n\n    if (connectionsToCleanup.length > 0) {\n      console.log(`Cleaning up ${connectionsToCleanup.length} WebRTC connections that are no longer visible:`, connectionsToCleanup);\n      connectionsToCleanup.forEach(streamName => {\n        cleanupWebRTCPlayer(streamName);\n      });\n    }\n  };\n\n  /**\n   * Initialize WebRTC player for a stream\n   * @param {Object} stream - Stream object\n   * @param {HTMLVideoElement} videoElement - Video element\n   * @param {HTMLCanvasElement} canvasOverlay - Canvas overlay for detection\n   * @param {Object} callbacks - Callback functions\n   */\n  const initializeWebRTCPlayer = (stream, videoElement, canvasOverlay, callbacks = {}) => {\n    if (!stream || !videoElement) {\n      console.error(`Cannot initialize WebRTC player: missing stream or video element`);\n      return;\n    }\n\n    // Check if there's already a connection for this stream\n    if (webrtcConnections.current[stream.name]) {\n      console.log(`WebRTC connection for stream ${stream.name} already exists, cleaning up first`);\n      cleanupWebRTCPlayer(stream.name);\n    }\n\n    console.log(`Initializing WebRTC player for stream ${stream.name}`);\n\n    // Create a new RTCPeerConnection with ICE servers\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ],\n      // Add additional configuration to ensure proper ICE credentials\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'balanced',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'unified-plan'\n    });\n\n    // Store the connection for cleanup\n    webrtcConnections.current[stream.name] = pc;\n\n    // Add event listeners\n    pc.ontrack = (event) => {\n      console.log(`Track received for stream ${stream.name}:`, event);\n      if (event.track.kind === 'video') {\n        videoElement.srcObject = event.streams[0];\n\n        // Add event handlers for video element\n        videoElement.onloadeddata = () => {\n          console.log(`Video data loaded for stream ${stream.name}`);\n          if (callbacks.onLoadedData) {\n            callbacks.onLoadedData();\n          }\n        };\n\n        videoElement.onplaying = () => {\n          console.log(`Video playing for stream ${stream.name}`);\n          if (callbacks.onPlaying) {\n            callbacks.onPlaying();\n          }\n\n          // Start detection polling now that the video is playing\n          if (stream.detection_based_recording && stream.detection_model && canvasOverlay) {\n            console.log(`Starting detection polling for stream ${stream.name} now that video is playing`);\n            startDetectionPolling(stream.name, canvasOverlay, videoElement, detectionIntervals.current);\n          } else {\n            console.log(`Detection not enabled for stream ${stream.name}`);\n          }\n        };\n\n        videoElement.onerror = (e) => {\n          console.error(`Video error for stream ${stream.name}:`, e);\n          if (callbacks.onError) {\n            callbacks.onError('Video playback error');\n          }\n        };\n      }\n    };\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log(`ICE candidate for stream ${stream.name}:`, event.candidate);\n        // go2rtc doesn't use a separate ICE endpoint, so we don't need to send ICE candidates\n      }\n    };\n\n    pc.oniceconnectionstatechange = () => {\n      console.log(`ICE connection state for stream ${stream.name}:`, pc.iceConnectionState);\n\n      // Handle different ICE connection states\n      if (pc.iceConnectionState === 'failed') {\n        console.warn(`ICE failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC ICE connection failed');\n        }\n      } else if (pc.iceConnectionState === 'disconnected') {\n        console.warn(`ICE disconnected for stream ${stream.name}`);\n        // Don't immediately handle as error, as disconnected can be temporary\n      }\n    };\n\n    // Also monitor connection state changes\n    pc.onconnectionstatechange = () => {\n      console.log(`Connection state changed for stream ${stream.name}:`, pc.connectionState);\n\n      if (pc.connectionState === 'failed') {\n        console.warn(`Connection failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC connection failed');\n        }\n      }\n    };\n\n    // Add transceivers to ensure we get both audio and video tracks\n    pc.addTransceiver('video', {direction: 'recvonly'});\n    pc.addTransceiver('audio', {direction: 'recvonly'});\n\n    // Create an offer with specific codec requirements\n    const offerOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n\n    // Create a timeout for the entire WebRTC setup process\n    const setupTimeoutId = setTimeout(() => {\n      console.warn(`WebRTC setup timed out for stream ${stream.name}`);\n      if (callbacks.onError) {\n        callbacks.onError('WebRTC setup timed out');\n      }\n\n      // Clean up the connection if it exists\n      if (webrtcConnections.current[stream.name]) {\n        cleanupWebRTCPlayer(stream.name);\n      }\n    }, 30000); // 30 second timeout for the entire setup process\n\n    // Create a separate timeout for video playback\n    const videoPlaybackTimeoutId = setTimeout(() => {\n      // Only show error if the connection still exists but video isn't playing\n      if (webrtcConnections.current[stream.name] &&\n          (!videoElement.srcObject || videoElement.readyState < 2)) { // HAVE_CURRENT_DATA = 2\n        console.warn(`Video playback timed out for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('Video playback timed out');\n        }\n      }\n    }, 20000); // 20 second timeout for video playback\n\n    // Add a check to ensure the connection still exists before proceeding\n    const checkConnectionExists = () => {\n      return webrtcConnections.current[stream.name] === pc;\n    };\n\n    pc.createOffer(offerOptions)\n      .then(offer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up during offer creation');\n        }\n        console.log(`Created offer for stream ${stream.name}`);\n        return pc.setLocalDescription(offer);\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting local description');\n        }\n        console.log(`Set local description for stream ${stream.name}`);\n        // Send the offer to the server\n        return sendOffer(stream.name, pc.localDescription);\n      })\n      .then(answer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after receiving answer');\n        }\n        console.log(`Received answer for stream ${stream.name}`);\n        // Set the remote description\n        return pc.setRemoteDescription(new RTCSessionDescription(answer));\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting remote description');\n        }\n        console.log(`Set remote description for stream ${stream.name}`);\n\n        // Clear both timeouts since we've successfully set up the connection\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n      })\n      .catch(error => {\n        // Clear both timeouts\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n\n        // Only log and call error callback if the connection still exists\n        if (checkConnectionExists()) {\n          console.error(`Error setting up WebRTC for stream ${stream.name}:`, error);\n          if (callbacks.onError) {\n            callbacks.onError(error.message);\n          }\n        } else {\n          console.log(`WebRTC setup for stream ${stream.name} was cancelled: ${error.message}`);\n        }\n      });\n\n    // Add event listener to clear the video playback timeout when video starts playing\n    videoElement.addEventListener('playing', () => {\n      clearTimeout(videoPlaybackTimeoutId);\n    }, { once: true }); // Use once: true to ensure it only fires once\n  };\n\n  /**\n   * Send WebRTC offer to server\n   * @param {string} streamName - Stream name\n   * @param {RTCSessionDescription} offer - WebRTC offer\n   * @returns {Promise<RTCSessionDescription>} Promise resolving to WebRTC answer\n   */\n  const sendOffer = useCallback(async (streamName, offer) => {\n    try {\n      // Format the offer according to go2rtc expectations\n      const formattedOffer = {\n        type: offer.type,\n        sdp: offer.sdp\n      };\n\n      console.log(`Sending formatted offer for stream ${streamName}`);\n\n      // Create an AbortController to allow cancellation of the request\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n\n      // Store the abort controller in the connection object for later cleanup\n      if (webrtcConnections.current[streamName]) {\n        webrtcConnections.current[streamName].abortController = abortController;\n      } else {\n        // If the connection no longer exists, abort immediately\n        console.log(`Connection for stream ${streamName} no longer exists, aborting offer`);\n        abortController.abort();\n        return Promise.reject(new Error('Connection no longer exists'));\n      }\n\n      // Use the mutation to send the offer with the abort signal\n      const result = await webrtcOfferMutation.mutateAsync({\n        ...formattedOffer,\n        streamName, // Add streamName for the URL construction in mutationFn\n        signal      // Add signal for request cancellation\n      });\n\n      // Check if the connection still exists before returning the result\n      if (webrtcConnections.current[streamName]) {\n        return result;\n      } else {\n        // If the connection was cleaned up during the request, abort and reject\n        console.log(`Connection for stream ${streamName} was cleaned up during offer, rejecting result`);\n        return Promise.reject(new Error('Connection was cleaned up during offer'));\n      }\n    } catch (error) {\n      // Check if this was an abort error, which we can safely ignore\n      if (error.name === 'AbortError') {\n        console.log(`WebRTC offer request for stream ${streamName} was aborted`);\n        // Return a rejected promise to stop the WebRTC connection process\n        return Promise.reject(new Error('Request aborted'));\n      }\n\n      console.error(`Error sending offer for stream ${streamName}:`, error);\n      throw error;\n    }\n  }, [webrtcOfferMutation]);\n\n  // ICE candidates are handled internally by the browser for go2rtc\n\n  /**\n   * Handle WebRTC error\n   * @param {string} streamName - Stream name\n   * @param {string} message - Error message\n   */\n  const handleWebRTCError = async (streamName, message) => {\n    console.error(`WebRTC error for stream ${streamName}:`, message);\n\n    // Find the video cell\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    if (!videoElement) return;\n\n    const videoCell = videoElement.closest('.video-cell');\n    if (!videoCell) return;\n\n    // Hide loading indicator\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'none';\n    }\n\n    // Create error indicator if it doesn't exist\n    let errorIndicator = videoCell.querySelector('.error-indicator');\n    if (!errorIndicator) {\n      errorIndicator = document.createElement('div');\n      errorIndicator.className = 'error-indicator';\n      errorIndicator.style.position = 'absolute';\n      errorIndicator.style.top = '0';\n      errorIndicator.style.left = '0';\n      errorIndicator.style.width = '100%';\n      errorIndicator.style.height = '100%';\n      errorIndicator.style.display = 'flex';\n      errorIndicator.style.flexDirection = 'column';\n      errorIndicator.style.justifyContent = 'center';\n      errorIndicator.style.alignItems = 'center';\n      errorIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n      errorIndicator.style.color = 'white';\n      errorIndicator.style.zIndex = '20'; // Above video but below controls\n      videoCell.appendChild(errorIndicator);\n    }\n\n    // Create the error message and retry button\n    const errorIcon = document.createElement('div');\n    errorIcon.className = 'error-icon';\n    errorIcon.textContent = '!';\n    errorIcon.style.fontSize = '24px';\n    errorIcon.style.marginBottom = '10px';\n    errorIcon.style.fontWeight = 'bold';\n\n    const errorMsg = document.createElement('p');\n    errorMsg.textContent = message || 'WebRTC connection failed';\n    errorMsg.style.marginBottom = '15px';\n    errorMsg.style.textAlign = 'center';\n    errorMsg.style.maxWidth = '80%';\n    errorMsg.style.color = 'white';\n\n    const retryButton = document.createElement('button');\n    retryButton.className = 'retry-button';\n    retryButton.textContent = 'Retry';\n    retryButton.style.padding = '8px 16px';\n    retryButton.style.backgroundColor = '#2563eb'; // blue-600\n    retryButton.style.color = 'white';\n    retryButton.style.borderRadius = '4px';\n    retryButton.style.border = 'none';\n    retryButton.style.cursor = 'pointer';\n    retryButton.style.position = 'relative';\n    retryButton.style.zIndex = '30';\n    retryButton.style.pointerEvents = 'auto';\n    retryButton.style.margin = '0 auto';\n    retryButton.style.display = 'block';\n\n    // Clear the error indicator and add the new elements\n    errorIndicator.innerHTML = '';\n    errorIndicator.appendChild(errorIcon);\n    errorIndicator.appendChild(errorMsg);\n    errorIndicator.appendChild(retryButton);\n\n    errorIndicator.style.display = 'flex';\n    errorIndicator.style.pointerEvents = 'auto'; // Enable pointer events when visible to allow retry button clicks\n\n    // Add event listener to retry button\n    retryButton.addEventListener('click', async (event) => {\n      console.log('Retry button clicked for stream:', streamName);\n      event.preventDefault();\n      event.stopPropagation();\n\n      // Show loading indicator\n      if (loadingIndicator) {\n        loadingIndicator.style.display = 'flex';\n      }\n\n      // Hide error indicator\n      errorIndicator.style.display = 'none';\n\n      // Cleanup existing connection\n      cleanupWebRTCPlayer(streamName);\n\n      // Find the stream in our streams array\n      const stream = streams.find(s => s.name === streamName);\n\n      if (stream) {\n        console.log(`Found stream ${streamName} in local state, reinitializing`);\n        // Small delay to ensure cleanup is complete\n        setTimeout(() => {\n          initializeWebRTCPlayer(stream);\n        }, 100);\n      } else {\n        console.log(`Stream ${streamName} not found in local state, fetching from API`);\n\n        try {\n          // Fetch stream info using queryClient\n          const streamInfo = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamName],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamName)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to fetch stream info: ${response.status} ${response.statusText}`);\n              }\n              return response.json();\n            },\n            staleTime: 10000 // 10 seconds\n          });\n\n          console.log(`Received stream info for ${streamName}, reinitializing`);\n          // Reinitialize with a small delay\n          setTimeout(() => {\n            initializeWebRTCPlayer(streamInfo);\n          }, 100);\n        } catch (error) {\n          console.error('Error fetching stream info:', error);\n\n          // Show error indicator again with new message\n          errorIndicator.style.display = 'flex';\n          errorMsg.textContent = 'Could not reconnect: ' + error.message;\n\n          // Hide loading indicator\n          if (loadingIndicator) {\n            loadingIndicator.style.display = 'none';\n          }\n        }\n      }\n    });\n  };\n\n  /**\n   * Cleanup WebRTC player\n   * @param {string} streamName - Stream name\n   */\n  const cleanupWebRTCPlayer = (streamName) => {\n    console.log(`Cleaning up WebRTC player for stream ${streamName}`);\n\n    // Close and remove the RTCPeerConnection\n    if (webrtcConnections.current[streamName]) {\n      // Create a local reference to the connection before deleting it\n      const connection = webrtcConnections.current[streamName];\n\n      // Abort any pending fetch requests\n      if (connection.abortController) {\n        console.log(`Aborting pending WebRTC requests for stream ${streamName}`);\n        try {\n          connection.abortController.abort();\n        } catch (e) {\n          console.error(`Error aborting WebRTC request for stream ${streamName}:`, e);\n        }\n      }\n\n      // Remove all event listeners to prevent memory leaks\n      if (connection.onicecandidate) connection.onicecandidate = null;\n      if (connection.oniceconnectionstatechange) connection.oniceconnectionstatechange = null;\n      if (connection.onconnectionstatechange) connection.onconnectionstatechange = null;\n      if (connection.ontrack) connection.ontrack = null;\n\n      // Close the connection\n      connection.close();\n\n      // Remove from our reference object\n      delete webrtcConnections.current[streamName];\n\n      console.log(`Closed WebRTC connection for stream ${streamName}`);\n    }\n\n    // Clean up detection polling\n    cleanupDetectionPolling(streamName, detectionIntervals.current);\n  };\n\n  /**\n   * Stop all WebRTC streams\n   */\n  const stopAllWebRTCStreams = () => {\n    console.log('Stopping all WebRTC streams');\n    // Close all RTCPeerConnections\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      cleanupWebRTCPlayer(streamName);\n    });\n    console.log('All WebRTC streams stopped');\n  };\n\n// Note: takeSnapshot is now provided by the useSnapshotManager hook\n\n  /**\n   * Toggle fullscreen mode for a specific stream\n   * @param {string} streamName - Stream name\n   * @param {Event} event - Click event\n   */\n  const toggleStreamFullscreen = (streamName, event) => {\n    // Prevent default button behavior\n    if (event) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (!streamName) {\n      console.error('Stream name not provided for fullscreen toggle');\n      return;\n    }\n\n    console.log(`Toggling fullscreen for stream: ${streamName}`);\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n\n    if (!videoCell) {\n      console.error('Stream not found:', streamName);\n      return;\n    }\n\n    if (!document.fullscreenElement) {\n      console.log('Entering fullscreen mode for video cell');\n      videoCell.requestFullscreen().catch(err => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n      });\n    } else {\n      console.log('Exiting fullscreen mode');\n      document.exitFullscreen();\n    }\n  };\n\n  return (\n    <section id=\"live-page\" className={`page ${isFullscreen ? 'fullscreen-mode' : ''}`}>\n      {/* Include the SnapshotManager component */}\n      <SnapshotManager />\n      {/* Include the FullscreenManager component */}\n      <FullscreenManager isFullscreen={isFullscreen} setIsFullscreen={setIsFullscreen} targetId=\"live-page\" />\n      <div className=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\">\n        <div className=\"flex items-center space-x-2\">\n          <h2 className=\"text-xl font-bold mr-4\">Live View</h2>\n          <div className=\"flex space-x-2\">\n            <button\n              id=\"hls-toggle-btn\"\n              className=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick={() => window.location.href = '/hls.html'}\n            >\n              HLS View\n            </button>\n          </div>\n        </div>\n        <div className=\"controls flex items-center space-x-2\">\n          <div className=\"flex items-center\">\n            <label for=\"layout-selector\" className=\"mr-2\">Layout:</label>\n            <select\n                id=\"layout-selector\"\n                className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                value={layout}\n                onChange={(e) => {\n                  const newLayout = e.target.value;\n                  setLayout(newLayout);\n                  setCurrentPage(0); // Reset to first page when layout changes\n                  // URL will be updated by the useEffect hook\n                }}\n            >\n              <option value=\"1\">1 Stream</option>\n              <option value=\"2\">2 Streams</option>\n              <option value=\"4\" selected>4 Streams</option>\n              <option value=\"6\">6 Streams</option>\n              <option value=\"9\">9 Streams</option>\n              <option value=\"16\">16 Streams</option>\n            </select>\n          </div>\n\n          {layout === '1' && (\n              <div className=\"flex items-center\">\n                <label for=\"stream-selector\" className=\"mr-2\">Stream:</label>\n                <select\n                    id=\"stream-selector\"\n                    className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                    value={selectedStream}\n                    onChange={(e) => {\n                      const newStream = e.target.value;\n                      setSelectedStream(newStream);\n                      // URL will be updated by the useEffect hook\n                    }}\n                >\n                  {streams.map(stream =>\n                      <option key={stream.name} value={stream.name}>{stream.name}</option>\n                  )}\n                </select>\n              </div>\n          )}\n\n          <button\n              id=\"fullscreen-btn\"\n              className=\"p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 focus:outline-none\"\n              onClick={() => toggleFullscreen()}\n              title=\"Toggle Fullscreen\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\"\n                 stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n              <path\n                  d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path>\n            </svg>\n          </button>\n        </div>\n      </div>\n\n      <div className=\"flex flex-col space-y-4\">\n        <div\n            id=\"video-grid\"\n            className={`video-container layout-${layout}`}\n            ref={videoGridRef}\n        >\n          {isLoadingStreams ? (\n              <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n                <div className=\"flex flex-col items-center justify-center py-8\">\n                  <div\n                      className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                  <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (isLoading && !isLoadingStreams) ? (\n            <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n              <div className=\"flex flex-col items-center justify-center py-8\">\n                <div\n                    className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (streamsError) ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">Error loading streams: {streamsError.message}</p>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\"\n              >\n                Retry\n              </button>\n            </div>\n          ) : streams.length === 0 ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n              <a href=\"streams.html\" className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n            </div>\n          ) : (\n            // Render video cells using our WebRTCVideoCell component\n            getStreamsToShow().map(stream => (\n              <WebRTCVideoCell\n                key={stream.name}\n                stream={stream}\n                onTakeSnapshot={takeSnapshot}\n                onToggleFullscreen={toggleStreamFullscreen}\n                webrtcConnections={webrtcConnections}\n                detectionIntervals={detectionIntervals}\n                initializeWebRTCPlayer={initializeWebRTCPlayer}\n                cleanupWebRTCPlayer={cleanupWebRTCPlayer}\n              />\n            ))\n          )}\n        </div>\n\n        {layout !== '1' && streams.length > getMaxStreamsForLayout() ? (\n          <div className=\"pagination-controls flex justify-center items-center space-x-4 mt-4\">\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to previous page');\n                setCurrentPage(Math.max(0, currentPage - 1));\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                const newPage = currentPage - 1;\n\n                if (newPage > 0) {\n                  url.searchParams.set('page', newPage + 1);\n                  sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n                } else {\n                  url.searchParams.delete('page');\n                  sessionStorage.removeItem('webrtc_current_page');\n                }\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage === 0}\n            >\n              Previous\n            </button>\n\n            <span className=\"text-gray-700 dark:text-gray-300\">\n              Page {currentPage + 1} of {Math.ceil(streams.length / getMaxStreamsForLayout())}\n            </span>\n\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to next page');\n                const newPage = Math.min(Math.ceil(streams.length / getMaxStreamsForLayout()) - 1, currentPage + 1);\n                setCurrentPage(newPage);\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                url.searchParams.set('page', newPage + 1);\n                sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage >= Math.ceil(streams.length / getMaxStreamsForLayout()) - 1}\n            >\n              Next\n            </button>\n          </div>\n        ) : null}\n      </div>\n    </section>\n  );\n}\n","/**\n * LightNVR Web Interface Live View Page\n * Entry point for the live view page with WebRTC/HLS support\n */\n\nimport { render } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { LiveView } from '../components/preact/LiveView.jsx';\nimport { WebRTCView } from '../components/preact/WebRTCView.jsx';\nimport { QueryClientProvider, queryClient } from '../query-client.js';\nimport { Header } from \"../components/preact/Header.jsx\";\nimport { Footer } from \"../components/preact/Footer.jsx\";\nimport { ToastContainer } from \"../components/preact/ToastContainer.jsx\";\n\n/**\n * Main App component that conditionally renders WebRTCView or LiveView\n * based on whether WebRTC is disabled in settings\n */\nfunction App() {\n    const [isWebRTCDisabled, setIsWebRTCDisabled] = useState(false);\n    const [isLoading, setIsLoading] = useState(true);\n\n    useEffect(() => {\n        // Check if WebRTC is disabled in settings\n        async function checkWebRTCStatus() {\n            try {\n                const response = await fetch('/api/settings');\n                if (!response.ok) {\n                    console.error('Failed to fetch settings:', response.status, response.statusText);\n                    setIsLoading(false);\n                    return;\n                }\n\n                const settings = await response.json();\n                \n                if (settings.webrtc_disabled) {\n                    console.log('WebRTC is disabled, using HLS view');\n                    setIsWebRTCDisabled(true);\n                } else {\n                    console.log('WebRTC is enabled, using WebRTC view');\n                    setIsWebRTCDisabled(false);\n                }\n            } catch (error) {\n                console.error('Error checking WebRTC status:', error);\n            } finally {\n                setIsLoading(false);\n            }\n        }\n\n        checkWebRTCStatus();\n    }, []);\n\n    if (isLoading) {\n        return <div className=\"loading\">Loading...</div>;\n    }\n\n    return (\n        <>\n            <Header />\n            <ToastContainer />\n            {isWebRTCDisabled ? <LiveView isWebRTCDisabled={true} /> : <WebRTCView />}\n            <Footer />\n        </>\n    );\n}\n\n// Render the App component when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Get the container element\n    const container = document.getElementById('main-content');\n\n    if (container) {\n        render(\n            <QueryClientProvider client={queryClient}>\n                <App />\n            </QueryClientProvider>,\n            container\n        );\n    }\n});\n"],"names":["spinnerStyle","style","WebRTCVideoCell","stream","onTakeSnapshot","onToggleFullscreen","webrtcConnections","detectionIntervals","initializeWebRTCPlayer","cleanupWebRTCPlayer","isLoading","setIsLoading","useState","error","setError","videoRef","useRef","canvasRef","cellRef","useEffect","initTimeout","startDetectionPolling","errorMessage","handleRetry","secondErrorMessage","jsxs","jsx","e","SnapshotButton","WebRTCView","takeSnapshot","useSnapshotManager","isFullscreen","setIsFullscreen","toggleFullscreen","useFullscreenManager","webrtcOfferMutation","useMutation","data","streamName","offerData","auth","response","text","jsonError","variables","streams","setStreams","layout","setLayout","layoutParam","selectedStream","setSelectedStream","streamParam","currentPage","setCurrentPage","pageParam","storedPage","videoGridRef","setupModals","addModalStyles","handleBeforeUnload","url","connectionCheckInterval","pc","s","stopAllWebRTCStreams","queryClient","useQueryClient","streamsData","isLoadingStreams","streamsError","useQuery","filteredStreams","filterStreamsForWebRTC","showStatusMessage","previousValues","prev","updateVideoGrid","updateURLTimeout","streamPromises","streamId","detailedStreams","getMaxStreamsForLayout","getStreamsToShow","streamsToShow","maxStreams","totalPages","startIdx","endIdx","streamsToShowNames","connectionsToCleanup","videoElement","canvasOverlay","callbacks","event","offerOptions","setupTimeoutId","videoPlaybackTimeoutId","checkConnectionExists","offer","sendOffer","answer","useCallback","formattedOffer","abortController","signal","result","connection","cleanupDetectionPolling","toggleStreamFullscreen","videoElementId","videoCell","err","SnapshotManager","FullscreenManager","newLayout","newStream","newPage","App","isWebRTCDisabled","setIsWebRTCDisabled","checkWebRTCStatus","Fragment","Header","ToastContainer","LiveView","Footer","container","render","QueryClientProvider"],"mappings":"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"}