{"version":3,"mappings":"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","names":["WebRTCView","streams","setStreams","useState","layout","setLayout","selectedStream","setSelectedStream","isFullscreen","setIsFullscreen","isLoading","setIsLoading","currentPage","setCurrentPage","videoGridRef","useRef","webrtcConnections","detectionIntervals","useEffect","setupModals","addStatusMessageStyles","addModalStyles","handleEscape","e","livePage","exitFullscreenMode","handleBeforeUnload","stopAllWebRTCStreams","handleVisibilityChange","streamName","pc","videoElementId","videoElement","connectionCheckInterval","cleanupWebRTCPlayer","stream","s","initializeWebRTCPlayer","timeoutId","showStatusMessage","loadStreams","streamData","error","updateVideoGrid","timeoutPromise","_","reject","fetchPromise","response","jsonTimeoutPromise","jsonPromise","streamPromises","detailsTimeoutPromise","detailsFetchPromise","detailedStreams","filteredStreams","getMaxStreamsForLayout","placeholder","streamsToShow","maxStreams","totalPages","startIdx","endIdx","streamsToShowNames","streamId","videoCell","snapshotBtn","takeSnapshot","fullscreenBtn","toggleStreamFullscreen","loadingIndicator","canvasId","canvasOverlay","event","handleWebRTCError","offerOptions","setupTimeoutId","offer","sendOffer","answer","startDetectionPolling","auth","formattedOffer","controller","signal","jsonController","jsonSignal","jsonTimeoutId","text","jsonError","textError","fetchError","message","errorIndicator","retryButton","streamInfo","errorMsg","cleanupDetectionPolling","streamElement","canvas","timestamp","fileName","showSnapshotPreview","err","html","_f","__template","toggleFullscreen","_b","_a","_c","_d","_e","loadWebRTCView","mainContent","__vitePreload","render","n","_g"],"ignoreList":[],"sources":["../../js/components/preact/WebRTCView.js"],"sourcesContent":["/**\n * LightNVR Web Interface WebRTCView Component\n * Preact component for the WebRTC view page\n */\n\nimport { h } from '../../preact.min.js';\nimport { html } from '../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../preact.hooks.module.js';\nimport { showStatusMessage, showSnapshotPreview, setupModals, addStatusMessageStyles, addModalStyles } from './UI.js';\nimport { toggleFullscreen, exitFullscreenMode } from './FullscreenManager.js';\nimport { startDetectionPolling, cleanupDetectionPolling } from './DetectionOverlay.js';\n\n/**\n * WebRTCView component\n * @returns {JSX.Element} WebRTCView component\n */\nexport function WebRTCView() {\n  const [streams, setStreams] = useState([]);\n  const [layout, setLayout] = useState('4');\n  const [selectedStream, setSelectedStream] = useState('');\n  const [isFullscreen, setIsFullscreen] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [currentPage, setCurrentPage] = useState(0);\n  const videoGridRef = useRef(null);\n  const webrtcConnections = useRef({});\n  const detectionIntervals = useRef({});\n  \n  // Set up event listeners and UI components\n  useEffect(() => {\n    // Set up modals for snapshot preview\n    setupModals();\n    addStatusMessageStyles();\n    addModalStyles();\n    \n    // Set up Escape key to exit fullscreen mode\n    const handleEscape = (e) => {\n      if (e.key === 'Escape') {\n        console.log(\"Escape key pressed, current fullscreen state:\", isFullscreen);\n        // Check if we're in fullscreen mode by checking the DOM directly\n        const livePage = document.getElementById('live-page');\n        if (livePage && livePage.classList.contains('fullscreen-mode')) {\n          console.log(\"Detected fullscreen mode via DOM, exiting fullscreen\");\n          exitFullscreenMode(null, setIsFullscreen);\n        }\n      }\n    };\n    \n    document.addEventListener('keydown', handleEscape);\n    \n    // Add event listener to stop streams when leaving the page\n    const handleBeforeUnload = () => {\n      stopAllWebRTCStreams();\n    };\n    \n    // Add event listener for visibility change to handle tab switching\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        console.log(\"Page hidden, pausing WebRTC streams\");\n        // Mark connections as inactive but don't close them yet\n        Object.keys(webrtcConnections.current).forEach(streamName => {\n          const pc = webrtcConnections.current[streamName];\n          if (pc && pc.connectionState !== 'closed') {\n            // Pause video elements to reduce resource usage\n            const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n            const videoElement = document.getElementById(videoElementId);\n            if (videoElement) {\n              videoElement.pause();\n            }\n          }\n        });\n      } else {\n        console.log(\"Page visible, resuming WebRTC streams\");\n        // Resume video playback\n        Object.keys(webrtcConnections.current).forEach(streamName => {\n          const pc = webrtcConnections.current[streamName];\n          if (pc && pc.connectionState !== 'closed') {\n            const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n            const videoElement = document.getElementById(videoElementId);\n            if (videoElement) {\n              videoElement.play().catch(e => {\n                console.warn(`Could not resume video for ${streamName}:`, e);\n              });\n            }\n          }\n        });\n      }\n    };\n    \n    window.addEventListener('beforeunload', handleBeforeUnload);\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Set up periodic connection check\n    const connectionCheckInterval = setInterval(() => {\n      Object.keys(webrtcConnections.current).forEach(streamName => {\n        const pc = webrtcConnections.current[streamName];\n        if (pc) {\n          // Log connection state for debugging\n          console.debug(`WebRTC connection state for ${streamName}: ${pc.connectionState}, ICE state: ${pc.iceConnectionState}`);\n          \n          // If connection is failed or disconnected for too long, try to reconnect\n          if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n            console.warn(`WebRTC connection for ${streamName} is in ${pc.iceConnectionState} state, will attempt reconnect`);\n            \n            // Clean up the old connection\n            cleanupWebRTCPlayer(streamName);\n            \n            // Find the stream info and reinitialize\n            const stream = streams.find(s => s.name === streamName);\n            if (stream) {\n              console.log(`Attempting to reconnect WebRTC for stream ${streamName}`);\n              initializeWebRTCPlayer(stream);\n            }\n          }\n        }\n      });\n    }, 30000); // Check every 30 seconds\n    \n    // Cleanup\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      clearInterval(connectionCheckInterval);\n      stopAllWebRTCStreams();\n    };\n  }, [streams]); // Add streams as dependency to ensure we have the latest stream data\n  \n  // Load streams after the component has rendered and videoGridRef is available\n  useEffect(() => {\n      // Set loading state initially\n      setIsLoading(true);\n      \n      // Create a timeout to handle potential stalls in loading\n      const timeoutId = setTimeout(() => {\n        console.warn('Stream loading timed out');\n        setIsLoading(false);\n        showStatusMessage('Loading streams timed out. Please try refreshing the page.');\n      }, 15000); // 15 second timeout\n      \n      // Load streams from API with timeout handling\n      loadStreams()\n        .then((streamData) => {\n          clearTimeout(timeoutId);\n          if (streamData && streamData.length > 0) {\n            setStreams(streamData);\n            setSelectedStream(streamData[0].name);\n          } else {\n            console.warn('No streams returned from API');\n          }\n          setIsLoading(false);\n        })\n        .catch((error) => {\n          clearTimeout(timeoutId);\n          console.error('Error loading streams:', error);\n          showStatusMessage('Error loading streams: ' + error.message);\n          setIsLoading(false);\n        });\n  }, []);\n  \n  // Update video grid when layout, page, or streams change\n  useEffect(() => {\n    updateVideoGrid();\n  }, [layout, selectedStream, streams, currentPage]);\n  \n  /**\n   * Load streams from API\n   * @returns {Promise<Array>} Promise resolving to array of streams\n   */\n  const loadStreams = async () => {\n    try {\n      // Create a timeout promise to handle potential stalls\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Request timed out')), 5000); // 5 second timeout\n      });\n      \n      // Fetch streams from API with timeout\n      const fetchPromise = fetch('/api/streams');\n      const response = await Promise.race([fetchPromise, timeoutPromise]);\n      \n      if (!response.ok) {\n        throw new Error('Failed to load streams');\n      }\n      \n      // Create another timeout for the JSON parsing\n      const jsonTimeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('JSON parsing timed out')), 3000); // 3 second timeout\n      });\n      \n      const jsonPromise = response.json();\n      const data = await Promise.race([jsonPromise, jsonTimeoutPromise]);\n      \n      // For WebRTC view, we need to fetch full details for each stream\n      const streamPromises = (data || []).map(stream => {\n        // Create a timeout promise for this stream's details fetch\n        const detailsTimeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(new Error(`Timeout fetching details for stream ${stream.name}`)), 3000);\n        });\n        \n        // Fetch stream details with timeout\n        const detailsFetchPromise = fetch(`/api/streams/${encodeURIComponent(stream.id || stream.name)}`)\n          .then(response => {\n            if (!response.ok) {\n              throw new Error(`Failed to load details for stream ${stream.name}`);\n            }\n            return response.json();\n          });\n          \n        // Race the fetch against the timeout\n        return Promise.race([detailsFetchPromise, detailsTimeoutPromise])\n          .catch(error => {\n            console.error(`Error loading details for stream ${stream.name}:`, error);\n            // Return the basic stream info if we can't get details\n            return stream;\n          });\n      });\n      \n      const detailedStreams = await Promise.all(streamPromises);\n      console.log('Loaded detailed streams for WebRTC view:', detailedStreams);\n      \n      // Filter out streams that are soft deleted, inactive, or not configured for HLS\n      const filteredStreams = detailedStreams.filter(stream => {\n        // Filter out soft deleted streams\n        if (stream.is_deleted) {\n          console.log(`Stream ${stream.name} is soft deleted, filtering out`);\n          return false;\n        }\n        \n        // Filter out inactive streams\n        if (!stream.enabled) {\n          console.log(`Stream ${stream.name} is inactive, filtering out`);\n          return false;\n        }\n        \n        // Filter out streams not configured for HLS\n        if (!stream.streaming_enabled) {\n          console.log(`Stream ${stream.name} is not configured for HLS, filtering out`);\n          return false;\n        }\n        \n        return true;\n      });\n      \n      console.log('Filtered streams for WebRTC view:', filteredStreams);\n      \n      return filteredStreams || [];\n    } catch (error) {\n      console.error('Error loading streams for WebRTC view:', error);\n      showStatusMessage('Error loading streams: ' + error.message);\n      \n      return [];\n    }\n  };\n  \n  /**\n   * Get maximum number of streams to display based on layout\n   * @returns {number} Maximum number of streams\n   */\n  const getMaxStreamsForLayout = () => {\n    switch (layout) {\n      case '1': return 1;  // Single view\n      case '2': return 2;  // 2x1 grid\n      case '4': return 4;  // 2x2 grid\n      case '6': return 6;  // 2x3 grid\n      case '9': return 9;  // 3x3 grid\n      case '16': return 16; // 4x4 grid\n      default: return 4;\n    }\n  };\n\n  /**\n   * Update video grid based on layout, streams, and pagination\n   */\n  const updateVideoGrid = () => {\n    if (!videoGridRef.current) return;\n    \n    // Clear existing content except placeholder\n    const placeholder = videoGridRef.current.querySelector('.placeholder');\n    videoGridRef.current.innerHTML = '';\n    \n    // If placeholder exists and no streams, add it back\n    if (placeholder && streams.length === 0) {\n      videoGridRef.current.appendChild(placeholder);\n      return;\n    }\n    \n    // Filter streams based on layout and selected stream\n    let streamsToShow = streams;\n    if (layout === '1' && selectedStream) {\n      streamsToShow = streams.filter(stream => stream.name === selectedStream);\n    } else {\n      // Apply pagination\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n      \n      // Ensure current page is valid\n      if (currentPage >= totalPages) {\n        setCurrentPage(Math.max(0, totalPages - 1));\n        return; // Will re-render with corrected page\n      }\n      \n      // Get streams for current page\n      const startIdx = currentPage * maxStreams;\n      const endIdx = Math.min(startIdx + maxStreams, streams.length);\n      streamsToShow = streams.slice(startIdx, endIdx);\n    }\n    \n    // Get names of streams that should be shown\n    const streamsToShowNames = streamsToShow.map(stream => stream.name);\n    \n    // Clean up connections for streams that are no longer visible\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      if (!streamsToShowNames.includes(streamName)) {\n        console.log(`Cleaning up WebRTC connection for stream ${streamName} (not visible in current view)`);\n        cleanupWebRTCPlayer(streamName);\n      }\n    });\n    \n    // Add video elements for each stream\n    streamsToShow.forEach(stream => {\n      // Ensure we have an ID for the stream (use name as fallback if needed)\n      const streamId = stream.id || stream.name;\n      \n      const videoCell = document.createElement('div');\n      videoCell.className = 'video-cell';\n      \n      videoCell.innerHTML = `\n        <video id=\"video-${stream.name.replace(/\\s+/g, '-')}\" autoplay muted></video>\n        <div class=\"stream-info\">\n          <span>${stream.name}</span>\n          <span>${stream.width}x${stream.height} · ${stream.fps}fps</span>\n          <div class=\"stream-controls\">\n            <button class=\"snapshot-btn\" data-id=\"${streamId}\" data-name=\"${stream.name}\">\n              <span>📷</span> Snapshot\n            </button>\n            <button class=\"fullscreen-btn\" data-id=\"${streamId}\" data-name=\"${stream.name}\">\n              <span>⛶</span> Fullscreen\n            </button>\n          </div>\n        </div>\n        <div class=\"loading-indicator\">\n          <div class=\"loading-spinner\"></div>\n          <span>Connecting WebRTC...</span>\n        </div>\n      `;\n      \n      videoGridRef.current.appendChild(videoCell);\n      \n      // Initialize WebRTC player\n      initializeWebRTCPlayer(stream);\n      \n      // Add event listeners for buttons\n      const snapshotBtn = videoCell.querySelector('.snapshot-btn');\n      if (snapshotBtn) {\n        snapshotBtn.addEventListener('click', () => {\n          takeSnapshot(streamId);\n        });\n      }\n      \n      const fullscreenBtn = videoCell.querySelector('.fullscreen-btn');\n      if (fullscreenBtn) {\n        fullscreenBtn.addEventListener('click', () => {\n          toggleStreamFullscreen(stream.name);\n        });\n      }\n    });\n  };\n  \n  /**\n   * Initialize WebRTC player for a stream\n   * @param {Object} stream - Stream object\n   */\n  const initializeWebRTCPlayer = (stream) => {\n    const videoElementId = `video-${stream.name.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n    \n    if (!videoElement || !videoCell) return;\n    \n    // Show loading state\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'flex';\n    }\n    \n    // Create canvas overlay for detection bounding boxes\n    const canvasId = `canvas-${stream.name.replace(/\\s+/g, '-')}`;\n    let canvasOverlay = document.getElementById(canvasId);\n    \n    if (!canvasOverlay) {\n      canvasOverlay = document.createElement('canvas');\n      canvasOverlay.id = canvasId;\n      canvasOverlay.className = 'detection-overlay';\n      canvasOverlay.style.position = 'absolute';\n      canvasOverlay.style.top = '0';\n      canvasOverlay.style.left = '0';\n      canvasOverlay.style.width = '100%';\n      canvasOverlay.style.height = '100%';\n      canvasOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through\n      videoCell.appendChild(canvasOverlay);\n    }\n    \n    // Create a new RTCPeerConnection with ICE servers\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ],\n      // Add additional configuration to ensure proper ICE credentials\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'balanced',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'unified-plan'\n    });\n    \n    // Store the connection for cleanup\n    webrtcConnections.current[stream.name] = pc;\n    \n    // Add event listeners\n    pc.ontrack = (event) => {\n      console.log(`Track received for stream ${stream.name}:`, event);\n      if (event.track.kind === 'video') {\n        videoElement.srcObject = event.streams[0];\n        \n        // Hide loading indicator when video starts playing\n        videoElement.onloadeddata = () => {\n          if (loadingIndicator) {\n            loadingIndicator.style.display = 'none';\n          }\n        };\n      }\n    };\n    \n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log(`ICE candidate for stream ${stream.name}:`, event.candidate);\n        // go2rtc doesn't use a separate ICE endpoint, so we don't need to send ICE candidates\n      }\n    };\n    \n    pc.oniceconnectionstatechange = () => {\n      console.log(`ICE connection state for stream ${stream.name}:`, pc.iceConnectionState);\n      if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n        // Handle connection failure\n        handleWebRTCError(stream.name, 'WebRTC connection failed');\n      }\n    };\n    \n    // Add transceivers to ensure we get both audio and video tracks\n    pc.addTransceiver('video', {direction: 'recvonly'});\n    pc.addTransceiver('audio', {direction: 'recvonly'});\n    \n    // Create an offer with specific codec requirements\n    const offerOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n    \n    // Create a timeout for the entire WebRTC setup process\n    const setupTimeoutId = setTimeout(() => {\n      console.warn(`WebRTC setup timed out for stream ${stream.name}`);\n      handleWebRTCError(stream.name, 'WebRTC setup timed out');\n      \n      // Clean up the connection if it exists\n      if (webrtcConnections.current[stream.name]) {\n        cleanupWebRTCPlayer(stream.name);\n      }\n    }, 15000); // 15 second timeout for the entire setup process\n    \n    pc.createOffer(offerOptions)\n      .then(offer => {\n        console.log(`Created offer for stream ${stream.name}:`, offer);\n        \n        // Log the original SDP to ensure it has ice-ufrag and ice-pwd\n        console.log(`Original SDP for stream ${stream.name}:`, offer.sdp);\n        \n        // Check if the SDP has ice-ufrag and ice-pwd\n        if (!offer.sdp.includes('a=ice-ufrag:') || !offer.sdp.includes('a=ice-pwd:')) {\n          console.warn(`SDP for stream ${stream.name} is missing ice-ufrag or ice-pwd!`);\n        }\n        \n        // We'll use the original offer without modifications to preserve ice-ufrag and ice-pwd\n        console.log(`Using original offer for stream ${stream.name}`);\n        return pc.setLocalDescription(offer);\n      })\n      .then(() => {\n        console.log(`Set local description for stream ${stream.name}`);\n        // Send the offer to the server\n        return sendOffer(stream.name, pc.localDescription);\n      })\n      .then(answer => {\n        console.log(`Received answer for stream ${stream.name}:`, answer);\n        // Set the remote description\n        return pc.setRemoteDescription(new RTCSessionDescription(answer));\n      })\n      .then(() => {\n        console.log(`Set remote description for stream ${stream.name}`);\n        \n        // Clear the setup timeout since we've successfully set up the connection\n        clearTimeout(setupTimeoutId);\n        \n        // Start detection polling if detection is enabled for this stream\n        console.log(`Stream ${stream.name} detection settings:`, {\n          detection_based_recording: stream.detection_based_recording,\n          detection_model: stream.detection_model,\n          detection_threshold: stream.detection_threshold\n        });\n        \n        if (stream.detection_based_recording && stream.detection_model) {\n          console.log(`Starting detection polling for stream ${stream.name}`);\n          startDetectionPolling(stream.name, canvasOverlay, videoElement, detectionIntervals.current);\n        } else {\n          console.log(`Detection not enabled for stream ${stream.name}`);\n        }\n      })\n      .catch(error => {\n        // Clear the setup timeout\n        clearTimeout(setupTimeoutId);\n        \n        console.error(`Error setting up WebRTC for stream ${stream.name}:`, error);\n        handleWebRTCError(stream.name, error.message);\n      });\n  };\n  \n  /**\n   * Send WebRTC offer to server\n   * @param {string} streamName - Stream name\n   * @param {RTCSessionDescription} offer - WebRTC offer\n   * @returns {Promise<RTCSessionDescription>} Promise resolving to WebRTC answer\n   */\n  const sendOffer = async (streamName, offer) => {\n    try {\n      // Get auth from localStorage\n      const auth = localStorage.getItem('auth');\n      \n      // Send the offer to the server\n      // Format the offer according to go2rtc expectations\n      const formattedOffer = {\n        type: offer.type,\n        sdp: offer.sdp\n      };\n      \n      console.log(`Sending formatted offer for stream ${streamName}:`, formattedOffer);\n      \n      // Create an AbortController for the fetch request\n      const controller = new AbortController();\n      const signal = controller.signal;\n      \n      // Set a timeout to abort the fetch after 8 seconds\n      const timeoutId = setTimeout(() => {\n        console.warn(`Aborting WebRTC offer request for stream ${streamName} due to timeout`);\n        controller.abort();\n      }, 8000);\n      \n      try {\n        // Note: Session cookie is automatically included in fetch requests\n        // We only need to add the Authorization header if we have it in localStorage\n        const response = await fetch(`/api/webrtc?src=${encodeURIComponent(streamName)}`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(auth ? { 'Authorization': 'Basic ' + auth } : {})\n          },\n          body: JSON.stringify(formattedOffer),\n          signal: signal\n        });\n        \n        // Clear the timeout since the request completed\n        clearTimeout(timeoutId);\n        \n        if (!response.ok) {\n          throw new Error(`Failed to send offer: ${response.status} ${response.statusText}`);\n        }\n        \n        // Create another AbortController for the JSON parsing\n        const jsonController = new AbortController();\n        const jsonSignal = jsonController.signal;\n        \n        // Set a timeout to abort the JSON parsing after 5 seconds\n        const jsonTimeoutId = setTimeout(() => {\n          console.warn(`Aborting JSON parsing for stream ${streamName} due to timeout`);\n          jsonController.abort();\n        }, 5000);\n        \n        try {\n          // Use a separate try/catch for the JSON parsing\n          const text = await response.text();\n          \n          // Clear the JSON timeout\n          clearTimeout(jsonTimeoutId);\n          \n          // Try to parse the JSON\n          try {\n            const answer = JSON.parse(text);\n            return answer;\n          } catch (jsonError) {\n            console.error(`Error parsing JSON for stream ${streamName}:`, jsonError);\n            console.log(`Raw response text: ${text}`);\n            throw new Error(`Failed to parse WebRTC answer: ${jsonError.message}`);\n          }\n        } catch (textError) {\n          // Clear the JSON timeout if it hasn't been cleared yet\n          clearTimeout(jsonTimeoutId);\n          \n          if (textError.name === 'AbortError') {\n            throw new Error(`WebRTC answer parsing timed out for stream ${streamName}`);\n          }\n          throw textError;\n        }\n      } catch (fetchError) {\n        // Clear the timeout if it hasn't been cleared yet\n        clearTimeout(timeoutId);\n        \n        if (fetchError.name === 'AbortError') {\n          throw new Error(`WebRTC offer request timed out for stream ${streamName}`);\n        }\n        throw fetchError;\n      }\n    } catch (error) {\n      console.error(`Error sending offer for stream ${streamName}:`, error);\n      throw error;\n    }\n  };\n  \n  // ICE candidates are handled internally by the browser for go2rtc\n  \n  /**\n   * Handle WebRTC error\n   * @param {string} streamName - Stream name\n   * @param {string} message - Error message\n   */\n  const handleWebRTCError = (streamName, message) => {\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n    \n    if (!videoCell) return;\n    \n    // Hide loading indicator\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'none';\n    }\n    \n    // Create error indicator if it doesn't exist\n    let errorIndicator = videoCell.querySelector('.error-indicator');\n    if (!errorIndicator) {\n      errorIndicator = document.createElement('div');\n      errorIndicator.className = 'error-indicator';\n      videoCell.appendChild(errorIndicator);\n    }\n    \n    errorIndicator.innerHTML = `\n      <div class=\"error-icon\">!</div>\n      <p>${message || 'WebRTC connection failed'}</p>\n      <button class=\"retry-button mt-4 px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Retry</button>\n    `;\n    \n    // Add retry button handler\n    const retryButton = errorIndicator.querySelector('.retry-button');\n    if (retryButton) {\n      retryButton.addEventListener('click', () => {\n        // Show loading indicator again\n        if (loadingIndicator) {\n          loadingIndicator.style.display = 'flex';\n        }\n        \n        // Hide error indicator\n        errorIndicator.style.display = 'none';\n        \n        // Cleanup existing connection\n        cleanupWebRTCPlayer(streamName);\n        \n        // Fetch stream info again and reinitialize\n        fetch(`/api/streams/${encodeURIComponent(streamName)}`)\n          .then(response => response.json())\n          .then(streamInfo => {\n            // Reinitialize\n            initializeWebRTCPlayer(streamInfo);\n          })\n          .catch(error => {\n            console.error('Error fetching stream info:', error);\n            \n            // Show error indicator again with new message\n            errorIndicator.style.display = 'flex';\n            const errorMsg = errorIndicator.querySelector('p');\n            if (errorMsg) {\n              errorMsg.textContent = 'Could not reconnect: ' + error.message;\n            }\n            \n            // Hide loading indicator\n            if (loadingIndicator) {\n              loadingIndicator.style.display = 'none';\n            }\n          });\n      });\n    }\n  };\n  \n  /**\n   * Cleanup WebRTC player\n   * @param {string} streamName - Stream name\n   */\n  const cleanupWebRTCPlayer = (streamName) => {\n    // Close and remove the RTCPeerConnection\n    if (webrtcConnections.current[streamName]) {\n      webrtcConnections.current[streamName].close();\n      delete webrtcConnections.current[streamName];\n    }\n    \n    // Reset video element\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    if (videoElement) {\n      videoElement.srcObject = null;\n    }\n    \n    // Clean up detection polling\n    cleanupDetectionPolling(streamName, detectionIntervals.current);\n  };\n  \n  /**\n   * Stop all WebRTC streams\n   */\n  const stopAllWebRTCStreams = () => {\n    // Close all RTCPeerConnections\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      cleanupWebRTCPlayer(streamName);\n    });\n  };\n  \n/**\n * Take snapshot of a stream\n * @param {string} streamId - Stream ID\n */\nconst takeSnapshot = (streamId) => {\n  // Find the stream by ID or name\n  const streamElement = document.querySelector(`.snapshot-btn[data-id=\"${streamId}\"]`);\n  if (!streamElement) {\n    console.error('Stream element not found for ID:', streamId);\n    return;\n  }\n\n  // Get the stream name from the data attribute\n  const streamName = streamElement.getAttribute('data-name');\n  if (!streamName) {\n    console.error('Stream name not found for ID:', streamId);\n    return;\n  }\n\n  // Find the video element\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  if (!videoElement) {\n    console.error('Video element not found for stream:', streamName);\n    return;\n  }\n\n  // Create a canvas element to capture the frame\n  const canvas = document.createElement('canvas');\n  canvas.width = videoElement.videoWidth;\n  canvas.height = videoElement.videoHeight;\n\n  // Check if we have valid dimensions\n  if (canvas.width === 0 || canvas.height === 0) {\n    console.error('Invalid video dimensions:', canvas.width, canvas.height);\n    showStatusMessage('Cannot take snapshot: Video not loaded or has invalid dimensions');\n    return;\n  }\n\n  // Draw the current frame to the canvas\n  const ctx = canvas.getContext('2d');\n  ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);\n\n  try {\n    // Save the canvas to global scope for direct access in the overlay\n    window.__snapshotCanvas = canvas;\n    \n    // Generate a filename\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = `snapshot-${streamName.replace(/\\s+/g, '-')}-${timestamp}.jpg`;\n    window.__snapshotFileName = fileName;\n    \n    // Show the standard preview\n    showSnapshotPreview(canvas.toDataURL('image/jpeg', 0.95), `Snapshot: ${streamName}`);\n    \n    // Show success message\n    showStatusMessage('Snapshot taken successfully');\n  } catch (error) {\n    console.error('Error creating snapshot:', error);\n    showStatusMessage('Failed to create snapshot: ' + error.message);\n  }\n};\n  \n  /**\n   * Toggle fullscreen mode for a specific stream\n   * @param {string} streamName - Stream name\n   */\n  const toggleStreamFullscreen = (streamName) => {\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n    \n    if (!videoCell) {\n      console.error('Stream not found:', streamName);\n      return;\n    }\n    \n    if (!document.fullscreenElement) {\n      videoCell.requestFullscreen().catch(err => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n      });\n    } else {\n      document.exitFullscreen();\n    }\n  };\n  \n  return html`\n    <section id=\"live-page\" class=\"page\">\n      <div class=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\">\n        <div class=\"flex items-center space-x-2\">\n          <h2 class=\"text-xl font-bold mr-4\">Live View</h2>\n          <div class=\"flex space-x-2\">\n            <button \n              id=\"hls-toggle-btn\" \n              class=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick=${() => window.location.href = '/hls.html'}\n            >\n              HLS View\n            </button>\n            <button \n              id=\"fullscreen-btn\" \n              class=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick=${() => toggleFullscreen(isFullscreen, setIsFullscreen)}\n            >\n              Fullscreen\n            </button>\n          </div>\n        </div>\n        <div class=\"controls flex items-center space-x-2\">\n          <select \n            id=\"layout-selector\" \n            class=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n            value=${layout}\n            onChange=${(e) => {\n              setLayout(e.target.value);\n              setCurrentPage(0); // Reset to first page when layout changes\n            }}\n          >\n            <option value=\"1\">Single View</option>\n            <option value=\"2\">2x1 Grid</option>\n            <option value=\"4\" selected>2x2 Grid</option>\n            <option value=\"6\">2x3 Grid</option>\n            <option value=\"9\">3x3 Grid</option>\n            <option value=\"16\">4x4 Grid</option>\n          </select>\n          \n          ${layout === '1' && html`\n            <select \n              id=\"stream-selector\" \n              class=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n              value=${selectedStream}\n              onChange=${(e) => setSelectedStream(e.target.value)}\n            >\n              ${streams.map(stream => html`\n                <option key=${stream.name} value=${stream.name}>${stream.name}</option>\n              `)}\n            </select>\n          `}\n        </div>\n      </div>\n      \n      <div class=\"flex flex-col space-y-4\">\n        <div \n          id=\"video-grid\" \n          class=${`video-container layout-${layout}`}\n          ref=${videoGridRef}\n        >\n          ${isLoading ? html`\n            <div class=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n              <div class=\"flex flex-col items-center justify-center py-8\">\n                <div class=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                <p class=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ` : streams.length === 0 ? html`\n            <div class=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p class=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n              <a href=\"streams.html\" class=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n            </div>\n          ` : null}\n          <!-- Video cells will be dynamically added by the updateVideoGrid function -->\n        </div>\n        \n        ${layout !== '1' && streams.length > getMaxStreamsForLayout() ? html`\n          <div class=\"pagination-controls flex justify-center items-center space-x-4 mt-4\">\n            <button \n              class=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick=${() => setCurrentPage(Math.max(0, currentPage - 1))}\n              disabled=${currentPage === 0}\n            >\n              Previous\n            </button>\n            <span class=\"text-gray-700 dark:text-gray-300\">\n              Page ${currentPage + 1} of ${Math.ceil(streams.length / getMaxStreamsForLayout())}\n            </span>\n            <button \n              class=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick=${() => setCurrentPage(Math.min(Math.ceil(streams.length / getMaxStreamsForLayout()) - 1, currentPage + 1))}\n              disabled=${currentPage >= Math.ceil(streams.length / getMaxStreamsForLayout()) - 1}\n            >\n              Next\n            </button>\n          </div>\n        ` : null}\n      </div>\n    </section>\n  `;\n}\n\n/**\n * Load WebRTCView component\n */\nexport function loadWebRTCView() {\n  const mainContent = document.getElementById('main-content');\n  if (!mainContent) return;\n  \n  // Render the WebRTCView component to the container\n  import('../../preact.min.js').then(({ render }) => {\n    render(html`<${WebRTCView} />`, mainContent);\n  });\n}\n\n// The component is initialized by preact-app.js when needed\n"],"file":"assets/WebRTCView-bzCSi_Tn.js"}