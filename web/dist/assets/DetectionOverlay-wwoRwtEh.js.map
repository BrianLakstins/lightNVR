{"version":3,"file":"DetectionOverlay-wwoRwtEh.js","sources":["../../js/components/preact/FullscreenManager.js","../../js/components/preact/DetectionOverlay.js"],"sourcesContent":["/**\n * Fullscreen functionality for LiveView\n */\n\nimport { showStatusMessage } from './UI.js';\n\n/**\n * Exit fullscreen mode\n * @param {Event} e - Optional event object\n * @param {Function} setIsFullscreen - State setter for fullscreen state\n */\nexport function exitFullscreenMode(e, setIsFullscreen) {\n  // If this was called from an event, stop propagation\n  if (e) {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n  \n  console.log(\"DIRECT EXIT FUNCTION CALLED\");\n  \n  const livePage = document.getElementById('live-page');\n  if (!livePage) {\n    console.error(\"Live page element not found\");\n    return;\n  }\n  \n  // Exit fullscreen\n  livePage.classList.remove('fullscreen-mode');\n  document.body.style.overflow = '';\n  \n  // Remove exit button\n  const exitBtn = document.querySelector('.fullscreen-exit');\n  if (exitBtn) {\n    exitBtn.remove();\n  } else {\n    console.warn(\"Exit button not found when trying to remove it\");\n  }\n  \n  // Show the fullscreen button again\n  const fullscreenBtn = document.getElementById('fullscreen-btn');\n  if (fullscreenBtn) {\n    fullscreenBtn.style.display = '';\n  } else {\n    console.warn(\"Fullscreen button not found when trying to show it again\");\n  }\n  \n  // Update state\n  setIsFullscreen(false);\n  \n  console.log(\"Fullscreen mode exited, state set to false\");\n}\n\n/**\n * Toggle fullscreen mode for the entire live view\n * @param {boolean} isFullscreen - Current fullscreen state\n * @param {Function} setIsFullscreen - State setter for fullscreen state\n */\nexport function toggleFullscreen(isFullscreen, setIsFullscreen) {\n  console.log(\"toggleFullscreen called, current state:\", isFullscreen);\n  \n  const livePage = document.getElementById('live-page');\n  \n  if (!livePage) {\n    console.error(\"Live page element not found\");\n    return;\n  }\n  \n  // Check the actual DOM state rather than relying on the React state\n  const isCurrentlyInFullscreen = livePage.classList.contains('fullscreen-mode');\n  console.log(\"DOM check for fullscreen mode:\", isCurrentlyInFullscreen);\n  \n  if (!isCurrentlyInFullscreen) {\n    console.log(\"Entering fullscreen mode\");\n    // Enter fullscreen\n    livePage.classList.add('fullscreen-mode');\n    document.body.style.overflow = 'hidden';\n    \n    // Add exit button - IMPORTANT: Use a standalone function for the click handler\n    const exitBtn = document.createElement('button');\n    exitBtn.className = 'fullscreen-exit fixed top-4 right-4 w-10 h-10 bg-black/70 text-white rounded-full flex justify-center items-center cursor-pointer z-50 transition-all duration-200 hover:bg-black/85 hover:scale-110 shadow-md';\n    exitBtn.innerHTML = 'âœ•';\n    \n    // Create a standalone function for the click handler\n    const exitClickHandler = function(e) {\n      console.log(\"Exit button clicked - STANDALONE HANDLER\");\n      exitFullscreenMode(e, setIsFullscreen);\n    };\n    \n    // Add the event listener with the standalone function\n    exitBtn.addEventListener('click', exitClickHandler);\n    \n    livePage.appendChild(exitBtn);\n    \n    // Hide the fullscreen button in the controls when in fullscreen mode\n    const fullscreenBtn = document.getElementById('fullscreen-btn');\n    if (fullscreenBtn) {\n      fullscreenBtn.style.display = 'none';\n    }\n    \n    // Update state\n    setIsFullscreen(true);\n    console.log(\"Fullscreen mode entered, state set to true\");\n  } else {\n    exitFullscreenMode(null, setIsFullscreen);\n  }\n}\n\n/**\n * Toggle fullscreen mode for a specific stream\n * @param {string} streamName - Name of the stream\n */\nexport function toggleStreamFullscreen(streamName) {\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n  \n  if (!videoCell) {\n    console.error('Stream not found:', streamName);\n    return;\n  }\n  \n  if (!document.fullscreenElement) {\n    videoCell.requestFullscreen().catch(err => {\n      console.error(`Error attempting to enable fullscreen: ${err.message}`);\n      showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n    });\n  } else {\n    document.exitFullscreen();\n  }\n}\n","/**\n * Detection overlay functionality for LiveView\n */\n\n/**\n * Start detection polling for a stream\n * @param {string} streamName - Name of the stream\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n * @param {Object} detectionIntervals - Reference to store interval IDs\n * @returns {number} Interval ID\n */\nexport function startDetectionPolling(streamName, canvasOverlay, videoElement, detectionIntervals) {\n  // Clear existing interval if any\n  if (detectionIntervals[streamName]) {\n    clearInterval(detectionIntervals[streamName]);\n  }\n  \n  // Function to draw bounding boxes\n  const drawDetectionBoxes = (detections) => {\n    const canvas = canvasOverlay;\n    const ctx = canvas.getContext('2d');\n    \n    // Set canvas dimensions to match the displayed video element\n    canvas.width = videoElement.clientWidth;\n    canvas.height = videoElement.clientHeight;\n    \n    // Clear previous drawings\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // No detections, just return\n    if (!detections || detections.length === 0) {\n      return;\n    }\n    \n    // Get the actual video dimensions\n    const videoWidth = videoElement.videoWidth;\n    const videoHeight = videoElement.videoHeight;\n    \n    // If video dimensions aren't available yet, skip drawing\n    if (!videoWidth || !videoHeight) {\n      console.log('Video dimensions not available yet, skipping detection drawing');\n      return;\n    }\n    \n    // Calculate the scaling and positioning to maintain aspect ratio\n    const videoAspect = videoWidth / videoHeight;\n    const canvasAspect = canvas.width / canvas.height;\n    \n    let drawWidth, drawHeight, offsetX = 0, offsetY = 0;\n    \n    if (videoAspect > canvasAspect) {\n      // Video is wider than canvas (letterboxing - black bars on top and bottom)\n      drawWidth = canvas.width;\n      drawHeight = canvas.width / videoAspect;\n      offsetY = (canvas.height - drawHeight) / 2;\n    } else {\n      // Video is taller than canvas (pillarboxing - black bars on sides)\n      drawHeight = canvas.height;\n      drawWidth = canvas.height * videoAspect;\n      offsetX = (canvas.width - drawWidth) / 2;\n    }\n    \n    // Draw each detection\n    detections.forEach(detection => {\n      // Calculate pixel coordinates based on normalized values (0-1)\n      // and adjust for the actual display area\n      const x = (detection.x * drawWidth) + offsetX;\n      const y = (detection.y * drawHeight) + offsetY;\n      const width = detection.width * drawWidth;\n      const height = detection.height * drawHeight;\n      \n      // Draw bounding box\n      ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(x, y, width, height);\n      \n      // Draw label background\n      const label = `${detection.label} (${Math.round(detection.confidence * 100)}%)`;\n      ctx.font = '14px Arial';\n      const textWidth = ctx.measureText(label).width;\n      ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';\n      ctx.fillRect(x, y - 20, textWidth + 10, 20);\n      \n      // Draw label text\n      ctx.fillStyle = 'white';\n      ctx.fillText(label, x + 5, y - 5);\n    });\n  };\n  \n  // Use a more conservative polling interval (1000ms instead of 500ms)\n  // and implement exponential backoff on errors\n  let errorCount = 0;\n  let currentInterval = 1000; // Start with 1 second\n  \n  // Poll for detection results\n  const intervalId = setInterval(() => {\n    if (!videoElement.videoWidth) {\n      // Video not loaded yet, skip this cycle\n      return;\n    }\n    \n    // Fetch detection results from API\n    fetch(`/api/detection/results/${encodeURIComponent(streamName)}`)\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`Failed to fetch detection results: ${response.status}`);\n        }\n        // Reset error count on success\n        errorCount = 0;\n        return response.json();\n      })\n      .then(data => {\n        // Draw bounding boxes if we have detections\n        if (data && data.detections) {\n          drawDetectionBoxes(data.detections);\n        }\n      })\n      .catch(error => {\n        console.error(`Error fetching detection results for ${streamName}:`, error);\n        // Clear canvas on error\n        const ctx = canvasOverlay.getContext('2d');\n        ctx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);\n        \n        // Implement backoff strategy on errors\n        errorCount++;\n        if (errorCount > 3) {\n          // After 3 consecutive errors, slow down polling to avoid overwhelming the server\n          clearInterval(intervalId);\n          currentInterval = Math.min(5000, currentInterval * 2); // Max 5 seconds\n          console.log(`Reducing detection polling frequency to ${currentInterval}ms due to errors`);\n          \n          detectionIntervals[streamName] = setInterval(arguments.callee, currentInterval);\n        }\n      });\n  }, currentInterval);\n  \n  // Store interval ID for cleanup\n  detectionIntervals[streamName] = intervalId;\n  canvasOverlay.detectionInterval = intervalId;\n  \n  return intervalId;\n}\n\n/**\n * Clean up detection polling\n * @param {string} streamName - Name of the stream\n * @param {Object} detectionIntervals - Reference to stored interval IDs\n */\nexport function cleanupDetectionPolling(streamName, detectionIntervals) {\n  const canvasId = `canvas-${streamName.replace(/\\s+/g, '-')}`;\n  const canvasOverlay = document.getElementById(canvasId);\n  \n  if (canvasOverlay && canvasOverlay.detectionInterval) {\n    clearInterval(canvasOverlay.detectionInterval);\n    delete canvasOverlay.detectionInterval;\n  }\n  \n  if (detectionIntervals[streamName]) {\n    clearInterval(detectionIntervals[streamName]);\n    delete detectionIntervals[streamName];\n  }\n}\n"],"names":["exitFullscreenMode","setIsFullscreen","livePage","exitBtn","fullscreenBtn","toggleFullscreen","isFullscreen","isCurrentlyInFullscreen","exitClickHandler","e","toggleStreamFullscreen","streamName","videoElementId","videoElement","videoCell","err","showStatusMessage","startDetectionPolling","canvasOverlay","detectionIntervals","drawDetectionBoxes","detections","canvas","ctx","videoWidth","videoHeight","videoAspect","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","detection","x","y","width","height","label","textWidth","errorCount","currentInterval","intervalId","response","data","error","cleanupDetectionPolling","canvasId"],"mappings":"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"}