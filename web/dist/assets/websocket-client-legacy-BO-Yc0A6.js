System.register([],(function(e,t){"use strict";return{execute:function(){e("W",class{static generateUUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(e){const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)}))}constructor(){this.socket=null,this.clientId=null,this.connected=!1,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectDelay=1e3,this.handlers={},this.subscriptions=new Set,this.pendingSubscriptions=new Set,this.messageQueue=[],this.connecting=!1,this.subscriptionParams=new Map,this.clientIdCallbacks=[],this.connectionChangeListeners=[],console.log("WebSocket client initialized, waiting for server-assigned client ID"),this.connect=this.connect.bind(this),this.disconnect=this.disconnect.bind(this),this.reconnect=this.reconnect.bind(this),this.send=this.send.bind(this),this.subscribe=this.subscribe.bind(this),this.unsubscribe=this.unsubscribe.bind(this),this.handleMessage=this.handleMessage.bind(this),this.processMessageQueue=this.processMessageQueue.bind(this),this.addConnectionChangeListener=this.addConnectionChangeListener.bind(this),this.removeConnectionChangeListener=this.removeConnectionChangeListener.bind(this),this.notifyConnectionChangeListeners=this.notifyConnectionChangeListeners.bind(this),this.connect()}connect(){if(this.socket&&(this.socket.readyState===WebSocket.OPEN||this.socket.readyState===WebSocket.CONNECTING))return void console.log("WebSocket already connected or connecting");if(this.connecting)return void console.log("WebSocket connection already in progress");this.connecting=!0;const e=`${"https:"===window.location.protocol?"wss:":"ws:"}//${window.location.host}/api/ws`;if(console.log(`Connecting to WebSocket server at ${e}`),"undefined"==typeof WebSocket)return console.error("WebSocket not supported by this browser or environment"),this.connecting=!1,void this.fallbackToHttp();try{const t=setTimeout((()=>{console.error("WebSocket connection timeout"),this.socket&&this.socket.readyState!==WebSocket.OPEN&&(this.socket.close(),this.socket=null,this.connecting=!1,this.fallbackToHttp())}),1e4);this.socket=new WebSocket(e),this.socket.onopen=()=>{clearTimeout(t),console.log("WebSocket connection established"),this.connected=!0,this.connecting=!1,this.reconnectAttempts=0,this.reconnectDelay=1e3,this.notifyConnectionChangeListeners(!0),void 0!==this.socket.bufferedAmount&&console.log(`Initial WebSocket buffered amount: ${this.socket.bufferedAmount}`),console.log("WebSocket connected, waiting for welcome message with client ID"),this.clientId&&(console.log(`Using existing client ID: ${this.clientId}`),this.pendingSubscriptions=new Set([...this.subscriptions]),this.subscriptions.clear(),this.processPendingSubscriptions(),this.processMessageQueue())},this.socket.onmessage=e=>{try{this.handleMessage(e.data)}catch(t){console.error("Error handling WebSocket message:",t)}},this.socket.onclose=e=>{if(clearTimeout(t),console.log(`WebSocket connection closed: ${e.code} ${e.reason}`),this.connected=!1,this.connecting=!1,this.notifyConnectionChangeListeners(!1),1006===e.code&&(console.warn("WebSocket closed abnormally (code 1006), possible compatibility issue"),this.reconnectAttempts>=3))return console.warn("Multiple abnormal closures, falling back to HTTP"),void this.fallbackToHttp();1e3!==e.code&&this.reconnect()},this.socket.onerror=e=>{console.error("WebSocket error:",e),this.connecting=!1,this.connected&&(this.connected=!1,this.notifyConnectionChangeListeners(!1)),this.reconnectAttempts++,this.reconnectAttempts>=3&&(console.warn("Multiple WebSocket errors, falling back to HTTP"),this.fallbackToHttp())}}catch(t){console.error("Error creating WebSocket:",t),this.connecting=!1,this.reconnect()}}fallbackToHttp(){console.warn("Falling back to HTTP for operations"),this.usingHttpFallback=!0,this.connected&&(this.connected=!1,this.notifyConnectionChangeListeners(!1));const e=new CustomEvent("websocket-fallback",{detail:{usingHttp:!0}});window.dispatchEvent(e),this.pendingSubscriptions.size>0&&console.log(`Notifying ${this.pendingSubscriptions.size} pending subscriptions about HTTP fallback`)}disconnect(){this.socket&&(this.socket.close(1e3,"Client disconnected"),this.socket=null),this.connected=!1,this.connecting=!1,this.subscriptions.clear(),this.pendingSubscriptions.clear(),this.subscriptionParams.clear(),this.messageQueue=[]}reconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts)return void console.log("Maximum reconnect attempts reached");this.reconnectAttempts++;const e=Math.min(3e4,this.reconnectDelay*Math.pow(1.5,this.reconnectAttempts-1));console.log(`Reconnecting in ${e}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`),setTimeout((()=>{this.connect()}),e)}send(e,t,s){if(!this.connected)return console.log("WebSocket not connected, queueing message"),this.messageQueue.push({type:e,topic:t,payload:s}),this.connect(),!1;const o={type:e,topic:t,payload:s};try{return console.log("Sending WebSocket message:",JSON.stringify(o)),this.socket.send(JSON.stringify(o)),!0}catch(n){return console.error("Error sending WebSocket message:",n),this.messageQueue.push({type:e,topic:t,payload:s}),!1}}processMessageQueue(){if(!this.connected||0===this.messageQueue.length)return;console.log(`Processing ${this.messageQueue.length} queued messages`);const e=[...this.messageQueue];this.messageQueue=[];for(const t of e)this.send(t.type,t.topic,t.payload)}processPendingSubscriptions(){if(this.connected&&0!==this.pendingSubscriptions.size){console.log(`Processing ${this.pendingSubscriptions.size} pending subscriptions`);for(const e of this.pendingSubscriptions){const t=this.subscriptionParams.get(e)||{};this.subscribe(e,t)}this.pendingSubscriptions.clear()}}subscribe(e,t={}){if(!this.connected)return console.log(`WebSocket not connected, queueing subscription to ${e}`),this.pendingSubscriptions.add(e),this.connect(),!1;this.subscriptions.has(e)&&console.log(`Already subscribed to ${e}, updating parameters`),console.log(`Subscribing to ${e} with params:`,t),this.subscriptionParams.set(e,t);const s={client_id:this.clientId,...t},o=this.send("subscribe",e,s);return o?this.subscriptions.add(e):this.pendingSubscriptions.add(e),o}unsubscribe(e){if(!this.connected)return console.log(`WebSocket not connected, cannot unsubscribe from ${e}`),this.pendingSubscriptions.delete(e),!1;if(!this.subscriptions.has(e))return console.log(`Not subscribed to ${e}`),!0;console.log(`Unsubscribing from ${e}`);const t=this.send("unsubscribe",e,{});return t&&(this.subscriptions.delete(e),this.subscriptionParams.delete(e)),t}handleMessage(e){console.log("Raw WebSocket message received:",e);try{const o=JSON.parse(e);if(!o.type||!o.topic)return void console.error("Invalid WebSocket message format:",o);if(console.log(`Received WebSocket message: ${o.type} ${o.topic}`,o),"progress"!==o.type&&"result"!==o.type||console.log(`Received ${o.type} message for topic ${o.topic}:`,o.payload),"string"==typeof o.payload)try{const e=JSON.parse(o.payload);console.log(`Parsed payload for ${o.type}:${o.topic}:`,e),o.payload=e}catch(t){console.log(`Payload for ${o.type}:${o.topic} is not JSON, keeping as string`)}if("welcome"===o.type&&"system"===o.topic){console.log("Received welcome message:",o);let e=o.payload;if(console.log("Welcome payload type:",typeof e),"string"==typeof e)try{e=JSON.parse(e),console.log("Parsed welcome payload:",e)}catch(t){console.error("Error parsing welcome payload as JSON:",t),console.log("Raw payload string:",e)}if(e&&e.client_id){this.clientId=e.client_id,console.log(`WebSocket client ID received from server: ${this.clientId}`),this.pendingSubscriptions=new Set([...this.subscriptions]),this.subscriptions.clear(),this.processPendingSubscriptions(),this.processMessageQueue(),console.log(`Notifying ${this.clientIdCallbacks.length} waiting operations about client ID`);const t=[...this.clientIdCallbacks];this.clientIdCallbacks=[];for(const e of t)try{e(this.clientId)}catch(s){console.error("Error in client ID callback:",s)}}else console.error("Welcome message missing client_id:",e);return}const n=`${o.type}:${o.topic}`,i=this.handlers[n]||[];for(const e of i)try{e(o.payload)}catch(s){console.error(`Error in WebSocket message handler for ${n}:`,s)}}catch(s){console.error("Error parsing WebSocket message:",s)}}on(e,t,s){const o=`${e}:${t}`;this.handlers[o]||(this.handlers[o]=[]),this.handlers[o].push(s),"welcome"!==e&&"ack"!==e&&"error"!==e&&this.subscribe(t)}off(e,t,s){const o=`${e}:${t}`;this.handlers[o]&&(this.handlers[o]=s?this.handlers[o].filter((e=>e!==s)):[],0===this.handlers[o].length&&"welcome"!==e&&"ack"!==e&&"error"!==e&&this.unsubscribe(t))}getClientId(e){return this.clientId?(e&&e(this.clientId),this.clientId):e?(console.log("Client ID not available yet, adding callback to queue"),this.clientIdCallbacks.push(e),this.connected||this.connecting||(console.log("Not connected, connecting now to get client ID"),this.connect()),null):null}addConnectionChangeListener(e){if("function"==typeof e){if(!this.connectionChangeListeners.includes(e)){this.connectionChangeListeners.push(e),console.log("Added connection change listener");try{e(this.connected)}catch(t){console.error("Error in connection change listener:",t)}}}else console.error("Connection change listener must be a function")}removeConnectionChangeListener(e){const t=this.connectionChangeListeners.indexOf(e);-1!==t&&(this.connectionChangeListeners.splice(t,1),console.log("Removed connection change listener"))}notifyConnectionChangeListeners(e){console.log(`Notifying ${this.connectionChangeListeners.length} connection change listeners: connected=${e}`);for(const s of this.connectionChangeListeners)try{s(e)}catch(t){console.error("Error in connection change listener:",t)}}isConnected(){return this.connected}}),e("B",class{constructor(e){this.wsClient=e,this.topic="recordings/batch-delete",this.progressHandlers=[],this.resultHandlers=[],this.errorHandlers=[],this._httpFallbackTimeout=null,this.wsClient.subscribe(this.topic),this.wsClient.on("progress",this.topic,(e=>{this.handleProgress(e)})),this.wsClient.on("result",this.topic,(e=>{this.handleResult(e)})),this.wsClient.on("error",this.topic,(e=>{this.handleError(e)}))}deleteWithProgress(e){return new Promise(((t,s)=>{if(console.log("Starting batch delete operation with params:",e),!this.wsClient.isConnected())return console.error("WebSocket not connected, attempting to connect"),this.wsClient.connect(),void setTimeout((()=>{this.wsClient.isConnected()?(console.log("WebSocket connected, retrying batch delete"),this.deleteWithProgress(e).then(t).catch(s)):(console.error("WebSocket still not connected, falling back to HTTP"),"function"==typeof batchDeleteRecordingsByHttpRequest?batchDeleteRecordingsByHttpRequest(e).then(t).catch(s):s(new Error("WebSocket not connected and HTTP fallback not available")))}),1e3);const o=o=>{console.log("Using WebSocket client ID for batch delete:",o),console.log("Registering WebSocket handlers for batch delete");const n=e=>{console.log("Batch delete result received:",e),this.wsClient.off("result",this.topic,n),console.log("Batch delete result details:",JSON.stringify(e,null,2)),this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received a result"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null),t(e)},i=e=>{console.error("Batch delete error received:",e),this.wsClient.off("error",this.topic,i),this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received an error"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null),s(new Error(e.error||"Unknown error"))};if(this.wsClient.on("result",this.topic,n),this.wsClient.on("error",this.topic,i),this.wsClient.subscriptions.has(this.topic))console.log(`Already subscribed to ${this.topic}, sending request immediately`),this.sendDeleteRequest(e,o,t,s,n,i);else{console.log(`Subscribing to ${this.topic} before sending request`);const r={client_id:o};if(console.log("Subscription payload:",r),this.wsClient.socket&&this.wsClient.socket.readyState===WebSocket.OPEN){const e={type:"subscribe",topic:this.topic,payload:r};this.wsClient.socket.send(JSON.stringify(e)),console.log("Subscription sent directly via socket")}else this.wsClient.send("subscribe",this.topic,r);this.wsClient.subscriptions.add(this.topic),setTimeout((()=>{this.sendDeleteRequest(e,o,t,s,n,i)}),1e3)}},n=this.wsClient.getClientId(o);n&&o(n)}))}sendDeleteRequest(e,t,s,o,n,i){if(console.log("Sending batch delete request"),!e.ids&&!e.filter)return console.error("Missing ids or filter in batch delete params"),this.wsClient.off("result",this.topic,n),this.wsClient.off("error",this.topic,i),void o(new Error("Missing ids or filter in batch delete params"));if(e.ids?console.log(`Deleting ${e.ids.length} recordings with IDs:`,e.ids):e.filter&&console.log("Deleting recordings with filter:",e.filter),!t||!t.startsWith("0x"))return console.error(`Invalid client ID format: ${t}. Expected a pointer value like 0x12345678`),this.wsClient.off("result",this.topic,n),this.wsClient.off("error",this.topic,i),void o(new Error("Invalid client ID format. Please try again."));const r={...e,client_id:t};console.log("Full request params:",JSON.stringify(r,null,2));const c={type:"request",topic:this.topic,payload:r};console.log("Complete WebSocket message:",JSON.stringify(c,null,2)),console.log("Client ID format check:",{clientId:t,startsWithHex:t.startsWith("0x"),length:t.length,isValid:t.startsWith("0x")&&t.length>2}),e.filter&&e.totalCount&&"function"==typeof window.updateBatchDeleteProgress?(console.log("Simulating initial progress update with total count:",e.totalCount),window.updateBatchDeleteProgress({current:0,total:e.totalCount,succeeded:0,failed:0,status:`Starting batch delete operation for ${e.totalCount} recordings...`,complete:!1})):e.ids&&"function"==typeof window.updateBatchDeleteProgress&&(console.log("Simulating initial progress update with IDs count:",e.ids.length),window.updateBatchDeleteProgress({current:0,total:e.ids.length,succeeded:0,failed:0,status:`Starting batch delete operation for ${e.ids.length} recordings...`,complete:!1}));try{if(this.wsClient.socket&&this.wsClient.socket.readyState===WebSocket.OPEN)return c.payload.client_id&&c.payload.client_id===t||(console.warn("Client ID missing or incorrect in payload, fixing it"),c.payload.client_id=t),this.wsClient.socket.send(JSON.stringify(c)),console.log("Batch delete request sent successfully via direct socket send"),this._httpFallbackTimeout=setTimeout((()=>{console.warn("No response received after 30 seconds, trying HTTP fallback"),this._httpFallbackTimeout=null,"function"==typeof batchDeleteRecordingsByHttpRequest&&(console.log("Falling back to HTTP for batch delete"),batchDeleteRecordingsByHttpRequest(e).then(s).catch(o))}),3e4),!0;{const t=this.wsClient.send("request",this.topic,r);return t?console.log("Batch delete request sent successfully via send method"):(console.error("Failed to send batch delete request"),this.wsClient.off("result",this.topic,n),this.wsClient.off("error",this.topic,i),"function"==typeof batchDeleteRecordingsByHttpRequest?(console.log("Falling back to HTTP for batch delete"),batchDeleteRecordingsByHttpRequest(e).then(s).catch(o)):o(new Error("Failed to send batch delete request"))),t}}catch(l){return console.error("Error sending batch delete request:",l),this.wsClient.off("result",this.topic,n),this.wsClient.off("error",this.topic,i),o(l),!1}}handleProgress(e){console.log("Batch delete progress update received:",e);let t=e;if("string"==typeof e)try{t=JSON.parse(e),console.log("Parsed progress payload:",t)}catch(s){console.error("Error parsing progress payload:",s),t={error:"Failed to parse progress data"}}if(this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received a progress update"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null),"function"==typeof window.updateBatchDeleteProgress&&t)try{console.log("Directly updating progress UI with:",t),window.updateBatchDeleteProgress(t)}catch(o){console.error("Error directly updating progress UI:",o)}for(const n of this.progressHandlers)try{n(t)}catch(o){console.error("Error in progress handler:",o)}}handleResult(e){console.log("Batch delete result received:",e),this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received a result"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null);let t=e;if("string"==typeof e)try{t=JSON.parse(e),console.log("Parsed result payload:",t)}catch(s){console.error("Error parsing result payload:",s),t={error:"Failed to parse result data"}}if("function"==typeof window.updateBatchDeleteProgress&&t)try{const e={current:t.total||0,total:t.total||0,succeeded:t.succeeded||0,failed:t.failed||0,status:"Batch delete operation complete",complete:!0};console.log("Updating progress UI with final result:",e),window.updateBatchDeleteProgress(e)}catch(o){console.error("Error updating progress UI from result:",o)}for(const n of this.resultHandlers)try{n(t)}catch(o){console.error("Error in result handler:",o)}}handleError(e){console.log("Batch delete error received:",e),this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received an error"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null);let t=e;if("string"==typeof e)try{t=JSON.parse(e),console.log("Parsed error payload:",t)}catch(s){console.error("Error parsing error payload:",s),t={error:"string"==typeof e?e:"Unknown error"}}if("function"==typeof window.updateBatchDeleteProgress)try{const e={current:0,total:0,succeeded:0,failed:0,status:`Error: ${t.error||"Unknown error"}`,complete:!0,error:!0};console.log("Updating progress UI with error:",e),window.updateBatchDeleteProgress(e)}catch(o){console.error("Error updating progress UI from error:",o)}for(const n of this.errorHandlers)try{n(t)}catch(o){console.error("Error in error handler:",o)}}onProgress(e){return this.progressHandlers.push(e),()=>{this.progressHandlers=this.progressHandlers.filter((t=>t!==e))}}onResult(e){return this.resultHandlers.push(e),()=>{this.resultHandlers=this.resultHandlers.filter((t=>t!==e))}}onError(e){return this.errorHandlers.push(e),()=>{this.errorHandlers=this.errorHandlers.filter((t=>t!==e))}}})}}}));
//# sourceMappingURL=websocket-client-legacy-BO-Yc0A6.js.map
