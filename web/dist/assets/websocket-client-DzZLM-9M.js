class d{static generateUUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){const t=Math.random()*16|0;return(e==="x"?t:t&3|8).toString(16)})}constructor(){this.socket=null,this.clientId=null,this.connected=!1,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectDelay=1e3,this.handlers={},this.subscriptions=new Set,this.pendingSubscriptions=new Set,this.messageQueue=[],this.connecting=!1,this.subscriptionParams=new Map,this.clientIdCallbacks=[],this.connectionChangeListeners=[],console.log("WebSocket client initialized, waiting for server-assigned client ID"),this.connect=this.connect.bind(this),this.disconnect=this.disconnect.bind(this),this.reconnect=this.reconnect.bind(this),this.send=this.send.bind(this),this.subscribe=this.subscribe.bind(this),this.unsubscribe=this.unsubscribe.bind(this),this.handleMessage=this.handleMessage.bind(this),this.processMessageQueue=this.processMessageQueue.bind(this),this.addConnectionChangeListener=this.addConnectionChangeListener.bind(this),this.removeConnectionChangeListener=this.removeConnectionChangeListener.bind(this),this.notifyConnectionChangeListeners=this.notifyConnectionChangeListeners.bind(this),this.connect()}connect(){if(this.socket&&(this.socket.readyState===WebSocket.OPEN||this.socket.readyState===WebSocket.CONNECTING)){console.log("WebSocket already connected or connecting");return}if(this.connecting){console.log("WebSocket connection already in progress");return}this.connecting=!0;const e=window.location.protocol==="https:"?"wss:":"ws:",t="".concat(e,"//").concat(window.location.host,"/api/ws");if(console.log("Connecting to WebSocket server at ".concat(t)),typeof WebSocket>"u"){console.error("WebSocket not supported by this browser or environment"),this.connecting=!1,this.fallbackToHttp();return}try{const s=setTimeout(()=>{console.error("WebSocket connection timeout"),this.socket&&this.socket.readyState!==WebSocket.OPEN&&(this.socket.close(),this.socket=null,this.connecting=!1,this.fallbackToHttp())},1e4);this.socket=new WebSocket(t),this.socket.onopen=()=>{clearTimeout(s),console.log("WebSocket connection established"),this.connected=!0,this.connecting=!1,this.reconnectAttempts=0,this.reconnectDelay=1e3,this.notifyConnectionChangeListeners(!0),this.socket.bufferedAmount!==void 0&&console.log("Initial WebSocket buffered amount: ".concat(this.socket.bufferedAmount)),console.log("WebSocket connected, waiting for welcome message with client ID"),this.clientId&&(console.log("Using existing client ID: ".concat(this.clientId)),this.pendingSubscriptions=new Set([...this.subscriptions]),this.subscriptions.clear(),this.processPendingSubscriptions(),this.processMessageQueue())},this.socket.onmessage=o=>{try{this.handleMessage(o.data)}catch(n){console.error("Error handling WebSocket message:",n)}},this.socket.onclose=o=>{if(clearTimeout(s),console.log("WebSocket connection closed: ".concat(o.code," ").concat(o.reason)),this.connected=!1,this.connecting=!1,this.notifyConnectionChangeListeners(!1),o.code===1006&&(console.warn("WebSocket closed abnormally (code 1006), possible compatibility issue"),this.reconnectAttempts>=3)){console.warn("Multiple abnormal closures, falling back to HTTP"),this.fallbackToHttp();return}o.code!==1e3&&this.reconnect()},this.socket.onerror=o=>{console.error("WebSocket error:",o),this.connecting=!1,this.connected&&(this.connected=!1,this.notifyConnectionChangeListeners(!1)),this.reconnectAttempts++,this.reconnectAttempts>=3&&(console.warn("Multiple WebSocket errors, falling back to HTTP"),this.fallbackToHttp())}}catch(s){console.error("Error creating WebSocket:",s),this.connecting=!1,this.reconnect()}}fallbackToHttp(){console.warn("Falling back to HTTP for operations"),this.usingHttpFallback=!0,this.connected&&(this.connected=!1,this.notifyConnectionChangeListeners(!1));const e=new CustomEvent("websocket-fallback",{detail:{usingHttp:!0}});window.dispatchEvent(e),this.pendingSubscriptions.size>0&&console.log("Notifying ".concat(this.pendingSubscriptions.size," pending subscriptions about HTTP fallback"))}disconnect(){this.socket&&(this.socket.close(1e3,"Client disconnected"),this.socket=null),this.connected=!1,this.connecting=!1,this.subscriptions.clear(),this.pendingSubscriptions.clear(),this.subscriptionParams.clear(),this.messageQueue=[]}reconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.log("Maximum reconnect attempts reached");return}this.reconnectAttempts++;const e=Math.min(3e4,this.reconnectDelay*Math.pow(1.5,this.reconnectAttempts-1));console.log("Reconnecting in ".concat(e,"ms (attempt ").concat(this.reconnectAttempts,"/").concat(this.maxReconnectAttempts,")")),setTimeout(()=>{this.connect()},e)}send(e,t,s){if(!this.connected)return console.log("WebSocket not connected, queueing message"),this.messageQueue.push({type:e,topic:t,payload:s}),this.connect(),!1;const o={type:e,topic:t,payload:s};try{return console.log("Sending WebSocket message:",JSON.stringify(o)),this.socket.send(JSON.stringify(o)),!0}catch(n){return console.error("Error sending WebSocket message:",n),this.messageQueue.push({type:e,topic:t,payload:s}),!1}}processMessageQueue(){if(!this.connected||this.messageQueue.length===0)return;console.log("Processing ".concat(this.messageQueue.length," queued messages"));const e=[...this.messageQueue];this.messageQueue=[];for(const t of e)this.send(t.type,t.topic,t.payload)}processPendingSubscriptions(){if(!(!this.connected||this.pendingSubscriptions.size===0)){console.log("Processing ".concat(this.pendingSubscriptions.size," pending subscriptions"));for(const e of this.pendingSubscriptions){const t=this.subscriptionParams.get(e)||{};this.subscribe(e,t)}this.pendingSubscriptions.clear()}}subscribe(e,t={}){if(!this.connected)return console.log("WebSocket not connected, queueing subscription to ".concat(e)),this.pendingSubscriptions.add(e),this.connect(),!1;this.subscriptions.has(e)&&console.log("Already subscribed to ".concat(e,", updating parameters")),console.log("Subscribing to ".concat(e," with params:"),t),this.subscriptionParams.set(e,t);const s={client_id:this.clientId,...t},o=this.send("subscribe",e,s);return o?this.subscriptions.add(e):this.pendingSubscriptions.add(e),o}unsubscribe(e){if(!this.connected)return console.log("WebSocket not connected, cannot unsubscribe from ".concat(e)),this.pendingSubscriptions.delete(e),!1;if(!this.subscriptions.has(e))return console.log("Not subscribed to ".concat(e)),!0;console.log("Unsubscribing from ".concat(e));const t=this.send("unsubscribe",e,{});return t&&(this.subscriptions.delete(e),this.subscriptionParams.delete(e)),t}handleMessage(e){console.log("Raw WebSocket message received:",e);try{const t=JSON.parse(e);if(!t.type||!t.topic){console.error("Invalid WebSocket message format:",t);return}if(console.log("Received WebSocket message: ".concat(t.type," ").concat(t.topic),t),(t.type==="progress"||t.type==="result")&&console.log("Received ".concat(t.type," message for topic ").concat(t.topic,":"),t.payload),typeof t.payload=="string")try{const n=JSON.parse(t.payload);console.log("Parsed payload for ".concat(t.type,":").concat(t.topic,":"),n),t.payload=n}catch(n){console.log("Payload for ".concat(t.type,":").concat(t.topic," is not JSON, keeping as string"))}if(t.type==="welcome"&&t.topic==="system"){console.log("Received welcome message:",t);let n=t.payload;if(console.log("Welcome payload type:",typeof n),typeof n=="string")try{n=JSON.parse(n),console.log("Parsed welcome payload:",n)}catch(r){console.error("Error parsing welcome payload as JSON:",r),console.log("Raw payload string:",n)}if(!n||!n.client_id)console.error("Welcome message missing client_id:",n);else{this.clientId=n.client_id,console.log("WebSocket client ID received from server: ".concat(this.clientId)),this.pendingSubscriptions=new Set([...this.subscriptions]),this.subscriptions.clear(),this.processPendingSubscriptions(),this.processMessageQueue(),console.log("Notifying ".concat(this.clientIdCallbacks.length," waiting operations about client ID"));const r=[...this.clientIdCallbacks];this.clientIdCallbacks=[];for(const l of r)try{l(this.clientId)}catch(c){console.error("Error in client ID callback:",c)}}return}const s="".concat(t.type,":").concat(t.topic),o=this.handlers[s]||[];for(const n of o)try{n(t.payload)}catch(r){console.error("Error in WebSocket message handler for ".concat(s,":"),r)}}catch(t){console.error("Error parsing WebSocket message:",t)}}on(e,t,s){const o="".concat(e,":").concat(t);this.handlers[o]||(this.handlers[o]=[]),this.handlers[o].push(s),e!=="welcome"&&e!=="ack"&&e!=="error"&&this.subscribe(t)}off(e,t,s){const o="".concat(e,":").concat(t);this.handlers[o]&&(s?this.handlers[o]=this.handlers[o].filter(n=>n!==s):this.handlers[o]=[],this.handlers[o].length===0&&e!=="welcome"&&e!=="ack"&&e!=="error"&&this.unsubscribe(t))}getClientId(e){return this.clientId?(e&&e(this.clientId),this.clientId):(e&&(console.log("Client ID not available yet, adding callback to queue"),this.clientIdCallbacks.push(e),!this.connected&&!this.connecting&&(console.log("Not connected, connecting now to get client ID"),this.connect())),null)}addConnectionChangeListener(e){if(typeof e!="function"){console.error("Connection change listener must be a function");return}if(!this.connectionChangeListeners.includes(e)){this.connectionChangeListeners.push(e),console.log("Added connection change listener");try{e(this.connected)}catch(t){console.error("Error in connection change listener:",t)}}}removeConnectionChangeListener(e){const t=this.connectionChangeListeners.indexOf(e);t!==-1&&(this.connectionChangeListeners.splice(t,1),console.log("Removed connection change listener"))}notifyConnectionChangeListeners(e){console.log("Notifying ".concat(this.connectionChangeListeners.length," connection change listeners: connected=").concat(e));for(const t of this.connectionChangeListeners)try{t(e)}catch(s){console.error("Error in connection change listener:",s)}}isConnected(){return this.connected}}class u{constructor(e){this.wsClient=e,this.topic="recordings/batch-delete",this.progressHandlers=[],this.resultHandlers=[],this.errorHandlers=[],this._httpFallbackTimeout=null,this.wsClient.subscribe(this.topic),this.wsClient.on("progress",this.topic,t=>{this.handleProgress(t)}),this.wsClient.on("result",this.topic,t=>{this.handleResult(t)}),this.wsClient.on("error",this.topic,t=>{this.handleError(t)})}deleteWithProgress(e){return new Promise((t,s)=>{if(console.log("Starting batch delete operation with params:",e),!this.wsClient.isConnected()){console.error("WebSocket not connected, attempting to connect"),this.wsClient.connect(),setTimeout(()=>{this.wsClient.isConnected()?(console.log("WebSocket connected, retrying batch delete"),this.deleteWithProgress(e).then(t).catch(s)):(console.error("WebSocket still not connected, falling back to HTTP"),typeof batchDeleteRecordingsByHttpRequest=="function"?batchDeleteRecordingsByHttpRequest(e).then(t).catch(s):s(new Error("WebSocket not connected and HTTP fallback not available")))},1e3);return}const o=r=>{console.log("Using WebSocket client ID for batch delete:",r),console.log("Registering WebSocket handlers for batch delete");const l=i=>{console.log("Batch delete result received:",i),this.wsClient.off("result",this.topic,l),console.log("Batch delete result details:",JSON.stringify(i,null,2)),this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received a result"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null),t(i)},c=i=>{console.error("Batch delete error received:",i),this.wsClient.off("error",this.topic,c),this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received an error"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null),s(new Error(i.error||"Unknown error"))};if(this.wsClient.on("result",this.topic,l),this.wsClient.on("error",this.topic,c),this.wsClient.subscriptions.has(this.topic))console.log("Already subscribed to ".concat(this.topic,", sending request immediately")),this.sendDeleteRequest(e,r,t,s,l,c);else{console.log("Subscribing to ".concat(this.topic," before sending request"));const i={client_id:r};if(console.log("Subscription payload:",i),this.wsClient.socket&&this.wsClient.socket.readyState===WebSocket.OPEN){const h={type:"subscribe",topic:this.topic,payload:i};this.wsClient.socket.send(JSON.stringify(h)),console.log("Subscription sent directly via socket")}else this.wsClient.send("subscribe",this.topic,i);this.wsClient.subscriptions.add(this.topic),setTimeout(()=>{this.sendDeleteRequest(e,r,t,s,l,c)},1e3)}},n=this.wsClient.getClientId(o);n&&o(n)})}sendDeleteRequest(e,t,s,o,n,r){if(console.log("Sending batch delete request"),!e.ids&&!e.filter){console.error("Missing ids or filter in batch delete params"),this.wsClient.off("result",this.topic,n),this.wsClient.off("error",this.topic,r),o(new Error("Missing ids or filter in batch delete params"));return}if(e.ids?console.log("Deleting ".concat(e.ids.length," recordings with IDs:"),e.ids):e.filter&&console.log("Deleting recordings with filter:",e.filter),!t||!t.startsWith("0x")){console.error("Invalid client ID format: ".concat(t,". Expected a pointer value like 0x12345678")),this.wsClient.off("result",this.topic,n),this.wsClient.off("error",this.topic,r),o(new Error("Invalid client ID format. Please try again."));return}const l={...e,client_id:t};console.log("Full request params:",JSON.stringify(l,null,2));const c={type:"request",topic:this.topic,payload:l};console.log("Complete WebSocket message:",JSON.stringify(c,null,2)),console.log("Client ID format check:",{clientId:t,startsWithHex:t.startsWith("0x"),length:t.length,isValid:t.startsWith("0x")&&t.length>2}),e.filter&&e.totalCount&&typeof window.updateBatchDeleteProgress=="function"?(console.log("Simulating initial progress update with total count:",e.totalCount),window.updateBatchDeleteProgress({current:0,total:e.totalCount,succeeded:0,failed:0,status:"Starting batch delete operation for ".concat(e.totalCount," recordings..."),complete:!1})):e.ids&&typeof window.updateBatchDeleteProgress=="function"&&(console.log("Simulating initial progress update with IDs count:",e.ids.length),window.updateBatchDeleteProgress({current:0,total:e.ids.length,succeeded:0,failed:0,status:"Starting batch delete operation for ".concat(e.ids.length," recordings..."),complete:!1}));try{if(this.wsClient.socket&&this.wsClient.socket.readyState===WebSocket.OPEN)return(!c.payload.client_id||c.payload.client_id!==t)&&(console.warn("Client ID missing or incorrect in payload, fixing it"),c.payload.client_id=t),this.wsClient.socket.send(JSON.stringify(c)),console.log("Batch delete request sent successfully via direct socket send"),this._httpFallbackTimeout=setTimeout(()=>{console.warn("No response received after 30 seconds, trying HTTP fallback"),this._httpFallbackTimeout=null,typeof batchDeleteRecordingsByHttpRequest=="function"&&(console.log("Falling back to HTTP for batch delete"),batchDeleteRecordingsByHttpRequest(e).then(s).catch(o))},3e4),!0;{const i=this.wsClient.send("request",this.topic,l);return i?console.log("Batch delete request sent successfully via send method"):(console.error("Failed to send batch delete request"),this.wsClient.off("result",this.topic,n),this.wsClient.off("error",this.topic,r),typeof batchDeleteRecordingsByHttpRequest=="function"?(console.log("Falling back to HTTP for batch delete"),batchDeleteRecordingsByHttpRequest(e).then(s).catch(o)):o(new Error("Failed to send batch delete request"))),i}}catch(i){return console.error("Error sending batch delete request:",i),this.wsClient.off("result",this.topic,n),this.wsClient.off("error",this.topic,r),o(i),!1}}handleProgress(e){console.log("Batch delete progress update received:",e);let t=e;if(typeof e=="string")try{t=JSON.parse(e),console.log("Parsed progress payload:",t)}catch(s){console.error("Error parsing progress payload:",s),t={error:"Failed to parse progress data"}}if(this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received a progress update"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null),typeof window.updateBatchDeleteProgress=="function"&&t)try{console.log("Directly updating progress UI with:",t),window.updateBatchDeleteProgress(t)}catch(s){console.error("Error directly updating progress UI:",s)}for(const s of this.progressHandlers)try{s(t)}catch(o){console.error("Error in progress handler:",o)}}handleResult(e){console.log("Batch delete result received:",e),this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received a result"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null);let t=e;if(typeof e=="string")try{t=JSON.parse(e),console.log("Parsed result payload:",t)}catch(s){console.error("Error parsing result payload:",s),t={error:"Failed to parse result data"}}if(typeof window.updateBatchDeleteProgress=="function"&&t)try{const s={current:t.total||0,total:t.total||0,succeeded:t.succeeded||0,failed:t.failed||0,status:"Batch delete operation complete",complete:!0};console.log("Updating progress UI with final result:",s),window.updateBatchDeleteProgress(s)}catch(s){console.error("Error updating progress UI from result:",s)}for(const s of this.resultHandlers)try{s(t)}catch(o){console.error("Error in result handler:",o)}}handleError(e){console.log("Batch delete error received:",e),this._httpFallbackTimeout&&(console.log("Clearing HTTP fallback timeout because we received an error"),clearTimeout(this._httpFallbackTimeout),this._httpFallbackTimeout=null);let t=e;if(typeof e=="string")try{t=JSON.parse(e),console.log("Parsed error payload:",t)}catch(s){console.error("Error parsing error payload:",s),t={error:typeof e=="string"?e:"Unknown error"}}if(typeof window.updateBatchDeleteProgress=="function")try{const s={current:0,total:0,succeeded:0,failed:0,status:"Error: ".concat(t.error||"Unknown error"),complete:!0,error:!0};console.log("Updating progress UI with error:",s),window.updateBatchDeleteProgress(s)}catch(s){console.error("Error updating progress UI from error:",s)}for(const s of this.errorHandlers)try{s(t)}catch(o){console.error("Error in error handler:",o)}}onProgress(e){return this.progressHandlers.push(e),()=>{this.progressHandlers=this.progressHandlers.filter(t=>t!==e)}}onResult(e){return this.resultHandlers.push(e),()=>{this.resultHandlers=this.resultHandlers.filter(t=>t!==e)}}onError(e){return this.errorHandlers.push(e),()=>{this.errorHandlers=this.errorHandlers.filter(t=>t!==e)}}}export{u as B,d as W};
//# sourceMappingURL=websocket-client-DzZLM-9M.js.map
