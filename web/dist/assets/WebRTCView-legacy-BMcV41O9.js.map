{"version":3,"file":"WebRTCView-legacy-BMcV41O9.js","sources":["../../js/components/preact/WebRTCView.js"],"sourcesContent":["/**\n * LightNVR Web Interface WebRTCView Component\n * Preact component for the WebRTC view page\n */\n\nimport { h } from '../../preact.min.js';\nimport { html } from '../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../preact.hooks.module.js';\nimport { showStatusMessage, showSnapshotPreview, setupModals, addStatusMessageStyles, addModalStyles } from './UI.js';\nimport { toggleFullscreen, exitFullscreenMode } from './FullscreenManager.js';\nimport { startDetectionPolling, cleanupDetectionPolling } from './DetectionOverlay.js';\n\n/**\n * WebRTCView component\n * @returns {JSX.Element} WebRTCView component\n */\nexport function WebRTCView() {\n  const [streams, setStreams] = useState([]);\n  const [layout, setLayout] = useState('4');\n  const [selectedStream, setSelectedStream] = useState('');\n  const [isFullscreen, setIsFullscreen] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [currentPage, setCurrentPage] = useState(0);\n  const videoGridRef = useRef(null);\n  const webrtcConnections = useRef({});\n  const detectionIntervals = useRef({});\n  \n  // Set up event listeners and UI components\n  useEffect(() => {\n    // Set up modals for snapshot preview\n    setupModals();\n    addStatusMessageStyles();\n    addModalStyles();\n    \n    // Set up Escape key to exit fullscreen mode\n    const handleEscape = (e) => {\n      if (e.key === 'Escape') {\n        console.log(\"Escape key pressed, current fullscreen state:\", isFullscreen);\n        // Check if we're in fullscreen mode by checking the DOM directly\n        const livePage = document.getElementById('live-page');\n        if (livePage && livePage.classList.contains('fullscreen-mode')) {\n          console.log(\"Detected fullscreen mode via DOM, exiting fullscreen\");\n          exitFullscreenMode(null, setIsFullscreen);\n        }\n      }\n    };\n    \n    document.addEventListener('keydown', handleEscape);\n    \n    // Add event listener to stop streams when leaving the page\n    const handleBeforeUnload = () => {\n      stopAllWebRTCStreams();\n    };\n    \n    // Add event listener for visibility change to handle tab switching\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        console.log(\"Page hidden, pausing WebRTC streams\");\n        // Mark connections as inactive but don't close them yet\n        Object.keys(webrtcConnections.current).forEach(streamName => {\n          const pc = webrtcConnections.current[streamName];\n          if (pc && pc.connectionState !== 'closed') {\n            // Pause video elements to reduce resource usage\n            const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n            const videoElement = document.getElementById(videoElementId);\n            if (videoElement) {\n              videoElement.pause();\n            }\n          }\n        });\n      } else {\n        console.log(\"Page visible, resuming WebRTC streams\");\n        // Resume video playback\n        Object.keys(webrtcConnections.current).forEach(streamName => {\n          const pc = webrtcConnections.current[streamName];\n          if (pc && pc.connectionState !== 'closed') {\n            const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n            const videoElement = document.getElementById(videoElementId);\n            if (videoElement) {\n              videoElement.play().catch(e => {\n                console.warn(`Could not resume video for ${streamName}:`, e);\n              });\n            }\n          }\n        });\n      }\n    };\n    \n    window.addEventListener('beforeunload', handleBeforeUnload);\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Set up periodic connection check\n    const connectionCheckInterval = setInterval(() => {\n      Object.keys(webrtcConnections.current).forEach(streamName => {\n        const pc = webrtcConnections.current[streamName];\n        if (pc) {\n          // Log connection state for debugging\n          console.debug(`WebRTC connection state for ${streamName}: ${pc.connectionState}, ICE state: ${pc.iceConnectionState}`);\n          \n          // If connection is failed or disconnected for too long, try to reconnect\n          if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n            console.warn(`WebRTC connection for ${streamName} is in ${pc.iceConnectionState} state, will attempt reconnect`);\n            \n            // Clean up the old connection\n            cleanupWebRTCPlayer(streamName);\n            \n            // Find the stream info and reinitialize\n            const stream = streams.find(s => s.name === streamName);\n            if (stream) {\n              console.log(`Attempting to reconnect WebRTC for stream ${streamName}`);\n              initializeWebRTCPlayer(stream);\n            }\n          }\n        }\n      });\n    }, 30000); // Check every 30 seconds\n    \n    // Cleanup\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      clearInterval(connectionCheckInterval);\n      stopAllWebRTCStreams();\n    };\n  }, [streams]); // Add streams as dependency to ensure we have the latest stream data\n  \n  // Load streams after the component has rendered and videoGridRef is available\n  useEffect(() => {\n      // Set loading state initially\n      setIsLoading(true);\n      \n      // Create a timeout to handle potential stalls in loading\n      const timeoutId = setTimeout(() => {\n        console.warn('Stream loading timed out');\n        setIsLoading(false);\n        showStatusMessage('Loading streams timed out. Please try refreshing the page.');\n      }, 15000); // 15 second timeout\n      \n      // Load streams from API with timeout handling\n      loadStreams()\n        .then((streamData) => {\n          clearTimeout(timeoutId);\n          if (streamData && streamData.length > 0) {\n            setStreams(streamData);\n            setSelectedStream(streamData[0].name);\n          } else {\n            console.warn('No streams returned from API');\n          }\n          setIsLoading(false);\n        })\n        .catch((error) => {\n          clearTimeout(timeoutId);\n          console.error('Error loading streams:', error);\n          showStatusMessage('Error loading streams: ' + error.message);\n          setIsLoading(false);\n        });\n  }, []);\n  \n  // Update video grid when layout, page, or streams change\n  useEffect(() => {\n    updateVideoGrid();\n  }, [layout, selectedStream, streams, currentPage]);\n  \n  /**\n   * Load streams from API\n   * @returns {Promise<Array>} Promise resolving to array of streams\n   */\n  const loadStreams = async () => {\n    try {\n      // Create a timeout promise to handle potential stalls\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Request timed out')), 5000); // 5 second timeout\n      });\n      \n      // Fetch streams from API with timeout\n      const fetchPromise = fetch('/api/streams');\n      const response = await Promise.race([fetchPromise, timeoutPromise]);\n      \n      if (!response.ok) {\n        throw new Error('Failed to load streams');\n      }\n      \n      // Create another timeout for the JSON parsing\n      const jsonTimeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('JSON parsing timed out')), 3000); // 3 second timeout\n      });\n      \n      const jsonPromise = response.json();\n      const data = await Promise.race([jsonPromise, jsonTimeoutPromise]);\n      \n      // For WebRTC view, we need to fetch full details for each stream\n      const streamPromises = (data || []).map(stream => {\n        // Create a timeout promise for this stream's details fetch\n        const detailsTimeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(new Error(`Timeout fetching details for stream ${stream.name}`)), 3000);\n        });\n        \n        // Fetch stream details with timeout\n        const detailsFetchPromise = fetch(`/api/streams/${encodeURIComponent(stream.id || stream.name)}`)\n          .then(response => {\n            if (!response.ok) {\n              throw new Error(`Failed to load details for stream ${stream.name}`);\n            }\n            return response.json();\n          });\n          \n        // Race the fetch against the timeout\n        return Promise.race([detailsFetchPromise, detailsTimeoutPromise])\n          .catch(error => {\n            console.error(`Error loading details for stream ${stream.name}:`, error);\n            // Return the basic stream info if we can't get details\n            return stream;\n          });\n      });\n      \n      const detailedStreams = await Promise.all(streamPromises);\n      console.log('Loaded detailed streams for WebRTC view:', detailedStreams);\n      \n      // Filter out streams that are soft deleted, inactive, or not configured for HLS\n      const filteredStreams = detailedStreams.filter(stream => {\n        // Filter out soft deleted streams\n        if (stream.is_deleted) {\n          console.log(`Stream ${stream.name} is soft deleted, filtering out`);\n          return false;\n        }\n        \n        // Filter out inactive streams\n        if (!stream.enabled) {\n          console.log(`Stream ${stream.name} is inactive, filtering out`);\n          return false;\n        }\n        \n        // Filter out streams not configured for HLS\n        if (!stream.streaming_enabled) {\n          console.log(`Stream ${stream.name} is not configured for HLS, filtering out`);\n          return false;\n        }\n        \n        return true;\n      });\n      \n      console.log('Filtered streams for WebRTC view:', filteredStreams);\n      \n      return filteredStreams || [];\n    } catch (error) {\n      console.error('Error loading streams for WebRTC view:', error);\n      showStatusMessage('Error loading streams: ' + error.message);\n      \n      return [];\n    }\n  };\n  \n  /**\n   * Get maximum number of streams to display based on layout\n   * @returns {number} Maximum number of streams\n   */\n  const getMaxStreamsForLayout = () => {\n    switch (layout) {\n      case '1': return 1;  // Single view\n      case '2': return 2;  // 2x1 grid\n      case '4': return 4;  // 2x2 grid\n      case '6': return 6;  // 2x3 grid\n      case '9': return 9;  // 3x3 grid\n      case '16': return 16; // 4x4 grid\n      default: return 4;\n    }\n  };\n\n  /**\n   * Update video grid based on layout, streams, and pagination\n   */\n  const updateVideoGrid = () => {\n    if (!videoGridRef.current) return;\n    \n    // Clear existing content except placeholder\n    const placeholder = videoGridRef.current.querySelector('.placeholder');\n    videoGridRef.current.innerHTML = '';\n    \n    // If placeholder exists and no streams, add it back\n    if (placeholder && streams.length === 0) {\n      videoGridRef.current.appendChild(placeholder);\n      return;\n    }\n    \n    // Filter streams based on layout and selected stream\n    let streamsToShow = streams;\n    if (layout === '1' && selectedStream) {\n      streamsToShow = streams.filter(stream => stream.name === selectedStream);\n    } else {\n      // Apply pagination\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n      \n      // Ensure current page is valid\n      if (currentPage >= totalPages) {\n        setCurrentPage(Math.max(0, totalPages - 1));\n        return; // Will re-render with corrected page\n      }\n      \n      // Get streams for current page\n      const startIdx = currentPage * maxStreams;\n      const endIdx = Math.min(startIdx + maxStreams, streams.length);\n      streamsToShow = streams.slice(startIdx, endIdx);\n    }\n\n    // Stagger initialization of WebRTC connections\n    streamsToShow.forEach((stream, index) => {\n      // Create video cell immediately for UI responsiveness\n      createVideoCell(stream);\n      \n      // Stagger the actual WebRTC initialization\n      setTimeout(() => {\n        initializeWebRTCPlayer(stream);\n      }, index * 500); // 500ms delay between each stream initialization\n    });\n  };\n\n  /**\n   * Create video cell without initializing WebRTC\n   * @param {Object} stream - Stream object\n   */\n  const createVideoCell = (stream) => {\n    // Ensure we have an ID for the stream (use name as fallback if needed)\n    const streamId = stream.id || stream.name;\n    \n    const videoCell = document.createElement('div');\n    videoCell.className = 'video-cell';\n    videoCell.dataset.streamName = stream.name;\n    videoCell.style.position = 'relative'; // Create stacking context\n    \n    // Create video element\n    const videoElement = document.createElement('video');\n    videoElement.id = `video-${stream.name.replace(/\\s+/g, '-')}`;\n    videoElement.className = 'video-element';\n    videoElement.playsInline = true;\n    videoElement.autoplay = true;\n    videoElement.muted = true;\n    videoElement.style.pointerEvents = 'none'; // Allow clicks to pass through to controls\n    \n    // Create loading indicator\n    const loadingIndicator = document.createElement('div');\n    loadingIndicator.className = 'loading-indicator';\n    loadingIndicator.innerHTML = `\n      <div class=\"spinner\"></div>\n      <p>Connecting...</p>\n    `;\n    loadingIndicator.style.position = 'absolute';\n    loadingIndicator.style.top = '0';\n    loadingIndicator.style.left = '0';\n    loadingIndicator.style.width = '100%';\n    loadingIndicator.style.height = '100%';\n    loadingIndicator.style.display = 'flex';\n    loadingIndicator.style.flexDirection = 'column';\n    loadingIndicator.style.justifyContent = 'center';\n    loadingIndicator.style.alignItems = 'center';\n    loadingIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n    loadingIndicator.style.color = 'white';\n    loadingIndicator.style.zIndex = '20'; // Above video but below controls\n    \n    // Create error indicator (hidden by default)\n    const errorIndicator = document.createElement('div');\n    errorIndicator.className = 'error-indicator';\n    errorIndicator.style.display = 'none';\n    errorIndicator.style.position = 'absolute';\n    errorIndicator.style.top = '0';\n    errorIndicator.style.left = '0';\n    errorIndicator.style.width = '100%';\n    errorIndicator.style.height = '100%';\n    errorIndicator.style.flexDirection = 'column';\n    errorIndicator.style.justifyContent = 'center';\n    errorIndicator.style.alignItems = 'center';\n    errorIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n    errorIndicator.style.color = 'white';\n    errorIndicator.style.zIndex = '20'; // Above video but below controls\n    \n    // Create stream name overlay\n    const streamNameOverlay = document.createElement('div');\n    streamNameOverlay.className = 'stream-name-overlay';\n    streamNameOverlay.textContent = stream.name;\n    streamNameOverlay.style.position = 'absolute';\n    streamNameOverlay.style.top = '10px';\n    streamNameOverlay.style.left = '10px';\n    streamNameOverlay.style.padding = '5px 10px';\n    streamNameOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n    streamNameOverlay.style.color = 'white';\n    streamNameOverlay.style.borderRadius = '4px';\n    streamNameOverlay.style.fontSize = '14px';\n    streamNameOverlay.style.zIndex = '15'; // Above video but below controls\n    \n    // Create stream controls\n    const streamControls = document.createElement('div');\n    streamControls.className = 'stream-controls';\n    streamControls.innerHTML = `\n      <button class=\"snapshot-btn\" title=\"Take Snapshot\" data-id=\"${streamId}\" data-name=\"${stream.name}\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"></path><circle cx=\"12\" cy=\"13\" r=\"4\"></circle></svg>\n      </button>\n      <button class=\"fullscreen-btn\" title=\"Toggle Fullscreen\" data-id=\"${streamId}\" data-name=\"${stream.name}\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path></svg>\n      </button>\n    `;\n    streamControls.style.position = 'absolute';\n    streamControls.style.bottom = '10px';\n    streamControls.style.right = '10px';\n    streamControls.style.display = 'flex';\n    streamControls.style.gap = '10px';\n    streamControls.style.zIndex = '30'; // Above everything else\n    \n    // Add canvas for detection overlay\n    const canvasOverlay = document.createElement('canvas');\n    canvasOverlay.id = `canvas-${stream.name.replace(/\\s+/g, '-')}`;\n    canvasOverlay.className = 'detection-overlay';\n    canvasOverlay.style.position = 'absolute';\n    canvasOverlay.style.top = '0';\n    canvasOverlay.style.left = '0';\n    canvasOverlay.style.width = '100%';\n    canvasOverlay.style.height = '100%';\n    canvasOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through\n    canvasOverlay.style.zIndex = '5'; // Above video but below controls\n    \n    // Assemble the video cell\n    videoCell.appendChild(videoElement);\n    videoCell.appendChild(loadingIndicator);\n    videoCell.appendChild(errorIndicator);\n    videoCell.appendChild(streamNameOverlay);\n    videoCell.appendChild(streamControls);\n    videoCell.appendChild(canvasOverlay);\n    \n    // Add to grid\n    videoGridRef.current.appendChild(videoCell);\n    \n    // Make sure all buttons have proper z-index and pointer events\n    const allButtons = videoCell.querySelectorAll('button');\n    allButtons.forEach(button => {\n      button.style.position = 'relative';\n      button.style.zIndex = '30';\n      button.style.pointerEvents = 'auto';\n    });\n    \n    // Add event listeners for buttons\n    const snapshotBtn = videoCell.querySelector('.snapshot-btn');\n    if (snapshotBtn) {\n      snapshotBtn.addEventListener('click', (event) => {\n        takeSnapshot(streamId, event);\n      });\n    }\n    \n    const fullscreenBtn = videoCell.querySelector('.fullscreen-btn');\n    if (fullscreenBtn) {\n      fullscreenBtn.addEventListener('click', () => {\n        toggleStreamFullscreen(stream.name);\n      });\n    }\n  };\n  \n  /**\n   * Initialize WebRTC player for a stream\n   * @param {Object} stream - Stream object\n   */\n  const initializeWebRTCPlayer = (stream) => {\n    const videoElementId = `video-${stream.name.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n    \n    if (!videoElement || !videoCell) return;\n    \n    // Show loading state\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'flex';\n    }\n    \n    // Create canvas overlay for detection bounding boxes\n    const canvasId = `canvas-${stream.name.replace(/\\s+/g, '-')}`;\n    let canvasOverlay = document.getElementById(canvasId);\n    \n    if (!canvasOverlay) {\n      canvasOverlay = document.createElement('canvas');\n      canvasOverlay.id = canvasId;\n      canvasOverlay.className = 'detection-overlay';\n      canvasOverlay.style.position = 'absolute';\n      canvasOverlay.style.top = '0';\n      canvasOverlay.style.left = '0';\n      canvasOverlay.style.width = '100%';\n      canvasOverlay.style.height = '100%';\n      canvasOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through\n      videoCell.appendChild(canvasOverlay);\n    }\n    \n    // Create a new RTCPeerConnection with ICE servers\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ],\n      // Add additional configuration to ensure proper ICE credentials\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'balanced',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'unified-plan'\n    });\n    \n    // Store the connection for cleanup\n    webrtcConnections.current[stream.name] = pc;\n    \n    // Add event listeners\n    pc.ontrack = (event) => {\n      console.log(`Track received for stream ${stream.name}:`, event);\n      if (event.track.kind === 'video') {\n        videoElement.srcObject = event.streams[0];\n        \n        // Hide loading indicator when video starts playing\n        videoElement.onloadeddata = () => {\n          if (loadingIndicator) {\n            loadingIndicator.style.display = 'none';\n          }\n        };\n      }\n    };\n    \n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log(`ICE candidate for stream ${stream.name}:`, event.candidate);\n        // go2rtc doesn't use a separate ICE endpoint, so we don't need to send ICE candidates\n      }\n    };\n    \n    pc.oniceconnectionstatechange = () => {\n      console.log(`ICE connection state for stream ${stream.name}:`, pc.iceConnectionState);\n      if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n        // Handle connection failure\n        handleWebRTCError(stream.name, 'WebRTC connection failed');\n      }\n    };\n    \n    // Add transceivers to ensure we get both audio and video tracks\n    pc.addTransceiver('video', {direction: 'recvonly'});\n    pc.addTransceiver('audio', {direction: 'recvonly'});\n    \n    // Create an offer with specific codec requirements\n    const offerOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n    \n    // Create a timeout for the entire WebRTC setup process\n    const setupTimeoutId = setTimeout(() => {\n      console.warn(`WebRTC setup timed out for stream ${stream.name}`);\n      handleWebRTCError(stream.name, 'WebRTC setup timed out');\n      \n      // Clean up the connection if it exists\n      if (webrtcConnections.current[stream.name]) {\n        cleanupWebRTCPlayer(stream.name);\n      }\n    }, 15000); // 15 second timeout for the entire setup process\n    \n    pc.createOffer(offerOptions)\n      .then(offer => {\n        console.log(`Created offer for stream ${stream.name}:`, offer);\n        \n        // Log the original SDP to ensure it has ice-ufrag and ice-pwd\n        console.log(`Original SDP for stream ${stream.name}:`, offer.sdp);\n        \n        // Check if the SDP has ice-ufrag and ice-pwd\n        if (!offer.sdp.includes('a=ice-ufrag:') || !offer.sdp.includes('a=ice-pwd:')) {\n          console.warn(`SDP for stream ${stream.name} is missing ice-ufrag or ice-pwd!`);\n        }\n        \n        // We'll use the original offer without modifications to preserve ice-ufrag and ice-pwd\n        console.log(`Using original offer for stream ${stream.name}`);\n        return pc.setLocalDescription(offer);\n      })\n      .then(() => {\n        console.log(`Set local description for stream ${stream.name}`);\n        // Send the offer to the server\n        return sendOffer(stream.name, pc.localDescription);\n      })\n      .then(answer => {\n        console.log(`Received answer for stream ${stream.name}:`, answer);\n        // Set the remote description\n        return pc.setRemoteDescription(new RTCSessionDescription(answer));\n      })\n      .then(() => {\n        console.log(`Set remote description for stream ${stream.name}`);\n        \n        // Clear the setup timeout since we've successfully set up the connection\n        clearTimeout(setupTimeoutId);\n        \n        // Start detection polling if detection is enabled for this stream\n        console.log(`Stream ${stream.name} detection settings:`, {\n          detection_based_recording: stream.detection_based_recording,\n          detection_model: stream.detection_model,\n          detection_threshold: stream.detection_threshold\n        });\n        \n        if (stream.detection_based_recording && stream.detection_model) {\n          console.log(`Starting detection polling for stream ${stream.name}`);\n          startDetectionPolling(stream.name, canvasOverlay, videoElement, detectionIntervals.current);\n        } else {\n          console.log(`Detection not enabled for stream ${stream.name}`);\n        }\n      })\n      .catch(error => {\n        // Clear the setup timeout\n        clearTimeout(setupTimeoutId);\n        \n        console.error(`Error setting up WebRTC for stream ${stream.name}:`, error);\n        handleWebRTCError(stream.name, error.message);\n      });\n  };\n  \n  /**\n   * Send WebRTC offer to server\n   * @param {string} streamName - Stream name\n   * @param {RTCSessionDescription} offer - WebRTC offer\n   * @returns {Promise<RTCSessionDescription>} Promise resolving to WebRTC answer\n   */\n  const sendOffer = async (streamName, offer) => {\n    try {\n      // Get auth from localStorage\n      const auth = localStorage.getItem('auth');\n      \n      // Send the offer to the server\n      // Format the offer according to go2rtc expectations\n      const formattedOffer = {\n        type: offer.type,\n        sdp: offer.sdp\n      };\n      \n      console.log(`Sending formatted offer for stream ${streamName}:`, formattedOffer);\n      \n      // Create an AbortController for the fetch request\n      const controller = new AbortController();\n      const signal = controller.signal;\n      \n      // Set a timeout to abort the fetch after 8 seconds\n      const timeoutId = setTimeout(() => {\n        console.warn(`Aborting WebRTC offer request for stream ${streamName} due to timeout`);\n        controller.abort();\n      }, 8000);\n      \n      try {\n        // Note: Session cookie is automatically included in fetch requests\n        // We only need to add the Authorization header if we have it in localStorage\n        const response = await fetch(`/api/webrtc?src=${encodeURIComponent(streamName)}`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(auth ? { 'Authorization': 'Basic ' + auth } : {})\n          },\n          body: JSON.stringify(formattedOffer),\n          signal: signal\n        });\n        \n        // Clear the timeout since the request completed\n        clearTimeout(timeoutId);\n        \n        if (!response.ok) {\n          throw new Error(`Failed to send offer: ${response.status} ${response.statusText}`);\n        }\n        \n        // Create another AbortController for the JSON parsing\n        const jsonController = new AbortController();\n        const jsonSignal = jsonController.signal;\n        \n        // Set a timeout to abort the JSON parsing after 5 seconds\n        const jsonTimeoutId = setTimeout(() => {\n          console.warn(`Aborting JSON parsing for stream ${streamName} due to timeout`);\n          jsonController.abort();\n        }, 5000);\n        \n        try {\n          // Use a separate try/catch for the JSON parsing\n          const text = await response.text();\n          \n          // Clear the JSON timeout\n          clearTimeout(jsonTimeoutId);\n          \n          // Try to parse the JSON\n          try {\n            const answer = JSON.parse(text);\n            return answer;\n          } catch (jsonError) {\n            console.error(`Error parsing JSON for stream ${streamName}:`, jsonError);\n            console.log(`Raw response text: ${text}`);\n            throw new Error(`Failed to parse WebRTC answer: ${jsonError.message}`);\n          }\n        } catch (textError) {\n          // Clear the JSON timeout if it hasn't been cleared yet\n          clearTimeout(jsonTimeoutId);\n          \n          if (textError.name === 'AbortError') {\n            throw new Error(`WebRTC answer parsing timed out for stream ${streamName}`);\n          }\n          throw textError;\n        }\n      } catch (fetchError) {\n        // Clear the timeout if it hasn't been cleared yet\n        clearTimeout(timeoutId);\n        \n        if (fetchError.name === 'AbortError') {\n          throw new Error(`WebRTC offer request timed out for stream ${streamName}`);\n        }\n        throw fetchError;\n      }\n    } catch (error) {\n      console.error(`Error sending offer for stream ${streamName}:`, error);\n      throw error;\n    }\n  };\n  \n  // ICE candidates are handled internally by the browser for go2rtc\n  \n  /**\n   * Handle WebRTC error\n   * @param {string} streamName - Stream name\n   * @param {string} message - Error message\n   */\n  const handleWebRTCError = (streamName, message) => {\n    console.error(`WebRTC error for stream ${streamName}:`, message);\n    \n    // Find the video cell\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    if (!videoElement) return;\n    \n    const videoCell = videoElement.closest('.video-cell');\n    if (!videoCell) return;\n    \n    // Hide loading indicator\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'none';\n    }\n    \n    // Create error indicator if it doesn't exist\n    let errorIndicator = videoCell.querySelector('.error-indicator');\n    if (!errorIndicator) {\n      errorIndicator = document.createElement('div');\n      errorIndicator.className = 'error-indicator';\n      errorIndicator.style.position = 'absolute';\n      errorIndicator.style.top = '0';\n      errorIndicator.style.left = '0';\n      errorIndicator.style.width = '100%';\n      errorIndicator.style.height = '100%';\n      errorIndicator.style.display = 'flex';\n      errorIndicator.style.flexDirection = 'column';\n      errorIndicator.style.justifyContent = 'center';\n      errorIndicator.style.alignItems = 'center';\n      errorIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n      errorIndicator.style.color = 'white';\n      errorIndicator.style.zIndex = '20'; // Above video but below controls\n      videoCell.appendChild(errorIndicator);\n    }\n    \n    errorIndicator.innerHTML = `\n      <div class=\"error-icon\">!</div>\n      <p>${message || 'WebRTC connection failed'}</p>\n      <button class=\"retry-button mt-4 px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Retry</button>\n    `;\n    errorIndicator.style.display = 'flex';\n    \n    // Make sure retry button is clickable\n    const retryButton = errorIndicator.querySelector('.retry-button');\n    if (retryButton) {\n      retryButton.style.position = 'relative';\n      retryButton.style.zIndex = '30';\n      retryButton.style.pointerEvents = 'auto';\n      \n      retryButton.addEventListener('click', () => {\n        // Show loading indicator\n        if (loadingIndicator) {\n          loadingIndicator.style.display = 'flex';\n        }\n        \n        // Hide error indicator\n        errorIndicator.style.display = 'none';\n        \n        // Cleanup existing connection\n        cleanupWebRTCPlayer(streamName);\n        \n        // Fetch stream info again and reinitialize\n        fetch(`/api/streams/${encodeURIComponent(streamName)}`)\n          .then(response => response.json())\n          .then(streamInfo => {\n            // Reinitialize\n            initializeWebRTCPlayer(streamInfo);\n          })\n          .catch(error => {\n            console.error('Error fetching stream info:', error);\n            \n            // Show error indicator again with new message\n            errorIndicator.style.display = 'flex';\n            const errorMsg = errorIndicator.querySelector('p');\n            if (errorMsg) {\n              errorMsg.textContent = 'Could not reconnect: ' + error.message;\n            }\n            \n            // Hide loading indicator\n            if (loadingIndicator) {\n              loadingIndicator.style.display = 'none';\n            }\n          });\n      });\n    }\n  };\n  \n  /**\n   * Cleanup WebRTC player\n   * @param {string} streamName - Stream name\n   */\n  const cleanupWebRTCPlayer = (streamName) => {\n    // Close and remove the RTCPeerConnection\n    if (webrtcConnections.current[streamName]) {\n      webrtcConnections.current[streamName].close();\n      delete webrtcConnections.current[streamName];\n    }\n    \n    // Reset video element\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    if (videoElement) {\n      videoElement.srcObject = null;\n    }\n    \n    // Clean up detection polling\n    cleanupDetectionPolling(streamName, detectionIntervals.current);\n  };\n  \n  /**\n   * Stop all WebRTC streams\n   */\n  const stopAllWebRTCStreams = () => {\n    // Close all RTCPeerConnections\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      cleanupWebRTCPlayer(streamName);\n    });\n  };\n  \n/**\n * Take snapshot of a stream\n * @param {string} streamId - Stream ID\n */\nconst takeSnapshot = (streamId) => {\n  // Find the stream by button element\n  const streamElement = document.querySelector(`.snapshot-btn[data-id=\"${streamId}\"]`);\n  let streamName;\n  \n  if (streamElement) {\n    // Get the stream name from the data attribute\n    streamName = streamElement.getAttribute('data-name');\n  } else {\n    // If we can't find by data-id (which might be missing in the new UI),\n    // try to find the parent video cell and get the stream name\n    const clickedButton = event.currentTarget || event.target;\n    const videoCell = clickedButton.closest('.video-cell');\n    \n    if (videoCell) {\n      streamName = videoCell.dataset.streamName;\n    }\n  }\n  \n  if (!streamName) {\n    console.error('Stream name not found for snapshot');\n    showStatusMessage('Cannot take snapshot: Stream not identified');\n    return;\n  }\n\n  // Find the video element\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  if (!videoElement) {\n    console.error('Video element not found for stream:', streamName);\n    showStatusMessage('Cannot take snapshot: Video element not found');\n    return;\n  }\n\n  // Create a canvas element to capture the frame\n  const canvas = document.createElement('canvas');\n  canvas.width = videoElement.videoWidth;\n  canvas.height = videoElement.videoHeight;\n\n  // Check if we have valid dimensions\n  if (canvas.width === 0 || canvas.height === 0) {\n    console.error('Invalid video dimensions:', canvas.width, canvas.height);\n    showStatusMessage('Cannot take snapshot: Video not loaded or has invalid dimensions');\n    return;\n  }\n\n  // Draw the current frame to the canvas\n  const ctx = canvas.getContext('2d');\n  ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);\n\n  try {\n    // Save the canvas to global scope for direct access in the overlay\n    window.__snapshotCanvas = canvas;\n    \n    // Generate a filename\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = `snapshot-${streamName.replace(/\\s+/g, '-')}-${timestamp}.jpg`;\n    window.__snapshotFileName = fileName;\n    \n    // Show the standard preview\n    showSnapshotPreview(canvas.toDataURL('image/jpeg', 0.95), `Snapshot: ${streamName}`);\n    \n    // Show success message\n    showStatusMessage('Snapshot taken successfully');\n  } catch (error) {\n    console.error('Error creating snapshot:', error);\n    showStatusMessage('Failed to create snapshot: ' + error.message);\n  }\n};\n  \n  /**\n   * Toggle fullscreen mode for a specific stream\n   * @param {string} streamName - Stream name\n   */\n  const toggleStreamFullscreen = (streamName) => {\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n    \n    if (!videoCell) {\n      console.error('Stream not found:', streamName);\n      return;\n    }\n    \n    if (!document.fullscreenElement) {\n      videoCell.requestFullscreen().catch(err => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n      });\n    } else {\n      document.exitFullscreen();\n    }\n  };\n  \n  return html`\n    <section id=\"live-page\" class=\"page\">\n      <div class=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\">\n        <div class=\"flex items-center space-x-2\">\n          <h2 class=\"text-xl font-bold mr-4\">Live View</h2>\n          <div class=\"flex space-x-2\">\n            <button \n              id=\"hls-toggle-btn\" \n              class=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick=${() => window.location.href = '/hls.html'}\n            >\n              HLS View\n            </button>\n            <button \n              id=\"fullscreen-btn\" \n              class=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick=${() => toggleFullscreen(isFullscreen, setIsFullscreen)}\n            >\n              Fullscreen\n            </button>\n          </div>\n        </div>\n        <div class=\"controls flex items-center space-x-2\">\n          <select \n            id=\"layout-selector\" \n            class=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n            value=${layout}\n            onChange=${(e) => {\n              setLayout(e.target.value);\n              setCurrentPage(0); // Reset to first page when layout changes\n            }}\n          >\n            <option value=\"1\">Single View</option>\n            <option value=\"2\">2x1 Grid</option>\n            <option value=\"4\" selected>2x2 Grid</option>\n            <option value=\"6\">2x3 Grid</option>\n            <option value=\"9\">3x3 Grid</option>\n            <option value=\"16\">4x4 Grid</option>\n          </select>\n          \n          ${layout === '1' && html`\n            <select \n              id=\"stream-selector\" \n              class=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n              value=${selectedStream}\n              onChange=${(e) => setSelectedStream(e.target.value)}\n            >\n              ${streams.map(stream => html`\n                <option key=${stream.name} value=${stream.name}>${stream.name}</option>\n              `)}\n            </select>\n          `}\n        </div>\n      </div>\n      \n      <div class=\"flex flex-col space-y-4\">\n        <div \n          id=\"video-grid\" \n          class=${`video-container layout-${layout}`}\n          ref=${videoGridRef}\n        >\n          ${isLoading ? html`\n            <div class=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n              <div class=\"flex flex-col items-center justify-center py-8\">\n                <div class=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                <p class=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ` : streams.length === 0 ? html`\n            <div class=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p class=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n              <a href=\"streams.html\" class=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n            </div>\n          ` : null}\n          <!-- Video cells will be dynamically added by the updateVideoGrid function -->\n        </div>\n        \n        ${layout !== '1' && streams.length > getMaxStreamsForLayout() ? html`\n          <div class=\"pagination-controls flex justify-center items-center space-x-4 mt-4\">\n            <button \n              class=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick=${() => setCurrentPage(Math.max(0, currentPage - 1))}\n              disabled=${currentPage === 0}\n            >\n              Previous\n            </button>\n            <span class=\"text-gray-700 dark:text-gray-300\">\n              Page ${currentPage + 1} of ${Math.ceil(streams.length / getMaxStreamsForLayout())}\n            </span>\n            <button \n              class=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick=${() => setCurrentPage(Math.min(Math.ceil(streams.length / getMaxStreamsForLayout()) - 1, currentPage + 1))}\n              disabled=${currentPage >= Math.ceil(streams.length / getMaxStreamsForLayout()) - 1}\n            >\n              Next\n            </button>\n          </div>\n        ` : null}\n      </div>\n    </section>\n  `;\n}\n\n/**\n * Load WebRTCView component\n */\nexport function loadWebRTCView() {\n  const mainContent = document.getElementById('main-content');\n  if (!mainContent) return;\n  \n  // Render the WebRTCView component to the container\n  import('../../preact.min.js').then(({ render }) => {\n    render(html`<${WebRTCView} />`, mainContent);\n  });\n}\n\n// The component is initialized by preact-app.js when needed\n"],"names":["WebRTCView","streams","setStreams","useState","layout","setLayout","selectedStream","setSelectedStream","isFullscreen","setIsFullscreen","isLoading","setIsLoading","currentPage","setCurrentPage","videoGridRef","useRef","webrtcConnections","detectionIntervals","useEffect","setupModals","addStatusMessageStyles","addModalStyles","handleEscape","e","key","console","log","livePage","document","getElementById","classList","contains","exitFullscreenMode","addEventListener","handleBeforeUnload","stopAllWebRTCStreams","handleVisibilityChange","hidden","Object","keys","current","forEach","streamName","pc","connectionState","videoElementId","replace","videoElement","pause","play","catch","warn","window","connectionCheckInterval","setInterval","debug","iceConnectionState","cleanupWebRTCPlayer","stream","find","s","name","initializeWebRTCPlayer","removeEventListener","clearInterval","timeoutId","setTimeout","showStatusMessage","loadStreams","then","streamData","clearTimeout","length","error","message","updateVideoGrid","async","timeoutPromise","Promise","_","reject","Error","fetchPromise","fetch","response","race","ok","jsonTimeoutPromise","jsonPromise","json","streamPromises","map","detailsTimeoutPromise","detailsFetchPromise","encodeURIComponent","id","detailedStreams","all","filteredStreams","filter","is_deleted","enabled","streaming_enabled","getMaxStreamsForLayout","placeholder","querySelector","innerHTML","appendChild","streamsToShow","maxStreams","totalPages","Math","ceil","max","startIdx","endIdx","min","slice","index","createVideoCell","streamId","videoCell","createElement","className","dataset","style","position","playsInline","autoplay","muted","pointerEvents","loadingIndicator","top","left","width","height","display","flexDirection","justifyContent","alignItems","backgroundColor","color","zIndex","errorIndicator","streamNameOverlay","textContent","padding","borderRadius","fontSize","streamControls","bottom","right","gap","canvasOverlay","querySelectorAll","button","snapshotBtn","event","takeSnapshot","fullscreenBtn","toggleStreamFullscreen","closest","canvasId","RTCPeerConnection","iceServers","urls","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","sdpSemantics","ontrack","track","kind","srcObject","onloadeddata","onicecandidate","candidate","oniceconnectionstatechange","handleWebRTCError","addTransceiver","direction","setupTimeoutId","createOffer","offerToReceiveAudio","offerToReceiveVideo","offer","sdp","includes","setLocalDescription","sendOffer","localDescription","answer","setRemoteDescription","RTCSessionDescription","detection_based_recording","detection_model","detection_threshold","startDetectionPolling","auth","localStorage","getItem","formattedOffer","type","controller","AbortController","signal","abort","method","headers","Authorization","body","JSON","stringify","status","statusText","jsonController","jsonTimeoutId","text","parse","jsonError","textError","fetchError","retryButton","streamInfo","errorMsg","close","cleanupDetectionPolling","streamElement","getAttribute","currentTarget","target","canvas","videoWidth","videoHeight","getContext","drawImage","__snapshotCanvas","timestamp","Date","toISOString","fileName","__snapshotFileName","showSnapshotPreview","toDataURL","fullscreenElement","exitFullscreen","requestFullscreen","err","html","location","href","toggleFullscreen","value","mainContent","__vitePreload","render","module","import","n","p","meta","url"],"mappings":"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"}