{"version":3,"file":"DetectionOverlay-legacy-CSCOIoen.js","sources":["../../js/components/preact/FullscreenManager.js","../../js/components/preact/DetectionOverlay.js"],"sourcesContent":["/**\n * Fullscreen functionality for LiveView\n */\n\nimport { showStatusMessage } from './UI.js';\n\n/**\n * Exit fullscreen mode\n * @param {Event} e - Optional event object\n * @param {Function} setIsFullscreen - State setter for fullscreen state\n */\nexport function exitFullscreenMode(e, setIsFullscreen) {\n  // If this was called from an event, stop propagation\n  if (e) {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  console.log(\"DIRECT EXIT FUNCTION CALLED\");\n\n  const livePage = document.getElementById('live-page');\n  if (!livePage) {\n    console.error(\"Live page element not found\");\n    return;\n  }\n\n  // Exit fullscreen\n  livePage.classList.remove('fullscreen-mode');\n  document.body.style.overflow = '';\n\n  // Remove exit button\n  const exitBtn = document.querySelector('.fullscreen-exit');\n  if (exitBtn) {\n    exitBtn.remove();\n  } else {\n    console.warn(\"Exit button not found when trying to remove it\");\n  }\n\n  // Show the fullscreen button again\n  const fullscreenBtn = document.getElementById('fullscreen-btn');\n  if (fullscreenBtn) {\n    fullscreenBtn.style.display = '';\n  } else {\n    console.warn(\"Fullscreen button not found when trying to show it again\");\n  }\n\n  // Remove the escape key handler if it exists\n  if (window._fullscreenEscapeHandler) {\n    document.removeEventListener('keydown', window._fullscreenEscapeHandler);\n    delete window._fullscreenEscapeHandler;\n  }\n\n  // Update state\n  setIsFullscreen(false);\n\n  console.log(\"Fullscreen mode exited, state set to false\");\n}\n\n/**\n * Toggle fullscreen mode for the entire live view\n * @param {boolean} isFullscreen - Current fullscreen state\n * @param {Function} setIsFullscreen - State setter for fullscreen state\n */\nexport function toggleFullscreen(isFullscreen, setIsFullscreen) {\n  console.log(\"toggleFullscreen called, current state:\", isFullscreen);\n\n  const livePage = document.getElementById('live-page');\n\n  if (!livePage) {\n    console.error(\"Live page element not found\");\n    return;\n  }\n\n  const isCurrentlyInFullscreen = livePage.classList.contains('fullscreen-mode');\n  console.log(\"DOM check for fullscreen mode:\", isCurrentlyInFullscreen);\n\n  if (!isCurrentlyInFullscreen) {\n    console.log(\"Entering fullscreen mode\");\n    // Enter fullscreen\n    livePage.classList.add('fullscreen-mode');\n    document.body.style.overflow = 'hidden';\n\n    // Add exit button - IMPORTANT: Use a standalone function for the click handler\n    const exitBtn = document.createElement('button');\n    exitBtn.className = 'fullscreen-exit fixed top-4 right-4 w-10 h-10 bg-black/70 text-white rounded-full flex justify-center items-center cursor-pointer z-50 transition-all duration-200 hover:bg-black/85 hover:scale-110 shadow-md';\n    exitBtn.innerHTML = 'âœ•';\n\n    // Create a standalone function for the click handler\n    const exitClickHandler = function(e) {\n      console.log(\"Exit button clicked - STANDALONE HANDLER\");\n      exitFullscreenMode(e, setIsFullscreen);\n    };\n\n    // Add the event listener with the standalone function\n    exitBtn.addEventListener('click', exitClickHandler);\n\n    livePage.appendChild(exitBtn);\n\n    // Hide the fullscreen button in the controls when in fullscreen mode\n    const fullscreenBtn = document.getElementById('fullscreen-btn');\n    if (fullscreenBtn) {\n      fullscreenBtn.style.display = 'none';\n    }\n\n    // Add event listener for Escape key\n    const escapeHandler = function(e) {\n      if (e.key === 'Escape') {\n        console.log(\"Escape key pressed in fullscreen mode\");\n        exitFullscreenMode(null, setIsFullscreen);\n      }\n    };\n\n    // Store the handler on the window object so we can remove it later\n    window._fullscreenEscapeHandler = escapeHandler;\n    document.addEventListener('keydown', escapeHandler);\n\n    // Update state\n    setIsFullscreen(true);\n    console.log(\"Fullscreen mode entered, state set to true\");\n  } else {\n    exitFullscreenMode(null, setIsFullscreen);\n  }\n}\n\n/**\n * Toggle fullscreen mode for a specific stream\n * @param {string} streamName - Name of the stream\n */\nexport function toggleStreamFullscreen(streamName) {\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n\n  if (!videoCell) {\n    console.error('Stream not found:', streamName);\n    return;\n  }\n\n  if (!document.fullscreenElement) {\n    videoCell.requestFullscreen().catch(err => {\n      console.error(`Error attempting to enable fullscreen: ${err.message}`);\n      showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n    });\n  } else {\n    document.exitFullscreen();\n  }\n}\n","/**\n * Detection overlay functionality for LiveView\n */\n\n/**\n * Start detection polling for a stream\n * @param {string} streamName - Name of the stream\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n * @param {Object} detectionIntervals - Reference to store interval IDs\n * @returns {number} Interval ID\n */\nexport function startDetectionPolling(streamName, canvasOverlay, videoElement, detectionIntervals) {\n  // Clear existing interval if any\n  if (detectionIntervals[streamName]) {\n    clearInterval(detectionIntervals[streamName]);\n  }\n  \n  // Function to draw bounding boxes\n  const drawDetectionBoxes = (detections) => {\n    const canvas = canvasOverlay;\n    const ctx = canvas.getContext('2d');\n    \n    // Set canvas dimensions to match the displayed video element\n    canvas.width = videoElement.clientWidth;\n    canvas.height = videoElement.clientHeight;\n    \n    // Clear previous drawings\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // No detections, just return\n    if (!detections || detections.length === 0) {\n      return;\n    }\n    \n    // Get the actual video dimensions\n    const videoWidth = videoElement.videoWidth;\n    const videoHeight = videoElement.videoHeight;\n    \n    // If video dimensions aren't available yet, skip drawing\n    if (!videoWidth || !videoHeight) {\n      console.log('Video dimensions not available yet, skipping detection drawing');\n      return;\n    }\n    \n    // Calculate the scaling and positioning to maintain aspect ratio\n    const videoAspect = videoWidth / videoHeight;\n    const canvasAspect = canvas.width / canvas.height;\n    \n    let drawWidth, drawHeight, offsetX = 0, offsetY = 0;\n    \n    if (videoAspect > canvasAspect) {\n      // Video is wider than canvas (letterboxing - black bars on top and bottom)\n      drawWidth = canvas.width;\n      drawHeight = canvas.width / videoAspect;\n      offsetY = (canvas.height - drawHeight) / 2;\n    } else {\n      // Video is taller than canvas (pillarboxing - black bars on sides)\n      drawHeight = canvas.height;\n      drawWidth = canvas.height * videoAspect;\n      offsetX = (canvas.width - drawWidth) / 2;\n    }\n    \n    // Draw each detection\n    detections.forEach(detection => {\n      // Calculate pixel coordinates based on normalized values (0-1)\n      // and adjust for the actual display area\n      const x = (detection.x * drawWidth) + offsetX;\n      const y = (detection.y * drawHeight) + offsetY;\n      const width = detection.width * drawWidth;\n      const height = detection.height * drawHeight;\n      \n      // Draw bounding box\n      ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(x, y, width, height);\n      \n      // Draw label background\n      const label = `${detection.label} (${Math.round(detection.confidence * 100)}%)`;\n      ctx.font = '14px Arial';\n      const textWidth = ctx.measureText(label).width;\n      ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';\n      ctx.fillRect(x, y - 20, textWidth + 10, 20);\n      \n      // Draw label text\n      ctx.fillStyle = 'white';\n      ctx.fillText(label, x + 5, y - 5);\n    });\n  };\n  \n  // Use a more conservative polling interval (1000ms instead of 500ms)\n  // and implement exponential backoff on errors\n  let errorCount = 0;\n  let currentInterval = 1000; // Start with 1 second\n  \n  // Create a polling function that we can reference for recreating intervals\n  const pollDetections = () => {\n    if (!videoElement.videoWidth) {\n      // Video not loaded yet, skip this cycle\n      return;\n    }\n    \n    // Fetch detection results from API\n    fetch(`/api/detection/results/${encodeURIComponent(streamName)}`)\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`Failed to fetch detection results: ${response.status}`);\n        }\n        // Reset error count on success\n        errorCount = 0;\n        return response.json();\n      })\n      .then(data => {\n        // Draw bounding boxes if we have detections\n        if (data && data.detections) {\n          drawDetectionBoxes(data.detections);\n        }\n      })\n      .catch(error => {\n        console.error(`Error fetching detection results for ${streamName}:`, error);\n        // Clear canvas on error\n        const ctx = canvasOverlay.getContext('2d');\n        ctx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);\n        \n        // Implement backoff strategy on errors\n        errorCount++;\n        if (errorCount > 3) {\n          // After 3 consecutive errors, slow down polling to avoid overwhelming the server\n          clearInterval(detectionIntervals[streamName]);\n          currentInterval = Math.min(5000, currentInterval * 2); // Max 5 seconds\n          console.log(`Reducing detection polling frequency to ${currentInterval}ms due to errors`);\n          \n          // Create a new interval with the updated taming\n          detectionIntervals[streamName] = setInterval(pollDetections, currentInterval);\n        }\n      });\n  };\n  \n  // Start the polling interval\n  const intervalId = setInterval(pollDetections, currentInterval);\n  \n  // Store interval ID for cleanup\n  detectionIntervals[streamName] = intervalId;\n  canvasOverlay.detectionInterval = intervalId;\n  \n  return intervalId;\n}\n\n/**\n * Clean up detection polling\n * @param {string} streamName - Name of the stream\n * @param {Object} detectionIntervals - Reference to stored interval IDs\n */\nexport function cleanupDetectionPolling(streamName, detectionIntervals) {\n  const canvasId = `canvas-${streamName.replace(/\\s+/g, '-')}`;\n  const canvasOverlay = document.getElementById(canvasId);\n  \n  if (canvasOverlay && canvasOverlay.detectionInterval) {\n    clearInterval(canvasOverlay.detectionInterval);\n    delete canvasOverlay.detectionInterval;\n  }\n  \n  if (detectionIntervals[streamName]) {\n    clearInterval(detectionIntervals[streamName]);\n    delete detectionIntervals[streamName];\n  }\n}\n\n/**\n * Draw detections on canvas overlay\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {HTMLVideoElement} videoElement - Video element\n * @param {Array} detections - Array of detection objects\n */\nexport function drawDetections(canvas, videoElement, detections) {\n  if (!canvas || !videoElement || !detections || !detections.length) return;\n  \n  const ctx = canvas.getContext('2d');\n  if (!ctx) return;\n  \n  // Clear previous drawings\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  \n  // Get video dimensions\n  const videoWidth = videoElement.videoWidth;\n  const videoHeight = videoElement.videoHeight;\n  \n  if (videoWidth === 0 || videoHeight === 0) return;\n  \n  // Ensure canvas dimensions match video container dimensions\n  if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {\n    canvas.width = canvas.offsetWidth;\n    canvas.height = canvas.offsetHeight;\n  }\n  \n  // For object-fit: cover, we need to calculate the visible portion of the video\n  const videoAspect = videoWidth / videoHeight;\n  const canvasAspect = canvas.width / canvas.height;\n  \n  let scale, offsetX = 0, offsetY = 0;\n  \n  if (videoAspect > canvasAspect) {\n    // Video is wider than canvas - some width is cropped\n    scale = canvas.height / videoHeight;\n    offsetX = (videoWidth * scale - canvas.width) / 2;\n  } else {\n    // Video is taller than canvas - some height is cropped\n    scale = canvas.width / videoWidth;\n    offsetY = (videoHeight * scale - canvas.height) / 2;\n  }\n  \n  // Draw each detection\n  detections.forEach(detection => {\n    // Convert normalized coordinates to canvas coordinates\n    const x = (detection.x * videoWidth * scale) - offsetX;\n    const y = (detection.y * videoHeight * scale) - offsetY;\n    const width = detection.width * videoWidth * scale;\n    const height = detection.height * videoHeight * scale;\n    \n    // Draw bounding box\n    ctx.strokeStyle = detection.color || '#00FF00';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(x, y, width, height);\n    \n    // Draw label background\n    ctx.fillStyle = detection.color || '#00FF00';\n    const label = `${detection.class} ${Math.round(detection.confidence * 100)}%`;\n    const textWidth = ctx.measureText(label).width + 10;\n    ctx.fillRect(x, y - 20, textWidth, 20);\n    \n    // Draw label text\n    ctx.fillStyle = '#000000';\n    ctx.font = '12px Arial';\n    ctx.fillText(label, x + 5, y - 5);\n  });\n}\n\n/**\n * Handle fullscreen change events for detection overlay\n * @param {Event} event - Fullscreen change event\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n */\nexport function handleFullscreenChange(event, canvasOverlay, videoElement) {\n  if (document.fullscreenElement) {\n    // When entering fullscreen, resize the canvas to match the fullscreen dimensions\n    setTimeout(() => {\n      if (canvasOverlay && videoElement) {\n        canvasOverlay.width = videoElement.clientWidth;\n        canvasOverlay.height = videoElement.clientHeight;\n        \n        // Ensure the canvas is positioned correctly in fullscreen\n        canvasOverlay.style.position = 'absolute';\n        canvasOverlay.style.top = '0';\n        canvasOverlay.style.left = '0';\n        canvasOverlay.style.width = '100%';\n        canvasOverlay.style.height = '100%';\n        canvasOverlay.style.zIndex = '10'; // Ensure it's above the video but below controls\n      }\n    }, 100); // Small delay to allow fullscreen to complete\n  } else {\n    // When exiting fullscreen, reset the canvas dimensions\n    setTimeout(() => {\n      if (canvasOverlay && videoElement) {\n        canvasOverlay.width = videoElement.clientWidth;\n        canvasOverlay.height = videoElement.clientHeight;\n      }\n    }, 100);\n  }\n}\n\n/**\n * Ensure controls are visible above the detection overlay\n * @param {string} streamName - Name of the stream\n */\nexport function ensureControlsVisibility(streamName) {\n  const streamId = streamName.replace(/\\s+/g, '-');\n  const videoCell = document.querySelector(`.video-cell[data-stream=\"${streamId}\"]`);\n  \n  if (!videoCell) return;\n  \n  // Find all controls within this cell\n  const controls = videoCell.querySelector('.stream-controls');\n  if (controls) {\n    // Ensure controls are above the canvas overlay\n    controls.style.position = 'relative';\n    controls.style.zIndex = '30'; // Higher than the canvas overlay\n    controls.style.pointerEvents = 'auto'; // Ensure clicks are registered\n    \n    // Remove any fullscreen button as it's redundant\n    const fullscreenBtn = controls.querySelector('.fullscreen-btn');\n    if (fullscreenBtn) {\n      fullscreenBtn.remove();\n    }\n  }\n  \n  // Find and fix snapshot button specifically\n  const snapshotBtn = videoCell.querySelector('.snapshot-btn');\n  if (snapshotBtn) {\n    snapshotBtn.style.position = 'relative';\n    snapshotBtn.style.zIndex = '30';\n    snapshotBtn.style.pointerEvents = 'auto';\n  }\n  \n  // Find and fix all buttons in the video cell\n  const allButtons = videoCell.querySelectorAll('button');\n  allButtons.forEach(button => {\n    button.style.position = 'relative';\n    button.style.zIndex = '30';\n    button.style.pointerEvents = 'auto';\n  });\n  \n  // Make sure the video element itself doesn't block clicks\n  const video = videoCell.querySelector('video');\n  if (video) {\n    video.style.pointerEvents = 'none';\n  }\n}\n\n/**\n * Initialize detection overlay for a stream\n * @param {string} streamName - Name of the stream\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n * @param {Object} detectionIntervals - Reference to store interval IDs\n */\nexport function initializeDetectionOverlay(streamName, canvasOverlay, videoElement, detectionIntervals) {\n  // Ensure the canvas is properly positioned\n  canvasOverlay.style.position = 'absolute';\n  canvasOverlay.style.top = '0';\n  canvasOverlay.style.left = '0';\n  canvasOverlay.style.width = '100%';\n  canvasOverlay.style.height = '100%';\n  canvasOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through\n  canvasOverlay.style.zIndex = '5'; // Above video but below controls\n  \n  // Find the parent container and ensure proper stacking context\n  const parentContainer = canvasOverlay.parentElement;\n  if (parentContainer) {\n    parentContainer.style.position = 'relative'; // Create stacking context\n  }\n  \n  // Ensure controls are visible\n  ensureControlsVisibility(streamName);\n  \n  // Add fullscreen change listener\n  document.addEventListener('fullscreenchange', (event) => {\n    handleFullscreenChange(event, canvasOverlay, videoElement);\n    \n    // Re-ensure controls visibility after fullscreen change\n    setTimeout(() => ensureControlsVisibility(streamName), 200);\n  });\n  \n  // Start detection polling\n  return startDetectionPolling(streamName, canvasOverlay, videoElement, detectionIntervals);\n}\n\n/**\n * Add snapshot functionality to detection overlay\n * @param {string} streamName - Name of the stream\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n */\nexport function addSnapshotWithDetections(streamName, canvasOverlay, videoElement) {\n  const streamId = streamName.replace(/\\s+/g, '-');\n  const videoCell = document.querySelector(`.video-cell[data-stream=\"${streamId}\"]`);\n  \n  if (!videoCell) return;\n  \n  // Find the snapshot button\n  const snapshotBtn = videoCell.querySelector(`.snapshot-btn[data-id=\"${streamId}\"]`);\n  if (!snapshotBtn) return;\n  \n  // Create a wrapper for the original click handler\n  const originalOnClick = snapshotBtn.onclick;\n  \n  // Replace with our enhanced version that includes detections\n  snapshotBtn.onclick = function(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    \n    // Create a combined canvas with video and detections\n    const combinedCanvas = document.createElement('canvas');\n    combinedCanvas.width = videoElement.videoWidth;\n    combinedCanvas.height = videoElement.videoHeight;\n    const ctx = combinedCanvas.getContext('2d');\n    \n    // Draw the video frame\n    ctx.drawImage(videoElement, 0, 0, combinedCanvas.width, combinedCanvas.height);\n    \n    // Draw the detections from the overlay canvas\n    if (canvasOverlay.width > 0 && canvasOverlay.height > 0) {\n      ctx.drawImage(canvasOverlay, 0, 0, canvasOverlay.width, canvasOverlay.height, \n                   0, 0, combinedCanvas.width, combinedCanvas.height);\n    }\n    \n    // Store the canvas for the snapshot functionality\n    window.__snapshotCanvas = combinedCanvas;\n    \n    // Generate a filename\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = `snapshot-${streamName.replace(/\\s+/g, '-')}-${timestamp}.jpg`;\n    window.__snapshotFileName = fileName;\n    \n    // Show the standard preview\n    const dataUrl = combinedCanvas.toDataURL('image/jpeg', 0.95);\n    showSnapshotPreview(dataUrl, `Snapshot: ${streamName}`);\n    \n    // Call the original handler if it exists\n    if (typeof originalOnClick === 'function') {\n      originalOnClick.call(this, event);\n    }\n    \n    return false;\n  };\n  \n  // Make sure the button is visible\n  snapshotBtn.style.position = 'relative';\n  snapshotBtn.style.zIndex = '30';\n  snapshotBtn.style.pointerEvents = 'auto';\n  \n  console.log('Enhanced snapshot button with detection overlay capability');\n}\n"],"names":["exitFullscreenMode","e","setIsFullscreen","stopPropagation","preventDefault","console","log","livePage","document","getElementById","error","classList","remove","body","style","overflow","exitBtn","querySelector","warn","fullscreenBtn","display","window","_fullscreenEscapeHandler","removeEventListener","streamName","videoElementId","replace","videoElement","videoCell","closest","fullscreenElement","exitFullscreen","requestFullscreen","catch","err","message","showStatusMessage","detectionIntervals","canvasId","canvasOverlay","detectionInterval","clearInterval","errorCount","currentInterval","pollDetections","videoWidth","fetch","encodeURIComponent","then","response","ok","Error","status","json","data","detections","canvas","ctx","getContext","width","clientWidth","height","clientHeight","clearRect","length","videoHeight","videoAspect","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","forEach","detection","x","y","strokeStyle","lineWidth","strokeRect","label","Math","round","confidence","font","textWidth","measureText","fillStyle","fillRect","fillText","drawDetectionBoxes","min","setInterval","intervalId","isFullscreen","isCurrentlyInFullscreen","contains","add","createElement","className","innerHTML","exitClickHandler","addEventListener","appendChild","escapeHandler","key"],"mappings":"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"}