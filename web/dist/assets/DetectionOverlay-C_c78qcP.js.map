{"version":3,"file":"DetectionOverlay-C_c78qcP.js","sources":["../../js/components/preact/FullscreenManager.js","../../js/components/preact/DetectionOverlay.js"],"sourcesContent":["/**\n * Fullscreen functionality for LiveView\n */\n\nimport { showStatusMessage } from './UI.js';\n\n/**\n * Exit fullscreen mode\n * @param {Event} e - Optional event object\n * @param {Function} setIsFullscreen - State setter for fullscreen state\n */\nexport function exitFullscreenMode(e, setIsFullscreen) {\n  // If this was called from an event, stop propagation\n  if (e) {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  console.log(\"DIRECT EXIT FUNCTION CALLED\");\n\n  const livePage = document.getElementById('live-page');\n  if (!livePage) {\n    console.error(\"Live page element not found\");\n    return;\n  }\n\n  // Exit fullscreen\n  livePage.classList.remove('fullscreen-mode');\n  document.body.style.overflow = '';\n\n  // Remove exit button\n  const exitBtn = document.querySelector('.fullscreen-exit');\n  if (exitBtn) {\n    exitBtn.remove();\n  } else {\n    console.warn(\"Exit button not found when trying to remove it\");\n  }\n\n  // Show the fullscreen button again\n  const fullscreenBtn = document.getElementById('fullscreen-btn');\n  if (fullscreenBtn) {\n    fullscreenBtn.style.display = '';\n  } else {\n    console.warn(\"Fullscreen button not found when trying to show it again\");\n  }\n\n  // Remove the escape key handler if it exists\n  if (window._fullscreenEscapeHandler) {\n    document.removeEventListener('keydown', window._fullscreenEscapeHandler);\n    delete window._fullscreenEscapeHandler;\n  }\n\n  // Update state\n  setIsFullscreen(false);\n\n  console.log(\"Fullscreen mode exited, state set to false\");\n}\n\n/**\n * Toggle fullscreen mode for the entire live view\n * @param {boolean} isFullscreen - Current fullscreen state\n * @param {Function} setIsFullscreen - State setter for fullscreen state\n */\nexport function toggleFullscreen(isFullscreen, setIsFullscreen) {\n  console.log(\"toggleFullscreen called, current state:\", isFullscreen);\n\n  const livePage = document.getElementById('live-page');\n\n  if (!livePage) {\n    console.error(\"Live page element not found\");\n    return;\n  }\n\n  const isCurrentlyInFullscreen = livePage.classList.contains('fullscreen-mode');\n  console.log(\"DOM check for fullscreen mode:\", isCurrentlyInFullscreen);\n\n  if (!isCurrentlyInFullscreen) {\n    console.log(\"Entering fullscreen mode\");\n    // Enter fullscreen\n    livePage.classList.add('fullscreen-mode');\n    document.body.style.overflow = 'hidden';\n\n    // Add exit button - IMPORTANT: Use a standalone function for the click handler\n    const exitBtn = document.createElement('button');\n    exitBtn.className = 'fullscreen-exit fixed top-4 right-4 w-10 h-10 bg-black/70 text-white rounded-full flex justify-center items-center cursor-pointer z-50 transition-all duration-200 hover:bg-black/85 hover:scale-110 shadow-md';\n    exitBtn.innerHTML = 'âœ•';\n\n    // Create a standalone function for the click handler\n    const exitClickHandler = function(e) {\n      console.log(\"Exit button clicked - STANDALONE HANDLER\");\n      exitFullscreenMode(e, setIsFullscreen);\n    };\n\n    // Add the event listener with the standalone function\n    exitBtn.addEventListener('click', exitClickHandler);\n\n    livePage.appendChild(exitBtn);\n\n    // Hide the fullscreen button in the controls when in fullscreen mode\n    const fullscreenBtn = document.getElementById('fullscreen-btn');\n    if (fullscreenBtn) {\n      fullscreenBtn.style.display = 'none';\n    }\n\n    // Add event listener for Escape key\n    const escapeHandler = function(e) {\n      if (e.key === 'Escape') {\n        console.log(\"Escape key pressed in fullscreen mode\");\n        exitFullscreenMode(null, setIsFullscreen);\n      }\n    };\n\n    // Store the handler on the window object so we can remove it later\n    window._fullscreenEscapeHandler = escapeHandler;\n    document.addEventListener('keydown', escapeHandler);\n\n    // Update state\n    setIsFullscreen(true);\n    console.log(\"Fullscreen mode entered, state set to true\");\n  } else {\n    exitFullscreenMode(null, setIsFullscreen);\n  }\n}\n\n/**\n * Toggle fullscreen mode for a specific stream\n * @param {string} streamName - Name of the stream\n */\nexport function toggleStreamFullscreen(streamName) {\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n\n  if (!videoCell) {\n    console.error('Stream not found:', streamName);\n    return;\n  }\n\n  if (!document.fullscreenElement) {\n    videoCell.requestFullscreen().catch(err => {\n      console.error(`Error attempting to enable fullscreen: ${err.message}`);\n      showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n    });\n  } else {\n    document.exitFullscreen();\n  }\n}\n","/**\n * Detection overlay functionality for LiveView\n */\n\n/**\n * Start detection polling for a stream\n * @param {string} streamName - Name of the stream\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n * @param {Object} detectionIntervals - Reference to store interval IDs\n * @returns {number} Interval ID\n */\nexport function startDetectionPolling(streamName, canvasOverlay, videoElement, detectionIntervals) {\n  // Clear existing interval if any\n  if (detectionIntervals[streamName]) {\n    clearInterval(detectionIntervals[streamName]);\n  }\n  \n  // Function to draw bounding boxes\n  const drawDetectionBoxes = (detections) => {\n    const canvas = canvasOverlay;\n    const ctx = canvas.getContext('2d');\n    \n    // Set canvas dimensions to match the displayed video element\n    canvas.width = videoElement.clientWidth;\n    canvas.height = videoElement.clientHeight;\n    \n    // Clear previous drawings\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // No detections, just return\n    if (!detections || detections.length === 0) {\n      return;\n    }\n    \n    // Get the actual video dimensions\n    const videoWidth = videoElement.videoWidth;\n    const videoHeight = videoElement.videoHeight;\n    \n    // If video dimensions aren't available yet, skip drawing\n    if (!videoWidth || !videoHeight) {\n      console.log('Video dimensions not available yet, skipping detection drawing');\n      return;\n    }\n    \n    // Calculate the scaling and positioning to maintain aspect ratio\n    const videoAspect = videoWidth / videoHeight;\n    const canvasAspect = canvas.width / canvas.height;\n    \n    let drawWidth, drawHeight, offsetX = 0, offsetY = 0;\n    \n    if (videoAspect > canvasAspect) {\n      // Video is wider than canvas (letterboxing - black bars on top and bottom)\n      drawWidth = canvas.width;\n      drawHeight = canvas.width / videoAspect;\n      offsetY = (canvas.height - drawHeight) / 2;\n    } else {\n      // Video is taller than canvas (pillarboxing - black bars on sides)\n      drawHeight = canvas.height;\n      drawWidth = canvas.height * videoAspect;\n      offsetX = (canvas.width - drawWidth) / 2;\n    }\n    \n    // Draw each detection\n    detections.forEach(detection => {\n      // Calculate pixel coordinates based on normalized values (0-1)\n      // and adjust for the actual display area\n      const x = (detection.x * drawWidth) + offsetX;\n      const y = (detection.y * drawHeight) + offsetY;\n      const width = detection.width * drawWidth;\n      const height = detection.height * drawHeight;\n      \n      // Draw bounding box\n      ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(x, y, width, height);\n      \n      // Draw label background\n      const label = `${detection.label} (${Math.round(detection.confidence * 100)}%)`;\n      ctx.font = '14px Arial';\n      const textWidth = ctx.measureText(label).width;\n      ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';\n      ctx.fillRect(x, y - 20, textWidth + 10, 20);\n      \n      // Draw label text\n      ctx.fillStyle = 'white';\n      ctx.fillText(label, x + 5, y - 5);\n    });\n  };\n  \n  // Use a more conservative polling interval (1000ms instead of 500ms)\n  // and implement exponential backoff on errors\n  let errorCount = 0;\n  let currentInterval = 1000; // Start with 1 second\n  \n  // Create a polling function that we can reference for recreating intervals\n  const pollDetections = () => {\n    if (!videoElement.videoWidth) {\n      // Video not loaded yet, skip this cycle\n      return;\n    }\n    \n    // Fetch detection results from API\n    fetch(`/api/detection/results/${encodeURIComponent(streamName)}`)\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`Failed to fetch detection results: ${response.status}`);\n        }\n        // Reset error count on success\n        errorCount = 0;\n        return response.json();\n      })\n      .then(data => {\n        // Draw bounding boxes if we have detections\n        if (data && data.detections) {\n          drawDetectionBoxes(data.detections);\n        }\n      })\n      .catch(error => {\n        console.error(`Error fetching detection results for ${streamName}:`, error);\n        // Clear canvas on error\n        const ctx = canvasOverlay.getContext('2d');\n        ctx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);\n        \n        // Implement backoff strategy on errors\n        errorCount++;\n        if (errorCount > 3) {\n          // After 3 consecutive errors, slow down polling to avoid overwhelming the server\n          clearInterval(detectionIntervals[streamName]);\n          currentInterval = Math.min(5000, currentInterval * 2); // Max 5 seconds\n          console.log(`Reducing detection polling frequency to ${currentInterval}ms due to errors`);\n          \n          // Create a new interval with the updated taming\n          detectionIntervals[streamName] = setInterval(pollDetections, currentInterval);\n        }\n      });\n  };\n  \n  // Start the polling interval\n  const intervalId = setInterval(pollDetections, currentInterval);\n  \n  // Store interval ID for cleanup\n  detectionIntervals[streamName] = intervalId;\n  canvasOverlay.detectionInterval = intervalId;\n  \n  return intervalId;\n}\n\n/**\n * Clean up detection polling\n * @param {string} streamName - Name of the stream\n * @param {Object} detectionIntervals - Reference to stored interval IDs\n */\nexport function cleanupDetectionPolling(streamName, detectionIntervals) {\n  const canvasId = `canvas-${streamName.replace(/\\s+/g, '-')}`;\n  const canvasOverlay = document.getElementById(canvasId);\n  \n  if (canvasOverlay && canvasOverlay.detectionInterval) {\n    clearInterval(canvasOverlay.detectionInterval);\n    delete canvasOverlay.detectionInterval;\n  }\n  \n  if (detectionIntervals[streamName]) {\n    clearInterval(detectionIntervals[streamName]);\n    delete detectionIntervals[streamName];\n  }\n}\n\n/**\n * Draw detections on canvas overlay\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {HTMLVideoElement} videoElement - Video element\n * @param {Array} detections - Array of detection objects\n */\nexport function drawDetections(canvas, videoElement, detections) {\n  if (!canvas || !videoElement || !detections || !detections.length) return;\n  \n  const ctx = canvas.getContext('2d');\n  if (!ctx) return;\n  \n  // Clear previous drawings\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  \n  // Get video dimensions\n  const videoWidth = videoElement.videoWidth;\n  const videoHeight = videoElement.videoHeight;\n  \n  if (videoWidth === 0 || videoHeight === 0) return;\n  \n  // Ensure canvas dimensions match video container dimensions\n  if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {\n    canvas.width = canvas.offsetWidth;\n    canvas.height = canvas.offsetHeight;\n  }\n  \n  // For object-fit: cover, we need to calculate the visible portion of the video\n  const videoAspect = videoWidth / videoHeight;\n  const canvasAspect = canvas.width / canvas.height;\n  \n  let scale, offsetX = 0, offsetY = 0;\n  \n  if (videoAspect > canvasAspect) {\n    // Video is wider than canvas - some width is cropped\n    scale = canvas.height / videoHeight;\n    offsetX = (videoWidth * scale - canvas.width) / 2;\n  } else {\n    // Video is taller than canvas - some height is cropped\n    scale = canvas.width / videoWidth;\n    offsetY = (videoHeight * scale - canvas.height) / 2;\n  }\n  \n  // Draw each detection\n  detections.forEach(detection => {\n    // Convert normalized coordinates to canvas coordinates\n    const x = (detection.x * videoWidth * scale) - offsetX;\n    const y = (detection.y * videoHeight * scale) - offsetY;\n    const width = detection.width * videoWidth * scale;\n    const height = detection.height * videoHeight * scale;\n    \n    // Draw bounding box\n    ctx.strokeStyle = detection.color || '#00FF00';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(x, y, width, height);\n    \n    // Draw label background\n    ctx.fillStyle = detection.color || '#00FF00';\n    const label = `${detection.class} ${Math.round(detection.confidence * 100)}%`;\n    const textWidth = ctx.measureText(label).width + 10;\n    ctx.fillRect(x, y - 20, textWidth, 20);\n    \n    // Draw label text\n    ctx.fillStyle = '#000000';\n    ctx.font = '12px Arial';\n    ctx.fillText(label, x + 5, y - 5);\n  });\n}\n\n/**\n * Handle fullscreen change events for detection overlay\n * @param {Event} event - Fullscreen change event\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n */\nexport function handleFullscreenChange(event, canvasOverlay, videoElement) {\n  if (document.fullscreenElement) {\n    // When entering fullscreen, resize the canvas to match the fullscreen dimensions\n    setTimeout(() => {\n      if (canvasOverlay && videoElement) {\n        canvasOverlay.width = videoElement.clientWidth;\n        canvasOverlay.height = videoElement.clientHeight;\n        \n        // Ensure the canvas is positioned correctly in fullscreen\n        canvasOverlay.style.position = 'absolute';\n        canvasOverlay.style.top = '0';\n        canvasOverlay.style.left = '0';\n        canvasOverlay.style.width = '100%';\n        canvasOverlay.style.height = '100%';\n        canvasOverlay.style.zIndex = '10'; // Ensure it's above the video but below controls\n      }\n    }, 100); // Small delay to allow fullscreen to complete\n  } else {\n    // When exiting fullscreen, reset the canvas dimensions\n    setTimeout(() => {\n      if (canvasOverlay && videoElement) {\n        canvasOverlay.width = videoElement.clientWidth;\n        canvasOverlay.height = videoElement.clientHeight;\n      }\n    }, 100);\n  }\n}\n\n/**\n * Ensure controls are visible above the detection overlay\n * @param {string} streamName - Name of the stream\n */\nexport function ensureControlsVisibility(streamName) {\n  const streamId = streamName.replace(/\\s+/g, '-');\n  const videoCell = document.querySelector(`.video-cell[data-stream=\"${streamId}\"]`);\n  \n  if (!videoCell) return;\n  \n  // Find all controls within this cell\n  const controls = videoCell.querySelector('.stream-controls');\n  if (controls) {\n    // Ensure controls are above the canvas overlay\n    controls.style.position = 'relative';\n    controls.style.zIndex = '30'; // Higher than the canvas overlay\n    controls.style.pointerEvents = 'auto'; // Ensure clicks are registered\n    \n    // Remove any fullscreen button as it's redundant\n    const fullscreenBtn = controls.querySelector('.fullscreen-btn');\n    if (fullscreenBtn) {\n      fullscreenBtn.remove();\n    }\n  }\n  \n  // Find and fix snapshot button specifically\n  const snapshotBtn = videoCell.querySelector('.snapshot-btn');\n  if (snapshotBtn) {\n    snapshotBtn.style.position = 'relative';\n    snapshotBtn.style.zIndex = '30';\n    snapshotBtn.style.pointerEvents = 'auto';\n  }\n  \n  // Find and fix all buttons in the video cell\n  const allButtons = videoCell.querySelectorAll('button');\n  allButtons.forEach(button => {\n    button.style.position = 'relative';\n    button.style.zIndex = '30';\n    button.style.pointerEvents = 'auto';\n  });\n  \n  // Make sure the video element itself doesn't block clicks\n  const video = videoCell.querySelector('video');\n  if (video) {\n    video.style.pointerEvents = 'none';\n  }\n}\n\n/**\n * Initialize detection overlay for a stream\n * @param {string} streamName - Name of the stream\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n * @param {Object} detectionIntervals - Reference to store interval IDs\n */\nexport function initializeDetectionOverlay(streamName, canvasOverlay, videoElement, detectionIntervals) {\n  // Ensure the canvas is properly positioned\n  canvasOverlay.style.position = 'absolute';\n  canvasOverlay.style.top = '0';\n  canvasOverlay.style.left = '0';\n  canvasOverlay.style.width = '100%';\n  canvasOverlay.style.height = '100%';\n  canvasOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through\n  canvasOverlay.style.zIndex = '5'; // Above video but below controls\n  \n  // Find the parent container and ensure proper stacking context\n  const parentContainer = canvasOverlay.parentElement;\n  if (parentContainer) {\n    parentContainer.style.position = 'relative'; // Create stacking context\n  }\n  \n  // Ensure controls are visible\n  ensureControlsVisibility(streamName);\n  \n  // Add fullscreen change listener\n  document.addEventListener('fullscreenchange', (event) => {\n    handleFullscreenChange(event, canvasOverlay, videoElement);\n    \n    // Re-ensure controls visibility after fullscreen change\n    setTimeout(() => ensureControlsVisibility(streamName), 200);\n  });\n  \n  // Start detection polling\n  return startDetectionPolling(streamName, canvasOverlay, videoElement, detectionIntervals);\n}\n\n/**\n * Add snapshot functionality to detection overlay\n * @param {string} streamName - Name of the stream\n * @param {HTMLCanvasElement} canvasOverlay - Canvas element for drawing detection boxes\n * @param {HTMLVideoElement} videoElement - Video element\n */\nexport function addSnapshotWithDetections(streamName, canvasOverlay, videoElement) {\n  const streamId = streamName.replace(/\\s+/g, '-');\n  const videoCell = document.querySelector(`.video-cell[data-stream=\"${streamId}\"]`);\n  \n  if (!videoCell) return;\n  \n  // Find the snapshot button\n  const snapshotBtn = videoCell.querySelector(`.snapshot-btn[data-id=\"${streamId}\"]`);\n  if (!snapshotBtn) return;\n  \n  // Create a wrapper for the original click handler\n  const originalOnClick = snapshotBtn.onclick;\n  \n  // Replace with our enhanced version that includes detections\n  snapshotBtn.onclick = function(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    \n    // Create a combined canvas with video and detections\n    const combinedCanvas = document.createElement('canvas');\n    combinedCanvas.width = videoElement.videoWidth;\n    combinedCanvas.height = videoElement.videoHeight;\n    const ctx = combinedCanvas.getContext('2d');\n    \n    // Draw the video frame\n    ctx.drawImage(videoElement, 0, 0, combinedCanvas.width, combinedCanvas.height);\n    \n    // Draw the detections from the overlay canvas\n    if (canvasOverlay.width > 0 && canvasOverlay.height > 0) {\n      ctx.drawImage(canvasOverlay, 0, 0, canvasOverlay.width, canvasOverlay.height, \n                   0, 0, combinedCanvas.width, combinedCanvas.height);\n    }\n    \n    // Store the canvas for the snapshot functionality\n    window.__snapshotCanvas = combinedCanvas;\n    \n    // Generate a filename\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = `snapshot-${streamName.replace(/\\s+/g, '-')}-${timestamp}.jpg`;\n    window.__snapshotFileName = fileName;\n    \n    // Show the standard preview\n    const dataUrl = combinedCanvas.toDataURL('image/jpeg', 0.95);\n    showSnapshotPreview(dataUrl, `Snapshot: ${streamName}`);\n    \n    // Call the original handler if it exists\n    if (typeof originalOnClick === 'function') {\n      originalOnClick.call(this, event);\n    }\n    \n    return false;\n  };\n  \n  // Make sure the button is visible\n  snapshotBtn.style.position = 'relative';\n  snapshotBtn.style.zIndex = '30';\n  snapshotBtn.style.pointerEvents = 'auto';\n  \n  console.log('Enhanced snapshot button with detection overlay capability');\n}\n"],"names":["exitFullscreenMode","setIsFullscreen","livePage","exitBtn","fullscreenBtn","toggleFullscreen","isFullscreen","isCurrentlyInFullscreen","exitClickHandler","e","escapeHandler","toggleStreamFullscreen","streamName","videoElementId","videoElement","videoCell","err","showStatusMessage","startDetectionPolling","canvasOverlay","detectionIntervals","drawDetectionBoxes","detections","canvas","ctx","videoWidth","videoHeight","videoAspect","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","detection","x","y","width","height","label","textWidth","errorCount","currentInterval","pollDetections","response","data","error","intervalId","cleanupDetectionPolling","canvasId"],"mappings":"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"}