{"version":3,"file":"index-legacy-BwpXE2Xo.js","sources":["../../js/components/preact/WebRTCVideoCell.jsx","../../js/components/preact/WebRTCView.jsx","../../js/pages/index-page.jsx"],"sourcesContent":["/**\n * WebRTCVideoCell Component\n * A self-contained component for displaying a WebRTC video stream\n */\n\nimport { h } from 'preact';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { DetectionOverlay, takeSnapshotWithDetections } from './DetectionOverlay.jsx';\nimport { SnapshotButton } from './SnapshotManager.jsx';\nimport { LoadingIndicator } from './LoadingIndicator.jsx';\nimport { showSnapshotPreview } from './UI.jsx';\n\n/**\n * WebRTCVideoCell component\n * @param {Object} props - Component props\n * @param {Object} props.stream - Stream object\n * @param {Function} props.onToggleFullscreen - Fullscreen toggle handler\n * @param {string} props.streamId - Stream ID for stable reference\n * @returns {JSX.Element} WebRTCVideoCell component\n */\nexport function WebRTCVideoCell({\n  stream,\n  streamId,\n  onToggleFullscreen\n}) {\n  // Component state\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [connectionQuality, setConnectionQuality] = useState('unknown'); // 'unknown', 'good', 'poor', 'bad'\n\n  // Refs\n  const videoRef = useRef(null);\n  const cellRef = useRef(null);\n  const peerConnectionRef = useRef(null);\n  const detectionOverlayRef = useRef(null);\n  const abortControllerRef = useRef(null);\n  const connectionMonitorRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n\n  // Initialize WebRTC connection when component mounts\n  useEffect(() => {\n    if (!stream || !stream.name || !videoRef.current) return;\n\n    console.log(`Initializing WebRTC connection for stream ${stream.name}`);\n    setIsLoading(true);\n    setError(null);\n\n    // Create a new RTCPeerConnection\n    const pc = new RTCPeerConnection({\n      iceTransports: 'all',\n      bundlePolicy: 'balanced',\n      rtcpCnameCpn: 'LightNVR',\n      rtcpCnameRtp: 'LightNVR',\n      iceCandidatePoolSize: 0,\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' }\n      ]\n    });\n\n    peerConnectionRef.current = pc;\n\n    // Set up event handlers\n    pc.ontrack = (event) => {\n      console.log(`Track received for stream ${stream.name}`);\n      \n      if (event.track.kind === 'video') {\n        const videoElement = videoRef.current;\n        if (!videoElement) return;\n\n        // Set srcObject\n        videoElement.srcObject = event.streams[0];\n        \n        // Add event handlers\n        videoElement.onloadeddata = () => {\n          console.log(`Video data loaded for stream ${stream.name}`);\n        };\n\n        videoElement.onplaying = () => {\n          console.log(`Video playing for stream ${stream.name}`);\n          setIsLoading(false);\n          setIsPlaying(true);\n        };\n        \n        // Add timeouts to force-check video playback at different intervals\n        setTimeout(() => {\n          if (videoElement && !isPlaying) {\n            console.log(`Force-checking playback for stream ${stream.name} (attempt 1)`);\n            try {\n              videoElement.play().catch(e => {\n                console.warn(`Force play attempt 1 failed for ${stream.name}:`, e);\n              });\n            } catch (e) {\n              console.warn(`Error in force play attempt 1 for ${stream.name}:`, e);\n            }\n          }\n        }, 3000); // First check after 3 seconds\n\n        setTimeout(() => {\n          if (videoElement && !isPlaying) {\n            console.log(`Force-checking playback for stream ${stream.name} (attempt 2)`);\n            try {\n              // Try to restart the connection if still not playing\n              if (peerConnectionRef.current && peerConnectionRef.current.iceConnectionState === 'connected') {\n                console.log(`Connection is established but video not playing for ${stream.name}, forcing play`);\n                videoElement.play().catch(e => {\n                  console.warn(`Force play attempt 2 failed for ${stream.name}:`, e);\n                });\n              }\n            } catch (e) {\n              console.warn(`Error in force play attempt 2 for ${stream.name}:`, e);\n            }\n          } else if (isPlaying) {\n            console.log(`Video is now playing for stream ${stream.name}`);\n          }\n        }, 8000); // Second check after 8 seconds\n\n        videoElement.onerror = (e) => {\n          console.error(`Video error for stream ${stream.name}:`, e);\n          setError('Video playback error');\n          setIsLoading(false);\n        };\n      }\n    };\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        // Filter out empty candidates\n        if (event.candidate.candidate !== \"\") {\n          console.log(`ICE candidate for stream ${stream.name}`);\n          \n          // Only process candidates if we're not already connected\n          // This prevents issues with late-arriving candidates disrupting established connections\n          if (pc.iceConnectionState !== 'connected' && pc.iceConnectionState !== 'completed') {\n            // Process the candidate normally\n          } else {\n            console.log(`Ignoring late ICE candidate for stream ${stream.name} - connection already ${pc.iceConnectionState}`);\n          }\n        } else {\n          console.log(`Ignoring empty ICE candidate for stream ${stream.name}`);\n        }\n      }\n    };\n\n    pc.oniceconnectionstatechange = () => {\n      console.log(`ICE connection state for stream ${stream.name}: ${pc.iceConnectionState}`);\n      \n      if (pc.iceConnectionState === 'failed') {\n        console.error(`WebRTC ICE connection failed for stream ${stream.name}`);\n        setError('WebRTC ICE connection failed');\n        setIsLoading(false);\n      } else if (pc.iceConnectionState === 'disconnected') {\n        // Connection is temporarily disconnected, log but don't show error yet\n        console.warn(`WebRTC ICE connection disconnected for stream ${stream.name}, attempting to recover...`);\n        \n        // Set a timeout to check if the connection recovers on its own\n        setTimeout(() => {\n          if (peerConnectionRef.current && \n              (peerConnectionRef.current.iceConnectionState === 'disconnected' || \n               peerConnectionRef.current.iceConnectionState === 'failed')) {\n            console.error(`WebRTC ICE connection could not recover for stream ${stream.name}`);\n            setError('WebRTC connection lost. Please retry.');\n            setIsLoading(false);\n          } else if (peerConnectionRef.current) {\n            console.log(`WebRTC ICE connection recovered for stream ${stream.name}, current state: ${peerConnectionRef.current.iceConnectionState}`);\n          }\n        }, 5000); // Wait 5 seconds to see if connection recovers\n      } else if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {\n        // Connection is established or completed, clear any previous error\n        if (error) {\n          console.log(`WebRTC connection restored for stream ${stream.name}`);\n          setError(null);\n        }\n      }\n    };\n\n    // Add transceivers\n    pc.addTransceiver('video', {direction: 'recvonly'});\n    pc.addTransceiver('audio', {direction: 'recvonly'});\n\n    // Create and send offer\n    pc.createOffer()\n      .then(offer => pc.setLocalDescription(offer))\n      .then(() => {\n        // Create a new AbortController for this request\n        abortControllerRef.current = new AbortController();\n        \n        // Format the offer\n        const formattedOffer = {\n          type: pc.localDescription.type,\n          sdp: pc.localDescription.sdp\n        };\n\n        // Get auth token if available\n        const auth = localStorage.getItem('auth');\n\n        // Send the offer to the server\n        return fetch(`/api/webrtc?src=${encodeURIComponent(stream.name)}`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(auth ? { 'Authorization': 'Basic ' + auth } : {})\n          },\n          body: JSON.stringify(formattedOffer),\n          signal: abortControllerRef.current.signal\n        });\n      })\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`Failed to send offer: ${response.status} ${response.statusText}`);\n        }\n        return response.text();\n      })\n      .then(text => {\n        try {\n          return JSON.parse(text);\n        } catch (error) {\n          console.error(`Error parsing JSON for stream ${stream.name}:`, error);\n          throw new Error('Failed to parse WebRTC answer');\n        }\n      })\n      .then(answer => pc.setRemoteDescription(new RTCSessionDescription(answer)))\n      .catch(error => {\n        console.error(`Error setting up WebRTC for stream ${stream.name}:`, error);\n        setError(error.message || 'Failed to establish WebRTC connection');\n        setIsLoading(false);\n      });\n\n    // Set up connection quality monitoring\n    const startConnectionMonitoring = () => {\n      // Clear any existing monitor\n      if (connectionMonitorRef.current) {\n        clearInterval(connectionMonitorRef.current);\n      }\n      \n      // Start a new monitor\n      connectionMonitorRef.current = setInterval(() => {\n        if (!peerConnectionRef.current) return;\n        \n        // Get connection stats\n        peerConnectionRef.current.getStats().then(stats => {\n          let packetsLost = 0;\n          let packetsReceived = 0;\n          let currentRtt = 0;\n          let jitter = 0;\n          \n          stats.forEach(report => {\n            if (report.type === 'inbound-rtp' && report.kind === 'video') {\n              packetsLost = report.packetsLost || 0;\n              packetsReceived = report.packetsReceived || 0;\n              jitter = report.jitter || 0;\n            }\n            \n            if (report.type === 'candidate-pair' && report.state === 'succeeded') {\n              currentRtt = report.currentRoundTripTime || 0;\n            }\n          });\n          \n          // Calculate packet loss percentage\n          const totalPackets = packetsReceived + packetsLost;\n          const lossPercentage = totalPackets > 0 ? (packetsLost / totalPackets) * 100 : 0;\n          \n          // Determine connection quality\n          let quality = 'unknown';\n          \n          if (packetsReceived > 0) {\n            if (lossPercentage < 2 && currentRtt < 0.1 && jitter < 0.03) {\n              quality = 'good';\n            } else if (lossPercentage < 5 && currentRtt < 0.3 && jitter < 0.1) {\n              quality = 'fair';\n            } else if (lossPercentage < 15 && currentRtt < 1) {\n              quality = 'poor';\n            } else {\n              quality = 'bad';\n            }\n          }\n          \n          // Update connection quality state if changed\n          if (quality !== connectionQuality) {\n            console.log(`WebRTC connection quality for stream ${stream.name} changed to ${quality}`);\n            console.log(`Stats: loss=${lossPercentage.toFixed(2)}%, rtt=${(currentRtt * 1000).toFixed(0)}ms, jitter=${(jitter * 1000).toFixed(0)}ms`);\n            setConnectionQuality(quality);\n            \n            // If connection quality is poor or bad for the \"parking\" stream, which has shown issues\n            if ((quality === 'poor' || quality === 'bad') && stream.name === 'parking') {\n              console.warn(`Poor connection quality detected for problematic stream ${stream.name}, may need intervention`);\n              \n              // If we're in a bad state and the connection is still technically \"connected\"\n              // but video isn't flowing properly, we might need to force a reconnection\n              if (peerConnectionRef.current && \n                  peerConnectionRef.current.iceConnectionState === 'connected' && \n                  !isPlaying && \n                  reconnectAttemptsRef.current < 3) {\n                \n                console.log(`Attempting to recover stream ${stream.name} (attempt ${reconnectAttemptsRef.current + 1})`);\n                reconnectAttemptsRef.current++;\n                \n                // Force a reconnection\n                handleRetry();\n              }\n            }\n          }\n        }).catch(err => {\n          console.warn(`Error getting WebRTC stats for stream ${stream.name}:`, err);\n        });\n      }, 10000); // Check every 10 seconds\n    };\n    \n    // Start monitoring once we have a connection\n    if (peerConnectionRef.current && peerConnectionRef.current.iceConnectionState === 'connected') {\n      startConnectionMonitoring();\n    }\n    \n    // Listen for connection state changes to start/stop monitoring\n    const originalOnIceConnectionStateChange = pc.oniceconnectionstatechange;\n    pc.oniceconnectionstatechange = () => {\n      // Call the original handler\n      if (originalOnIceConnectionStateChange) {\n        originalOnIceConnectionStateChange();\n      }\n      \n      // Start monitoring when connected\n      if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {\n        startConnectionMonitoring();\n        // Reset reconnect attempts counter when we get a good connection\n        reconnectAttemptsRef.current = 0;\n      }\n      \n      // Stop monitoring when disconnected or failed\n      if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'closed') {\n        if (connectionMonitorRef.current) {\n          clearInterval(connectionMonitorRef.current);\n          connectionMonitorRef.current = null;\n        }\n      }\n    };\n\n    // Cleanup function\n    return () => {\n      console.log(`Cleaning up WebRTC connection for stream ${stream.name}`);\n      \n      // Stop connection monitoring\n      if (connectionMonitorRef.current) {\n        clearInterval(connectionMonitorRef.current);\n        connectionMonitorRef.current = null;\n      }\n      \n      // Abort any pending fetch requests\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n        abortControllerRef.current = null;\n      }\n      \n      // Clean up video element\n      if (videoRef.current && videoRef.current.srcObject) {\n        const tracks = videoRef.current.srcObject.getTracks();\n        tracks.forEach(track => track.stop());\n        videoRef.current.srcObject = null;\n      }\n      \n      // Close peer connection\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n        peerConnectionRef.current = null;\n      }\n    };\n  }, [stream]);\n\n  // Handle retry button click\n  const handleRetry = () => {\n    // Force a re-render to restart the WebRTC connection\n    setError(null);\n    setIsLoading(true);\n    \n    // Clean up existing connection\n    if (peerConnectionRef.current) {\n      peerConnectionRef.current.close();\n      peerConnectionRef.current = null;\n    }\n    \n    if (videoRef.current && videoRef.current.srcObject) {\n      const tracks = videoRef.current.srcObject.getTracks();\n      tracks.forEach(track => track.stop());\n      videoRef.current.srcObject = null;\n    }\n    \n    // Force a re-render by updating state\n    setIsPlaying(false);\n  };\n\n  return (\n    <div\n      className=\"video-cell\"\n      data-stream-name={stream.name}\n      data-stream-id={streamId}\n      ref={cellRef}\n      style={{\n        position: 'relative',\n        pointerEvents: 'auto',\n        zIndex: 1\n      }}\n    >\n      {/* Video element */}\n      <video\n        id={`video-${streamId.replace(/\\s+/g, '-')}`}\n        className=\"video-element\"\n        ref={videoRef}\n        playsInline\n        autoPlay\n        muted\n        disablePictureInPicture\n        style={{ width: '100%', height: '100%', objectFit: 'contain' }}\n      />\n\n      {/* Detection overlay component */}\n      {stream.detection_based_recording && stream.detection_model && (\n        <DetectionOverlay\n          ref={detectionOverlayRef}\n          streamName={stream.name}\n          videoRef={videoRef}\n          enabled={isPlaying}\n          detectionModel={stream.detection_model}\n        />\n      )}\n\n      {/* Stream name overlay with connection quality indicator */}\n      <div\n        className=\"stream-name-overlay\"\n        style={{\n          position: 'absolute',\n          top: '10px',\n          left: '10px',\n          padding: '5px 10px',\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n          color: 'white',\n          borderRadius: '4px',\n          fontSize: '14px',\n          zIndex: 3,\n          display: 'flex',\n          alignItems: 'center',\n          gap: '8px'\n        }}\n      >\n        {stream.name}\n        \n        {/* Connection quality indicator - only show when we have quality data and stream is playing */}\n        {isPlaying && connectionQuality !== 'unknown' && (\n          <div \n            className={`connection-quality-indicator quality-${connectionQuality}`}\n            title={`Connection Quality: ${connectionQuality.charAt(0).toUpperCase() + connectionQuality.slice(1)}`}\n            style={{\n              width: '10px',\n              height: '10px',\n              borderRadius: '50%',\n              backgroundColor: \n                connectionQuality === 'good' ? '#10B981' :  // Green\n                connectionQuality === 'fair' ? '#FBBF24' :  // Yellow\n                connectionQuality === 'poor' ? '#F97316' :  // Orange\n                connectionQuality === 'bad' ? '#EF4444' :   // Red\n                '#6B7280',                                  // Gray (unknown)\n              boxShadow: '0 0 4px rgba(0, 0, 0, 0.3)'\n            }}\n          />\n        )}\n      </div>\n\n      {/* Stream controls */}\n      <div\n        className=\"stream-controls\"\n        style={{\n          position: 'absolute',\n          bottom: '10px',\n          right: '10px',\n          display: 'flex',\n          gap: '10px',\n          zIndex: 5,\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n          padding: '5px',\n          borderRadius: '4px'\n        }}\n      >\n        <div\n          style={{\n            backgroundColor: 'transparent',\n            padding: '5px',\n            borderRadius: '4px'\n          }}\n          onMouseOver={(e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'}\n          onMouseOut={(e) => e.currentTarget.style.backgroundColor = 'transparent'}\n        >\n          <SnapshotButton\n            streamId={streamId}\n            streamName={stream.name}\n            onSnapshot={() => {\n              if (videoRef.current) {\n                let canvasRef = null;\n\n                // Try to get canvas ref from detection overlay if available\n                if (detectionOverlayRef.current && typeof detectionOverlayRef.current.getCanvasRef === 'function') {\n                  canvasRef = detectionOverlayRef.current.getCanvasRef();\n                }\n\n                // Take snapshot with or without detections\n                if (canvasRef) {\n                  const snapshot = takeSnapshotWithDetections(videoRef, canvasRef, stream.name);\n                  if (snapshot) {\n                    showSnapshotPreview(snapshot.canvas.toDataURL('image/jpeg', 0.95), `Snapshot: ${stream.name}`);\n                  }\n                } else {\n                  // Take a simple snapshot without detections\n                  const videoElement = videoRef.current;\n                  const canvas = document.createElement('canvas');\n                  canvas.width = videoElement.videoWidth;\n                  canvas.height = videoElement.videoHeight;\n\n                  if (canvas.width > 0 && canvas.height > 0) {\n                    const ctx = canvas.getContext('2d');\n                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);\n\n                    showSnapshotPreview(canvas.toDataURL('image/jpeg', 0.95), `Snapshot: ${stream.name}`);\n                  }\n                }\n              }\n            }}\n          />\n        </div>\n        <button\n          className=\"fullscreen-btn\"\n          title=\"Toggle Fullscreen\"\n          data-id={streamId}\n          data-name={stream.name}\n          onClick={(e) => onToggleFullscreen(stream.name, e, cellRef.current)}\n          style={{\n            backgroundColor: 'transparent',\n            border: 'none',\n            padding: '5px',\n            borderRadius: '4px',\n            color: 'white',\n            cursor: 'pointer'\n          }}\n          onMouseOver={(e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'}\n          onMouseOut={(e) => e.currentTarget.style.backgroundColor = 'transparent'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path></svg>\n        </button>\n      </div>\n\n      {/* Loading indicator */}\n      {isLoading && (\n        <div style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, zIndex: 5, pointerEvents: 'none' }}>\n          <LoadingIndicator message=\"Connecting...\" />\n        </div>\n      )}\n\n      {/* Error indicator */}\n      {error && (\n        <div\n          className=\"error-indicator\"\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            width: '100%',\n            height: '100%',\n            display: 'flex',\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            backgroundColor: 'rgba(0, 0, 0, 0.7)',\n            color: 'white',\n            zIndex: 5,\n            textAlign: 'center'\n          }}\n        >\n          <div\n            className=\"error-content\"\n            style={{\n              display: 'flex',\n              flexDirection: 'column',\n              justifyContent: 'center',\n              alignItems: 'center',\n              width: '80%',\n              maxWidth: '300px',\n              padding: '20px',\n              borderRadius: '8px',\n              backgroundColor: 'rgba(0, 0, 0, 0.5)'\n            }}\n          >\n            <div\n              className=\"error-icon\"\n              style={{\n                fontSize: '28px',\n                marginBottom: '15px',\n                fontWeight: 'bold',\n                width: '40px',\n                height: '40px',\n                lineHeight: '40px',\n                borderRadius: '50%',\n                backgroundColor: 'rgba(220, 38, 38, 0.8)',\n                textAlign: 'center'\n              }}\n            >\n              !\n            </div>\n            <p style={{\n              marginBottom: '20px',\n              textAlign: 'center',\n              width: '100%',\n              fontSize: '14px',\n              lineHeight: '1.4'\n            }}>\n              {error}\n            </p>\n            <button\n              className=\"retry-button\"\n              onClick={handleRetry}\n              style={{\n                padding: '8px 20px',\n                backgroundColor: '#2563eb',\n                color: 'white',\n                borderRadius: '4px',\n                border: 'none',\n                cursor: 'pointer',\n                fontWeight: 'bold',\n                fontSize: '14px',\n                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',\n                transition: 'background-color 0.2s ease'\n              }}\n              onMouseOver={(e) => e.currentTarget.style.backgroundColor = '#1d4ed8'}\n              onMouseOut={(e) => e.currentTarget.style.backgroundColor = '#2563eb'}\n            >\n              Retry\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n","/**\n * LightNVR Web Interface WebRTCView Component\n * Preact component for the WebRTC view page\n */\n\nimport { useState, useEffect, useRef, useCallback, useMemo } from 'preact/hooks';\nimport { setupModals, addModalStyles } from './UI.jsx';\nimport { showStatusMessage } from './ToastContainer.jsx';\nimport { useFullscreenManager, FullscreenManager } from './FullscreenManager.jsx';\nimport { useQuery, useQueryClient } from '../../query-client.js';\nimport { WebRTCVideoCell } from './WebRTCVideoCell.jsx';\nimport { SnapshotManager, useSnapshotManager } from './SnapshotManager.jsx';\n\n/**\n * WebRTCView component\n * @returns {JSX.Element} WebRTCView component\n */\nexport function WebRTCView() {\n  // Use the snapshot manager hook\n  const { takeSnapshot } = useSnapshotManager();\n\n  // Use the fullscreen manager hook\n  const { isFullscreen, setIsFullscreen, toggleFullscreen } = useFullscreenManager();\n\n  // State for streams and layout\n  const [streams, setStreams] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Initialize layout from URL or sessionStorage if available\n  const [layout, setLayout] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const layoutParam = urlParams.get('layout');\n    if (layoutParam) {\n      return layoutParam;\n    }\n    // Check sessionStorage as a backup\n    const storedLayout = sessionStorage.getItem('webrtc_layout');\n    return storedLayout || '4';\n  });\n\n  // Initialize selectedStream from URL or sessionStorage if available\n  const [selectedStream, setSelectedStream] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const streamParam = urlParams.get('stream');\n    if (streamParam) {\n      return streamParam;\n    }\n    // Check sessionStorage as a backup\n    const storedStream = sessionStorage.getItem('webrtc_selected_stream');\n    return storedStream || '';\n  });\n\n  // Initialize currentPage from URL or sessionStorage if available (URL uses 1-based indexing, internal state uses 0-based)\n  const [currentPage, setCurrentPage] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const pageParam = urlParams.get('page');\n    if (pageParam) {\n      // Convert from 1-based (URL) to 0-based (internal)\n      return Math.max(0, parseInt(pageParam, 10) - 1);\n    }\n    // Check sessionStorage as a backup\n    const storedPage = sessionStorage.getItem('webrtc_current_page');\n    if (storedPage) {\n      // Convert from 1-based (stored) to 0-based (internal)\n      return Math.max(0, parseInt(storedPage, 10) - 1);\n    }\n    return 0;\n  });\n\n  // Get query client for fetching and invalidating queries\n  const queryClient = useQueryClient();\n\n  // Set up event listeners and UI components\n  useEffect(() => {\n    // Set up modals for snapshot preview\n    setupModals();\n    addModalStyles();\n  }, []);\n\n  // Fetch streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery(\n    'streams',\n    '/api/streams',\n    {\n      timeout: 15000, // 15 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    }\n  );\n\n  // Update loading state based on streams query status\n  useEffect(() => {\n    setIsLoading(isLoadingStreams);\n  }, [isLoadingStreams]);\n\n  // Process streams data when it's loaded\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData)) {\n      // Process the streams data\n      const processStreams = async () => {\n        try {\n          // Filter and process the streams\n          const filteredStreams = await filterStreamsForWebRTC(streamsData);\n\n          if (filteredStreams.length > 0) {\n            setStreams(filteredStreams);\n\n            // Set selectedStream based on URL parameter if it exists and is valid\n            const urlParams = new URLSearchParams(window.location.search);\n            const streamParam = urlParams.get('stream');\n\n            if (streamParam && filteredStreams.some(stream => stream.name === streamParam)) {\n              // If the stream from URL exists in the loaded streams, use it\n              setSelectedStream(streamParam);\n            } else if (!selectedStream || !filteredStreams.some(stream => stream.name === selectedStream)) {\n              // Otherwise use the first stream if selectedStream is not set or invalid\n              setSelectedStream(filteredStreams[0].name);\n            }\n          } else {\n            console.warn('No streams available for WebRTC view after filtering');\n          }\n        } catch (error) {\n          console.error('Error processing streams:', error);\n          showStatusMessage('Error processing streams: ' + error.message);\n        }\n      };\n\n      processStreams();\n    }\n  }, [streamsData, selectedStream]);\n\n  // Update URL when layout, page, or selectedStream changes\n  useEffect(() => {\n    // Don't update URL during initial load or when streams are empty\n    if (streams.length === 0) return;\n\n    console.log('Updating URL parameters');\n    const url = new URL(window.location);\n\n    // Handle page parameter (convert from 0-based internal to 1-based URL)\n    if (currentPage === 0) {\n      url.searchParams.delete('page');\n    } else {\n      // Add 1 to convert from 0-based (internal) to 1-based (URL)\n      url.searchParams.set('page', currentPage + 1);\n    }\n\n    // Handle layout parameter\n    if (layout !== '4') { // Only set if not the default\n      url.searchParams.set('layout', layout);\n    } else {\n      // Remove layout parameter if it's the default value\n      url.searchParams.delete('layout');\n    }\n\n    // Handle selectedStream parameter\n    if (layout === '1' && selectedStream) {\n      url.searchParams.set('stream', selectedStream);\n    } else {\n      // Remove stream parameter if not in single stream mode\n      url.searchParams.delete('stream');\n    }\n\n    // Update URL without reloading the page\n    window.history.replaceState({}, '', url);\n\n    // Also update sessionStorage\n    if (currentPage > 0) {\n      sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n    } else {\n      sessionStorage.removeItem('webrtc_current_page');\n    }\n\n    if (layout !== '4') {\n      sessionStorage.setItem('webrtc_layout', layout);\n    } else {\n      sessionStorage.removeItem('webrtc_layout');\n    }\n\n    if (layout === '1' && selectedStream) {\n      sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n    } else {\n      sessionStorage.removeItem('webrtc_selected_stream');\n    }\n  }, [currentPage, layout, selectedStream, streams.length]);\n\n  /**\n   * Filter streams for WebRTC view\n   * @param {Array} streams - Array of streams\n   * @returns {Promise<Array>} Promise resolving to filtered array of streams\n   */\n  const filterStreamsForWebRTC = async (streams) => {\n    try {\n      if (!streams || !Array.isArray(streams)) {\n        console.warn('No streams data provided to filter');\n        return [];\n      }\n\n      // For WebRTC view, we need to fetch full details for each stream\n      const streamPromises = streams.map(async (stream) => {\n        try {\n          const streamId = stream.id || stream.name;\n\n          const streamDetails = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamId],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamId)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to load details for stream ${stream.name}`);\n              }\n              return response.json();\n            },\n            staleTime: 30000 // 30 seconds\n          });\n\n          return streamDetails;\n        } catch (error) {\n          console.error(`Error loading details for stream ${stream.name}:`, error);\n          // Return the basic stream info if we can't get details\n          return stream;\n        }\n      });\n\n      const detailedStreams = await Promise.all(streamPromises);\n      console.log('Loaded detailed streams for WebRTC view:', detailedStreams);\n\n      // Filter out streams that are soft deleted, inactive, or not configured for streaming\n      const filteredStreams = detailedStreams.filter(stream => {\n        // Filter out soft deleted streams\n        if (stream.is_deleted) {\n          console.log(`Stream ${stream.name} is soft deleted, filtering out`);\n          return false;\n        }\n\n        // Filter out inactive streams\n        if (!stream.enabled) {\n          console.log(`Stream ${stream.name} is inactive, filtering out`);\n          return false;\n        }\n\n        // Filter out streams not configured for streaming\n        if (!stream.streaming_enabled) {\n          console.log(`Stream ${stream.name} is not configured for streaming, filtering out`);\n          return false;\n        }\n\n        return true;\n      });\n\n      console.log('Filtered streams for WebRTC view:', filteredStreams);\n\n      return filteredStreams || [];\n    } catch (error) {\n      console.error('Error filtering streams for WebRTC view:', error);\n      showStatusMessage('Error processing streams: ' + error.message);\n      return [];\n    }\n  };\n\n  /**\n   * Get maximum number of streams to display based on layout\n   * @returns {number} Maximum number of streams\n   */\n  const getMaxStreamsForLayout = useCallback(() => {\n    switch (layout) {\n      case '1': return 1;  // Single view\n      case '2': return 2;  // 2x1 grid\n      case '4': return 4;  // 2x2 grid\n      case '6': return 6;  // 2x3 grid\n      case '9': return 9;  // 3x3 grid\n      case '16': return 16; // 4x4 grid\n      default: return 4;\n    }\n  }, [layout]);\n\n  /**\n   * Get streams to show based on layout, selected stream, and pagination\n   * @returns {Array} Streams to show\n   */\n  const getStreamsToShow = useCallback(() => {\n    // Filter streams based on layout and selected stream\n    let streamsToShow = streams;\n\n    if (layout === '1' && selectedStream) {\n      streamsToShow = streams.filter(stream => stream.name === selectedStream);\n    } else {\n      // Apply pagination\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      // Ensure current page is valid\n      if (currentPage >= totalPages && totalPages > 0) {\n        return []; // Will be handled by the effect that watches currentPage\n      }\n\n      // Get streams for current page\n      const startIdx = currentPage * maxStreams;\n      const endIdx = Math.min(startIdx + maxStreams, streams.length);\n      streamsToShow = streams.slice(startIdx, endIdx);\n    }\n\n    return streamsToShow;\n  }, [streams, layout, selectedStream, currentPage]);\n\n  // Ensure current page is valid when streams or layout changes\n  useEffect(() => {\n    if (streams.length === 0) return;\n\n    const maxStreams = getMaxStreamsForLayout();\n    const totalPages = Math.ceil(streams.length / maxStreams);\n\n    if (currentPage >= totalPages) {\n      setCurrentPage(Math.max(0, totalPages - 1));\n    }\n  }, [streams, layout, currentPage, getMaxStreamsForLayout]);\n\n  /**\n   * Toggle fullscreen mode for a specific stream\n   * @param {string} streamName - Stream name\n   * @param {Event} event - Click event\n   * @param {HTMLElement} cellElement - The video cell element\n   */\n  const toggleStreamFullscreen = (streamName, event, cellElement) => {\n    // Prevent default button behavior\n    if (event) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (!streamName) {\n      console.error('Stream name not provided for fullscreen toggle');\n      return;\n    }\n\n    console.log(`Toggling fullscreen for stream: ${streamName}`);\n\n    if (!cellElement) {\n      console.error('Video cell element not provided for fullscreen toggle');\n      return;\n    }\n\n    if (!document.fullscreenElement) {\n      console.log('Entering fullscreen mode for video cell');\n      cellElement.requestFullscreen().catch(err => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n      });\n    } else {\n      console.log('Exiting fullscreen mode');\n      document.exitFullscreen();\n    }\n  };\n\n  // Memoize the streams to show to prevent unnecessary re-renders\n  const streamsToShow = useMemo(() => getStreamsToShow(), [streams, layout, selectedStream, currentPage, getMaxStreamsForLayout]);\n\n  return (\n    <section\n      id=\"live-page\"\n      className={`page ${isFullscreen ? 'fullscreen-mode' : ''}`}\n    >\n      {/* Include the SnapshotManager component */}\n      <SnapshotManager />\n\n      {/* Include the FullscreenManager component */}\n      <FullscreenManager\n        isFullscreen={isFullscreen}\n        setIsFullscreen={setIsFullscreen}\n        targetId=\"live-page\"\n      />\n\n      <div className=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\" style={{ position: 'relative', zIndex: 10, pointerEvents: 'auto' }}>\n        <div className=\"flex items-center space-x-2\">\n          <h2 className=\"text-xl font-bold mr-4\">Live View</h2>\n          <div className=\"flex space-x-2\">\n            <button\n              id=\"hls-toggle-btn\"\n              className=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 inline-block text-center\"\n              style={{ position: 'relative', zIndex: 50 }} // Very high z-index to ensure clickability\n              onClick={() => {\n                window.location.href = '/hls.html';\n              }}\n            >\n              HLS View\n            </button>\n          </div>\n        </div>\n        <div className=\"controls flex items-center space-x-2\">\n          <div className=\"flex items-center\">\n            <label htmlFor=\"layout-selector\" className=\"mr-2\">Layout:</label>\n            <select\n              id=\"layout-selector\"\n              className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n              value={layout}\n              onChange={(e) => {\n                const newLayout = e.target.value;\n                setLayout(newLayout);\n                setCurrentPage(0); // Reset to first page when layout changes\n              }}\n            >\n              <option value=\"1\">1 Stream</option>\n              <option value=\"2\">2 Streams</option>\n              <option value=\"4\">4 Streams</option>\n              <option value=\"6\">6 Streams</option>\n              <option value=\"9\">9 Streams</option>\n              <option value=\"16\">16 Streams</option>\n            </select>\n          </div>\n\n          {layout === '1' && (\n            <div className=\"flex items-center\">\n              <label htmlFor=\"stream-selector\" className=\"mr-2\">Stream:</label>\n              <select\n                id=\"stream-selector\"\n                className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                value={selectedStream}\n                onChange={(e) => {\n                  const newStream = e.target.value;\n                  setSelectedStream(newStream);\n                }}\n              >\n                {streams.map(stream => (\n                  <option key={stream.name} value={stream.name}>{stream.name}</option>\n                ))}\n              </select>\n            </div>\n          )}\n\n          <button\n            id=\"fullscreen-btn\"\n            className=\"p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 focus:outline-none\"\n            onClick={() => toggleFullscreen()}\n            title=\"Toggle Fullscreen\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\"\n                 stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n              <path\n                d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path>\n            </svg>\n          </button>\n        </div>\n      </div>\n\n      <div className=\"flex flex-col space-y-4 h-full\">\n        <div\n          id=\"video-grid\"\n          className={`video-container layout-${layout}`}\n        >\n          {isLoadingStreams ? (\n              <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\" style={{ pointerEvents: 'none', zIndex: 1 }}>\n                <div className=\"flex flex-col items-center justify-center py-8\">\n                <div\n                  className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (isLoading && !isLoadingStreams) ? (\n            <div\n                className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\"\n                style={{\n                  pointerEvents: 'none',\n                  position: 'relative',\n                  zIndex: 1\n                }}\n            >\n              <div className=\"flex flex-col items-center justify-center py-8\">\n                <div\n                  className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (streamsError) ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">Error loading streams: {streamsError.message}</p>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\"\n              >\n                Retry\n              </button>\n            </div>\n          ) : streams.length === 0 ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n              <a href=\"streams.html\" className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n            </div>\n          ) : (\n            // Render video cells using our self-contained WebRTCVideoCell component\n            streamsToShow.map(stream => (\n              <WebRTCVideoCell\n                key={stream.name}\n                stream={stream}\n                onToggleFullscreen={toggleStreamFullscreen}\n                streamId={stream.name} // Add explicit streamId prop to prevent re-renders\n              />\n            ))\n          )}\n        </div>\n\n        {layout !== '1' && streams.length > getMaxStreamsForLayout() ? (\n          <div className=\"pagination-controls flex justify-center items-center space-x-4 mt-4\">\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to previous page');\n                setCurrentPage(Math.max(0, currentPage - 1));\n              }}\n              disabled={currentPage === 0}\n            >\n              Previous\n            </button>\n\n            <span className=\"text-gray-700 dark:text-gray-300\">\n              Page {currentPage + 1} of {Math.ceil(streams.length / getMaxStreamsForLayout())}\n            </span>\n\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to next page');\n                const totalPages = Math.ceil(streams.length / getMaxStreamsForLayout());\n                setCurrentPage(Math.min(totalPages - 1, currentPage + 1));\n              }}\n              disabled={currentPage >= Math.ceil(streams.length / getMaxStreamsForLayout()) - 1}\n            >\n              Next\n            </button>\n          </div>\n        ) : null}\n      </div>\n    </section>\n  );\n}\n","/**\n * LightNVR Web Interface Live View Page\n * Entry point for the live view page with WebRTC/HLS support\n */\n\nimport { render } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { LiveView } from '../components/preact/LiveView.jsx';\nimport { WebRTCView } from '../components/preact/WebRTCView.jsx';\nimport { QueryClientProvider, queryClient } from '../query-client.js';\nimport { Header } from \"../components/preact/Header.jsx\";\nimport { Footer } from \"../components/preact/Footer.jsx\";\nimport { ToastContainer } from \"../components/preact/ToastContainer.jsx\";\n\n/**\n * Main App component that conditionally renders WebRTCView or LiveView\n * based on whether WebRTC is disabled in settings\n */\nfunction App() {\n    const [isWebRTCDisabled, setIsWebRTCDisabled] = useState(false);\n    const [isLoading, setIsLoading] = useState(true);\n\n    useEffect(() => {\n        // Check if WebRTC is disabled in settings\n        async function checkWebRTCStatus() {\n            try {\n                const response = await fetch('/api/settings');\n                if (!response.ok) {\n                    console.error('Failed to fetch settings:', response.status, response.statusText);\n                    setIsLoading(false);\n                    return;\n                }\n\n                const settings = await response.json();\n                \n                if (settings.webrtc_disabled) {\n                    console.log('WebRTC is disabled, using HLS view');\n                    setIsWebRTCDisabled(true);\n                } else {\n                    console.log('WebRTC is enabled, using WebRTC view');\n                    setIsWebRTCDisabled(false);\n                }\n            } catch (error) {\n                console.error('Error checking WebRTC status:', error);\n            } finally {\n                setIsLoading(false);\n            }\n        }\n\n        checkWebRTCStatus();\n    }, []);\n\n    if (isLoading) {\n        return <div className=\"loading\">Loading...</div>;\n    }\n\n    return (\n            <>{isWebRTCDisabled ? <LiveView isWebRTCDisabled={true} /> : <WebRTCView />}</>\n    );\n}\n\n// Render the App component when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Get the container element\n    const container = document.getElementById('main-content');\n\n    if (container) {\n        render(\n            <QueryClientProvider client={queryClient}>\n                <Header />\n                <ToastContainer />\n                <App />\n                <Footer />\n            </QueryClientProvider>,\n            container\n        );\n    }\n});\n"],"names":["WebRTCVideoCell","stream","streamId","onToggleFullscreen","isLoading","setIsLoading","useState","error","setError","isPlaying","setIsPlaying","connectionQuality","setConnectionQuality","videoRef","useRef","cellRef","peerConnectionRef","detectionOverlayRef","abortControllerRef","connectionMonitorRef","reconnectAttemptsRef","useEffect","name","current","console","log","pc","RTCPeerConnection","iceTransports","bundlePolicy","rtcpCnameCpn","rtcpCnameRtp","iceCandidatePoolSize","iceServers","urls","ontrack","event","track","kind","videoElement","srcObject","streams","onloadeddata","onplaying","setTimeout","play","catch","e","warn","iceConnectionState","onerror","onicecandidate","candidate","oniceconnectionstatechange","addTransceiver","direction","createOffer","then","offer","setLocalDescription","AbortController","formattedOffer","type","localDescription","sdp","auth","localStorage","getItem","fetch","encodeURIComponent","method","headers","Authorization","body","JSON","stringify","signal","response","ok","Error","status","statusText","text","parse","answer","setRemoteDescription","RTCSessionDescription","message","startConnectionMonitoring","clearInterval","setInterval","getStats","stats","packetsLost","packetsReceived","currentRtt","jitter","forEach","report","state","currentRoundTripTime","totalPackets","lossPercentage","quality","toFixed","handleRetry","err","originalOnIceConnectionStateChange","abort","getTracks","stop","close","jsxs","className","ref","style","position","pointerEvents","zIndex","children","jsx","id","replace","playsInline","autoPlay","muted","disablePictureInPicture","width","height","objectFit","detection_based_recording","detection_model","DetectionOverlay","streamName","enabled","detectionModel","top","left","padding","backgroundColor","color","borderRadius","fontSize","display","alignItems","gap","title","charAt","toUpperCase","slice","boxShadow","bottom","right","onMouseOver","currentTarget","onMouseOut","SnapshotButton","onSnapshot","canvasRef","getCanvasRef","snapshot","takeSnapshotWithDetections","showSnapshotPreview","canvas","toDataURL","document","createElement","videoWidth","videoHeight","getContext","drawImage","onClick","border","cursor","xmlns","viewBox","fill","stroke","d","LoadingIndicator","flexDirection","justifyContent","textAlign","maxWidth","marginBottom","fontWeight","lineHeight","transition","WebRTCView","takeSnapshot","useSnapshotManager","isFullscreen","setIsFullscreen","toggleFullscreen","useFullscreenManager","setStreams","layout","setLayout","layoutParam","URLSearchParams","window","location","search","get","sessionStorage","selectedStream","setSelectedStream","streamParam","currentPage","setCurrentPage","pageParam","Math","max","parseInt","storedPage","queryClient","useQueryClient","setupModals","addModalStyles","data","streamsData","isLoadingStreams","streamsError","useQuery","timeout","retries","retryDelay","Array","isArray","async","filteredStreams","filterStreamsForWebRTC","length","some","showStatusMessage","processStreams","url","URL","searchParams","delete","set","history","replaceState","setItem","toString","removeItem","streamPromises","map","fetchQuery","queryKey","queryFn","json","staleTime","detailedStreams","Promise","all","filter","is_deleted","streaming_enabled","getMaxStreamsForLayout","useCallback","getStreamsToShow","streamsToShow","maxStreams","totalPages","ceil","startIdx","endIdx","min","toggleStreamFullscreen","cellElement","preventDefault","stopPropagation","fullscreenElement","exitFullscreen","requestFullscreen","useMemo","SnapshotManager","FullscreenManager","targetId","href","htmlFor","value","onChange","newLayout","target","newStream","strokeWidth","strokeLinecap","strokeLinejoin","reload","disabled","App","isWebRTCDisabled","setIsWebRTCDisabled","webrtc_disabled","checkWebRTCStatus","Fragment","LiveView","addEventListener","container","getElementById","render","QueryClientProvider","client","Header","ToastContainer","Footer"],"mappings":"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"}