{"version":3,"file":"index-legacy-38GxN1Cn.js","sources":["../../js/components/preact/WebRTCVideoCell.jsx","../../js/components/preact/WebRTCView.jsx","../../js/pages/index-page.jsx"],"sourcesContent":["/**\n * WebRTCVideoCell Component\n * A reusable component for displaying a WebRTC video stream\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { startDetectionPolling } from './DetectionOverlay.js';\nimport { SnapshotButton } from './SnapshotManager.jsx';\n\n// Add CSS for spinner animation\nconst spinnerStyle = `\n  @keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n`;\n\n// Add the style to the document\nif (typeof document !== 'undefined') {\n  const style = document.createElement('style');\n  style.textContent = spinnerStyle;\n  document.head.appendChild(style);\n}\n\n/**\n * WebRTCVideoCell component\n * @param {Object} props - Component props\n * @param {Object} props.stream - Stream object\n * @param {Function} props.onTakeSnapshot - Snapshot handler\n * @param {Function} props.onToggleFullscreen - Fullscreen toggle handler\n * @param {Object} props.webrtcConnections - Reference to WebRTC connections\n * @param {Object} props.detectionIntervals - Reference to detection intervals\n * @param {Function} props.initializeWebRTCPlayer - Function to initialize WebRTC player\n * @param {Function} props.cleanupWebRTCPlayer - Function to cleanup WebRTC player\n * @returns {JSX.Element} WebRTCVideoCell component\n */\nexport function WebRTCVideoCell({\n  stream,\n  onTakeSnapshot,\n  onToggleFullscreen,\n  webrtcConnections,\n  detectionIntervals,\n  initializeWebRTCPlayer,\n  cleanupWebRTCPlayer\n}) {\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const cellRef = useRef(null);\n\n  // Initialize WebRTC player when component mounts\n  useEffect(() => {\n    if (!stream) return;\n\n    console.log(`WebRTCVideoCell: Initializing player for stream ${stream.name}`);\n\n    // Check if this stream already has a connection\n    const hasExistingConnection = webrtcConnections.current[stream.name];\n    if (hasExistingConnection) {\n      console.log(`WebRTCVideoCell: Stream ${stream.name} already has a connection, skipping initialization`);\n      setIsLoading(false);\n      return;\n    }\n\n    // Initialize WebRTC player with a short delay to ensure DOM is ready\n    console.log(`WebRTCVideoCell: Will initialize stream ${stream.name} after a short delay`);\n\n    const initTimeout = setTimeout(() => {\n      if (videoRef.current && canvasRef.current) {\n        console.log(`WebRTCVideoCell: Now initializing stream ${stream.name}`);\n        initializeWebRTCPlayer(stream, videoRef.current, canvasRef.current, {\n          onLoadedData: () => {\n            console.log(`Video data loaded for stream ${stream.name}`);\n            setIsLoading(false);\n          },\n          onPlaying: () => {\n            console.log(`Video playing for stream ${stream.name}`);\n            setIsLoading(false);\n\n            // Start detection polling if enabled\n            if (stream.detection_based_recording && stream.detection_model && canvasRef.current) {\n              console.log(`Starting detection polling for stream ${stream.name}`);\n              startDetectionPolling(stream.name, canvasRef.current, videoRef.current, detectionIntervals);\n            }\n          },\n          onError: (errorMessage) => {\n            console.error(`Video error for stream ${stream.name}:`, errorMessage);\n            setError(errorMessage || 'Video playback error');\n            setIsLoading(false);\n          }\n        });\n      }\n    }, 100); // Short 100ms delay to ensure DOM is ready\n\n    // Cleanup function\n    return () => {\n      clearTimeout(initTimeout);\n      if (stream) {\n        console.log(`WebRTCVideoCell: Cleaning up player for stream ${stream.name}`);\n        cleanupWebRTCPlayer(stream.name);\n      }\n    };\n  }, [stream.name]); // Only depend on stream.name to prevent unnecessary re-renders\n\n  // Handle retry button click\n  const handleRetry = () => {\n    if (!stream) return;\n\n    console.log(`Retrying connection for stream ${stream.name}`);\n    setIsLoading(true);\n    setError(null);\n\n    // Clean up existing connection\n    cleanupWebRTCPlayer(stream.name);\n\n    // Force a small delay to ensure cleanup is complete\n    setTimeout(() => {\n      if (videoRef.current && canvasRef.current) {\n        console.log(`Reinitializing WebRTC player for stream ${stream.name}`);\n        initializeWebRTCPlayer(stream, videoRef.current, canvasRef.current, {\n          onLoadedData: () => {\n            console.log(`Video data loaded for stream ${stream.name}`);\n            setIsLoading(false);\n          },\n          onPlaying: () => {\n            console.log(`Video playing for stream ${stream.name}`);\n            setIsLoading(false);\n          },\n          onError: (errorMessage) => {\n            console.error(`Video error for stream ${stream.name}:`, errorMessage);\n            // Try one more time with a longer delay\n            console.log(`Trying one more time for stream ${stream.name} with a longer delay`);\n\n            setTimeout(() => {\n              if (videoRef.current && canvasRef.current) {\n                initializeWebRTCPlayer(stream, videoRef.current, canvasRef.current, {\n                  onLoadedData: () => {\n                    console.log(`Video data loaded for stream ${stream.name} on second attempt`);\n                    setIsLoading(false);\n                  },\n                  onPlaying: () => {\n                    console.log(`Video playing for stream ${stream.name} on second attempt`);\n                    setIsLoading(false);\n                  },\n                  onError: (secondErrorMessage) => {\n                    console.error(`Video error for stream ${stream.name} on second attempt:`, secondErrorMessage);\n                    setError(secondErrorMessage || 'Video playback error');\n                    setIsLoading(false);\n                  }\n                });\n              }\n            }, 1000); // Try again after 1 second\n          }\n        });\n      }\n    }, 200);\n  };\n\n  return (\n    <div\n      className=\"video-cell\"\n      data-stream-name={stream.name}\n      data-stream-id={stream.id || stream.name}\n      ref={cellRef}\n      style={{ position: 'relative' }}\n    >\n      {/* Video element */}\n      <video\n        id={`video-${stream.name.replace(/\\s+/g, '-')}`}\n        className=\"video-element\"\n        ref={videoRef}\n        playsInline\n        autoPlay\n        muted\n        style={{ pointerEvents: 'none', width: '100%', height: '100%', objectFit: 'contain' }}\n      />\n\n      {/* Canvas overlay for detection */}\n      <canvas\n        id={`canvas-${stream.name.replace(/\\s+/g, '-')}`}\n        className=\"detection-overlay\"\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          pointerEvents: 'none',\n          zIndex: 5\n        }}\n      />\n\n      {/* Stream name overlay */}\n      <div\n        className=\"stream-name-overlay\"\n        style={{\n          position: 'absolute',\n          top: '10px',\n          left: '10px',\n          padding: '5px 10px',\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n          color: 'white',\n          borderRadius: '4px',\n          fontSize: '14px',\n          zIndex: 15,\n          pointerEvents: 'none'\n        }}\n      >\n        {stream.name}\n      </div>\n\n      {/* Stream controls */}\n      <div\n        className=\"stream-controls\"\n        style={{\n          position: 'absolute',\n          bottom: '10px',\n          right: '10px',\n          display: 'flex',\n          gap: '10px',\n          zIndex: 30,\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n          padding: '5px',\n          borderRadius: '4px',\n          pointerEvents: 'auto'\n        }}\n      >\n        <div\n          style={{\n            backgroundColor: 'transparent',\n            padding: '5px',\n            borderRadius: '4px',\n            position: 'relative',\n            zIndex: 30\n          }}\n          onMouseOver={(e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'}\n          onMouseOut={(e) => e.currentTarget.style.backgroundColor = 'transparent'}\n        >\n          <SnapshotButton\n            streamId={stream.id || stream.name}\n            streamName={stream.name}\n          />\n        </div>\n        <button\n          className=\"fullscreen-btn\"\n          title=\"Toggle Fullscreen\"\n          data-id={stream.id || stream.name}\n          data-name={stream.name}\n          onClick={(e) => onToggleFullscreen(stream.name, e)}\n          style={{\n            backgroundColor: 'transparent',\n            border: 'none',\n            padding: '5px',\n            borderRadius: '4px',\n            color: 'white',\n            cursor: 'pointer',\n            position: 'relative',\n            zIndex: 30\n          }}\n          onMouseOver={(e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'}\n          onMouseOut={(e) => e.currentTarget.style.backgroundColor = 'transparent'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path></svg>\n        </button>\n      </div>\n\n      {/* Loading indicator */}\n      {isLoading && (\n        <div\n          className=\"loading-indicator\"\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            width: '100%',\n            height: '100%',\n            display: 'flex',\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            backgroundColor: 'rgba(0, 0, 0, 0.7)',\n            color: 'white',\n            zIndex: 20,\n            pointerEvents: 'none',\n            textAlign: 'center'\n          }}\n        >\n          <div\n            className=\"loading-content\"\n            style={{\n              display: 'flex',\n              flexDirection: 'column',\n              justifyContent: 'center',\n              alignItems: 'center',\n              padding: '20px',\n              borderRadius: '8px',\n              backgroundColor: 'rgba(0, 0, 0, 0.5)'\n            }}\n          >\n            <div className=\"spinner\" style={{\n              width: '40px',\n              height: '40px',\n              border: '4px solid rgba(255, 255, 255, 0.3)',\n              borderRadius: '50%',\n              borderTop: '4px solid white',\n              animation: 'spin 1s linear infinite',\n              marginBottom: '15px'\n            }}></div>\n            <p style={{\n              fontSize: '14px',\n              fontWeight: 'bold'\n            }}>Connecting...</p>\n          </div>\n        </div>\n      )}\n\n      {/* Error indicator */}\n      {error && (\n        <div\n          className=\"error-indicator\"\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            width: '100%',\n            height: '100%',\n            display: 'flex',\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            backgroundColor: 'rgba(0, 0, 0, 0.7)',\n            color: 'white',\n            zIndex: 20,\n            pointerEvents: 'auto',\n            textAlign: 'center'\n          }}\n        >\n          <div\n            className=\"error-content\"\n            style={{\n              display: 'flex',\n              flexDirection: 'column',\n              justifyContent: 'center',\n              alignItems: 'center',\n              width: '80%',\n              maxWidth: '300px',\n              padding: '20px',\n              borderRadius: '8px',\n              backgroundColor: 'rgba(0, 0, 0, 0.5)'\n            }}\n          >\n            <div\n              className=\"error-icon\"\n              style={{\n                fontSize: '28px',\n                marginBottom: '15px',\n                fontWeight: 'bold',\n                width: '40px',\n                height: '40px',\n                lineHeight: '40px',\n                borderRadius: '50%',\n                backgroundColor: 'rgba(220, 38, 38, 0.8)',\n                textAlign: 'center'\n              }}\n            >\n              !\n            </div>\n            <p style={{\n              marginBottom: '20px',\n              textAlign: 'center',\n              width: '100%',\n              fontSize: '14px',\n              lineHeight: '1.4'\n            }}>\n              {error}\n            </p>\n            <button\n              className=\"retry-button\"\n              onClick={handleRetry}\n              style={{\n                padding: '8px 20px',\n                backgroundColor: '#2563eb',\n                color: 'white',\n                borderRadius: '4px',\n                border: 'none',\n                cursor: 'pointer',\n                fontWeight: 'bold',\n                fontSize: '14px',\n                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',\n                transition: 'background-color 0.2s ease'\n              }}\n              onMouseOver={(e) => e.currentTarget.style.backgroundColor = '#1d4ed8'}\n              onMouseOut={(e) => e.currentTarget.style.backgroundColor = '#2563eb'}\n            >\n              Retry\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n","/**\n * LightNVR Web Interface WebRTCView Component\n * Preact component for the WebRTC view page\n */\n\n\nimport { useState, useEffect, useRef, useCallback } from 'preact/hooks';\nimport { showSnapshotPreview, setupModals, addModalStyles } from './UI.jsx';\nimport { showStatusMessage } from './ToastContainer.jsx';\nimport { useFullscreenManager, FullscreenManager } from './FullscreenManager.jsx';\nimport { startDetectionPolling, cleanupDetectionPolling } from './DetectionOverlay.js';\nimport { useMutation, useQuery, useQueryClient } from '../../query-client.js';\nimport { WebRTCVideoCell } from './WebRTCVideoCell.jsx';\nimport { SnapshotManager, useSnapshotManager } from './SnapshotManager.jsx';\n\n/**\n * WebRTCView component\n * @returns {JSX.Element} WebRTCView component\n */\nexport function WebRTCView() {\n  // Use the snapshot manager hook\n  const { takeSnapshot } = useSnapshotManager();\n  // Use the fullscreen manager hook\n  const { isFullscreen, setIsFullscreen, toggleFullscreen } = useFullscreenManager();\n  // WebRTC offer mutation hook - we don't specify the URL here as it will be dynamic based on the stream\n  const webrtcOfferMutation = useMutation({\n    mutationFn: async (data) => {\n      const { streamName, ...offerData } = data;\n      const auth = localStorage.getItem('auth');\n\n      const response = await fetch(`/api/webrtc?src=${encodeURIComponent(streamName)}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(auth ? { 'Authorization': 'Basic ' + auth } : {})\n        },\n        body: JSON.stringify(offerData),\n        signal: data.signal\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to send offer: ${response.status} ${response.statusText}`);\n      }\n\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch (jsonError) {\n        console.error(`Error parsing JSON for stream ${streamName}:`, jsonError);\n        console.log(`Raw response text: ${text}`);\n        throw new Error(`Failed to parse WebRTC answer: ${jsonError.message}`);\n      }\n    },\n    onError: (error, variables) => {\n      console.error(`Error sending WebRTC offer for stream ${variables.streamName}:`, error);\n    }\n  });\n\n  const [streams, setStreams] = useState([]);\n  // Initialize layout from URL or sessionStorage if available\n  const [layout, setLayout] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const layoutParam = urlParams.get('layout');\n    if (layoutParam) {\n      return layoutParam;\n    }\n    // Check sessionStorage as a backup\n    const storedLayout = sessionStorage.getItem('webrtc_layout');\n    return storedLayout || '4';\n  });\n\n  // Initialize selectedStream from URL or sessionStorage if available\n  const [selectedStream, setSelectedStream] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const streamParam = urlParams.get('stream');\n    if (streamParam) {\n      return streamParam;\n    }\n    // Check sessionStorage as a backup\n    const storedStream = sessionStorage.getItem('webrtc_selected_stream');\n    return storedStream || '';\n  });\n\n  // isFullscreen state is now managed by useFullscreenManager\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Initialize currentPage from URL or sessionStorage if available (URL uses 1-based indexing, internal state uses 0-based)\n  const [currentPage, setCurrentPage] = useState(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const pageParam = urlParams.get('page');\n    if (pageParam) {\n      // Convert from 1-based (URL) to 0-based (internal)\n      return Math.max(0, parseInt(pageParam, 10) - 1);\n    }\n    // Check sessionStorage as a backup\n    const storedPage = sessionStorage.getItem('webrtc_current_page');\n    if (storedPage) {\n      // Convert from 1-based (stored) to 0-based (internal)\n      return Math.max(0, parseInt(storedPage, 10) - 1);\n    }\n    return 0;\n  });\n  const videoGridRef = useRef(null);\n  const webrtcConnections = useRef({});\n  const detectionIntervals = useRef({});\n\n  // Set up event listeners and UI components\n  useEffect(() => {\n    // Set up modals for snapshot preview\n    setupModals();\n    addModalStyles();\n\n    // Add event listener to preserve URL parameters when page is reloaded\n    const handleBeforeUnload = () => {\n      console.log('Preserving URL parameters before page reload');\n\n      // Create a URL with the current parameters\n      const url = new URL(window.location);\n\n      // Ensure page parameter is set correctly (convert from 0-based internal to 1-based URL)\n      if (currentPage > 0) {\n        url.searchParams.set('page', currentPage + 1);\n      } else {\n        url.searchParams.delete('page');\n      }\n\n      // Ensure layout parameter is set if not default\n      if (layout !== '4') {\n        url.searchParams.set('layout', layout);\n      } else {\n        url.searchParams.delete('layout');\n      }\n\n      // Ensure stream parameter is set if in single stream mode\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without triggering navigation\n      window.history.replaceState({}, '', url);\n\n      // Store the current page in sessionStorage as a backup\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      // Store layout in sessionStorage\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      // Store selected stream in sessionStorage\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    };\n\n    // Register the beforeunload handler\n    window.addEventListener('beforeunload', handleBeforeUnload);\n\n    // Set up periodic connection check\n    const connectionCheckInterval = setInterval(() => {\n      Object.keys(webrtcConnections.current).forEach(streamName => {\n        const pc = webrtcConnections.current[streamName];\n        if (pc) {\n          // Log connection state for debugging\n          console.debug(`WebRTC connection state for ${streamName}: ${pc.connectionState}, ICE state: ${pc.iceConnectionState}`);\n\n          // If connection is failed or disconnected for too long, try to reconnect\n          if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {\n            console.warn(`WebRTC connection for ${streamName} is in ${pc.iceConnectionState} state, will attempt reconnect`);\n\n            // Clean up the old connection\n            cleanupWebRTCPlayer(streamName);\n\n            // Find the stream info and reinitialize\n            const stream = streams.find(s => s.name === streamName);\n            if (stream) {\n              console.log(`Attempting to reconnect WebRTC for stream ${streamName}`);\n              initializeWebRTCPlayer(stream);\n            }\n          }\n        }\n      });\n    }, 30000); // Check every 30 seconds\n\n    // Cleanup\n    return () => {\n      // Remove event listeners\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      clearInterval(connectionCheckInterval);\n      stopAllWebRTCStreams();\n    };\n  }, [streams, currentPage, layout, selectedStream]); // Add all relevant dependencies\n\n  // Get query client for fetching and invalidating queries\n  const queryClient = useQueryClient();\n\n  // Fetch streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery(\n    'streams',\n    '/api/streams',\n    {\n      timeout: 15000, // 15 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    }\n  );\n\n  // Update loading state based on streams query status\n  useEffect(() => {\n    setIsLoading(isLoadingStreams);\n  }, [isLoadingStreams]);\n\n  // Process streams data when it's loaded\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData)) {\n      // Process the streams data\n      const processStreams = async () => {\n        try {\n          // Filter and process the streams\n          const filteredStreams = await filterStreamsForWebRTC(streamsData);\n\n          if (filteredStreams.length > 0) {\n            setStreams(filteredStreams);\n\n            // Set selectedStream based on URL parameter if it exists and is valid\n            const urlParams = new URLSearchParams(window.location.search);\n            const streamParam = urlParams.get('stream');\n\n            if (streamParam && filteredStreams.some(stream => stream.name === streamParam)) {\n              // If the stream from URL exists in the loaded streams, use it\n              setSelectedStream(streamParam);\n            } else if (!selectedStream || !filteredStreams.some(stream => stream.name === selectedStream)) {\n              // Otherwise use the first stream if selectedStream is not set or invalid\n              setSelectedStream(filteredStreams[0].name);\n            }\n          } else {\n            console.warn('No streams available for WebRTC view after filtering');\n          }\n        } catch (error) {\n          console.error('Error processing streams:', error);\n          showStatusMessage('Error processing streams: ' + error.message);\n        }\n      };\n\n      processStreams();\n    }\n  }, [streamsData, selectedStream, queryClient]);\n\n  // Use a ref to track previous values to prevent unnecessary updates\n  const previousValues = useRef({ layout, selectedStream, currentPage, streamsLength: streams.length });\n\n  useEffect(() => {\n    // Only update if something actually changed\n    const prev = previousValues.current;\n    if (\n      prev.layout !== layout ||\n      prev.selectedStream !== selectedStream ||\n      prev.currentPage !== currentPage ||\n      prev.streamsLength !== streams.length\n    ) {\n      console.log('Layout, selectedStream, currentPage, or streams changed, updating video grid');\n      updateVideoGrid();\n\n      // Update previous values\n      previousValues.current = { layout, selectedStream, currentPage, streamsLength: streams.length };\n    }\n  }, [layout, selectedStream, streams, currentPage]);\n\n  // Update URL when layout, page, or selectedStream changes\n  useEffect(() => {\n    // Don't update URL during initial load or when streams are empty\n    if (streams.length === 0) return;\n\n    // Use a debounce to prevent multiple URL updates in quick succession\n    const updateURLTimeout = setTimeout(() => {\n      console.log('Updating URL parameters');\n      const url = new URL(window.location);\n\n      // Handle page parameter (convert from 0-based internal to 1-based URL)\n      if (currentPage === 0) {\n        url.searchParams.delete('page');\n      } else {\n        // Add 1 to convert from 0-based (internal) to 1-based (URL)\n        url.searchParams.set('page', currentPage + 1);\n      }\n\n      // Handle layout parameter\n      if (layout !== '4') { // Only set if not the default\n        url.searchParams.set('layout', layout);\n      } else {\n        // Remove layout parameter if it's the default value\n        url.searchParams.delete('layout');\n      }\n\n      // Handle selectedStream parameter\n      if (layout === '1' && selectedStream) {\n        url.searchParams.set('stream', selectedStream);\n      } else {\n        // Remove stream parameter if not in single stream mode\n        url.searchParams.delete('stream');\n      }\n\n      // Update URL without reloading the page\n      window.history.replaceState({}, '', url);\n\n      // Also update sessionStorage\n      if (currentPage > 0) {\n        sessionStorage.setItem('webrtc_current_page', (currentPage + 1).toString());\n      } else {\n        sessionStorage.removeItem('webrtc_current_page');\n      }\n\n      if (layout !== '4') {\n        sessionStorage.setItem('webrtc_layout', layout);\n      } else {\n        sessionStorage.removeItem('webrtc_layout');\n      }\n\n      if (layout === '1' && selectedStream) {\n        sessionStorage.setItem('webrtc_selected_stream', selectedStream);\n      } else {\n        sessionStorage.removeItem('webrtc_selected_stream');\n      }\n    }, 300); // 300ms debounce\n\n    // Clean up the timeout if the component re-renders before the timeout completes\n    return () => clearTimeout(updateURLTimeout);\n  }, [currentPage, layout, selectedStream, streams.length]);\n\n  /**\n   * Filter streams for WebRTC view\n   * @param {Array} streams - Array of streams\n   * @returns {Promise<Array>} Promise resolving to filtered array of streams\n   */\n  const filterStreamsForWebRTC = async (streams) => {\n    try {\n      if (!streams || !Array.isArray(streams)) {\n        console.warn('No streams data provided to filter');\n        return [];\n      }\n\n      // For WebRTC view, we need to fetch full details for each stream\n      const streamPromises = streams.map(async (stream) => {\n        try {\n          const streamId = stream.id || stream.name;\n\n          const streamDetails = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamId],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamId)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to load details for stream ${stream.name}`);\n              }\n              return response.json();\n            },\n            staleTime: 30000 // 30 seconds\n          });\n\n          return streamDetails;\n        } catch (error) {\n          console.error(`Error loading details for stream ${stream.name}:`, error);\n          // Return the basic stream info if we can't get details\n          return stream;\n        }\n      });\n\n      const detailedStreams = await Promise.all(streamPromises);\n      console.log('Loaded detailed streams for WebRTC view:', detailedStreams);\n\n      // Filter out streams that are soft deleted, inactive, or not configured for streaming\n      const filteredStreams = detailedStreams.filter(stream => {\n        // Filter out soft deleted streams\n        if (stream.is_deleted) {\n          console.log(`Stream ${stream.name} is soft deleted, filtering out`);\n          return false;\n        }\n\n        // Filter out inactive streams\n        if (!stream.enabled) {\n          console.log(`Stream ${stream.name} is inactive, filtering out`);\n          return false;\n        }\n\n        // Filter out streams not configured for streaming\n        if (!stream.streaming_enabled) {\n          console.log(`Stream ${stream.name} is not configured for streaming, filtering out`);\n          return false;\n        }\n\n        return true;\n      });\n\n      console.log('Filtered streams for WebRTC view:', filteredStreams);\n\n      return filteredStreams || [];\n    } catch (error) {\n      console.error('Error filtering streams for WebRTC view:', error);\n      showStatusMessage('Error processing streams: ' + error.message);\n      return [];\n    }\n  };\n\n  /**\n   * Get maximum number of streams to display based on layout\n   * @returns {number} Maximum number of streams\n   */\n  const getMaxStreamsForLayout = () => {\n    switch (layout) {\n      case '1': return 1;  // Single view\n      case '2': return 2;  // 2x1 grid\n      case '4': return 4;  // 2x2 grid\n      case '6': return 6;  // 2x3 grid\n      case '9': return 9;  // 3x3 grid\n      case '16': return 16; // 4x4 grid\n      default: return 4;\n    }\n  };\n\n  /**\n   * Get streams to show based on layout, selected stream, and pagination\n   * @returns {Array} Streams to show\n   */\n  const getStreamsToShow = () => {\n    // Filter streams based on layout and selected stream\n    let streamsToShow = streams;\n    if (layout === '1' && selectedStream) {\n      streamsToShow = streams.filter(stream => stream.name === selectedStream);\n    } else {\n      // Apply pagination\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      // Ensure current page is valid\n      if (currentPage >= totalPages && totalPages > 0) {\n        // We'll handle this in updateVideoGrid\n        return [];\n      }\n\n      // Get streams for current page\n      const startIdx = currentPage * maxStreams;\n      const endIdx = Math.min(startIdx + maxStreams, streams.length);\n      streamsToShow = streams.slice(startIdx, endIdx);\n    }\n\n    return streamsToShow;\n  };\n\n  /**\n   * Update video grid based on layout, streams, and pagination\n   */\n  const updateVideoGrid = () => {\n    if (!videoGridRef.current) return;\n\n    // Filter streams based on layout and selected stream\n    let streamsToShow = getStreamsToShow();\n\n    // If no streams to show and we have streams, check if page is invalid\n    if (streamsToShow.length === 0 && streams.length > 0) {\n      const maxStreams = getMaxStreamsForLayout();\n      const totalPages = Math.ceil(streams.length / maxStreams);\n\n      if (currentPage >= totalPages) {\n        setCurrentPage(Math.max(0, totalPages - 1));\n        return; // Will re-render with corrected page\n      }\n    }\n\n    // Get the names of streams that should be shown\n    const streamsToShowNames = streamsToShow.map(stream => stream.name);\n\n    // Log page change for debugging\n    console.log(`Updating video grid for page ${currentPage + 1}, showing streams:`, streamsToShowNames);\n\n    // Clean up connections for streams that are no longer visible\n    const connectionsToCleanup = Object.keys(webrtcConnections.current).filter(\n      streamName => !streamsToShowNames.includes(streamName)\n    );\n\n    if (connectionsToCleanup.length > 0) {\n      console.log(`Cleaning up ${connectionsToCleanup.length} WebRTC connections that are no longer visible:`, connectionsToCleanup);\n      connectionsToCleanup.forEach(streamName => {\n        cleanupWebRTCPlayer(streamName);\n      });\n    }\n  };\n\n  /**\n   * Initialize WebRTC player for a stream\n   * @param {Object} stream - Stream object\n   * @param {HTMLVideoElement} videoElement - Video element\n   * @param {HTMLCanvasElement} canvasOverlay - Canvas overlay for detection\n   * @param {Object} callbacks - Callback functions\n   */\n  const initializeWebRTCPlayer = (stream, videoElement, canvasOverlay, callbacks = {}) => {\n    if (!stream || !videoElement) {\n      console.error(`Cannot initialize WebRTC player: missing stream or video element`);\n      return;\n    }\n\n    // Check if there's already a connection for this stream\n    if (webrtcConnections.current[stream.name]) {\n      console.log(`WebRTC connection for stream ${stream.name} already exists, cleaning up first`);\n      cleanupWebRTCPlayer(stream.name);\n    }\n\n    console.log(`Initializing WebRTC player for stream ${stream.name}`);\n\n    // Create a new RTCPeerConnection with ICE servers\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' }\n      ],\n      // Add additional configuration to ensure proper ICE credentials\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'balanced',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'unified-plan'\n    });\n\n    // Store the connection for cleanup\n    webrtcConnections.current[stream.name] = pc;\n\n    // Add event listeners\n    pc.ontrack = (event) => {\n      console.log(`Track received for stream ${stream.name}:`, event);\n      if (event.track.kind === 'video') {\n        videoElement.srcObject = event.streams[0];\n\n        // Add event handlers for video element\n        videoElement.onloadeddata = () => {\n          console.log(`Video data loaded for stream ${stream.name}`);\n          if (callbacks.onLoadedData) {\n            callbacks.onLoadedData();\n          }\n        };\n\n        videoElement.onplaying = () => {\n          console.log(`Video playing for stream ${stream.name}`);\n          if (callbacks.onPlaying) {\n            callbacks.onPlaying();\n          }\n\n          // Start detection polling now that the video is playing\n          if (stream.detection_based_recording && stream.detection_model && canvasOverlay) {\n            console.log(`Starting detection polling for stream ${stream.name} now that video is playing`);\n            startDetectionPolling(stream.name, canvasOverlay, videoElement, detectionIntervals.current);\n          } else {\n            console.log(`Detection not enabled for stream ${stream.name}`);\n          }\n        };\n\n        videoElement.onerror = (e) => {\n          console.error(`Video error for stream ${stream.name}:`, e);\n          if (callbacks.onError) {\n            callbacks.onError('Video playback error');\n          }\n        };\n      }\n    };\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log(`ICE candidate for stream ${stream.name}:`, event.candidate);\n        // go2rtc doesn't use a separate ICE endpoint, so we don't need to send ICE candidates\n      }\n    };\n\n    pc.oniceconnectionstatechange = () => {\n      console.log(`ICE connection state for stream ${stream.name}:`, pc.iceConnectionState);\n\n      // Handle different ICE connection states\n      if (pc.iceConnectionState === 'failed') {\n        console.warn(`ICE failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC ICE connection failed');\n        }\n      } else if (pc.iceConnectionState === 'disconnected') {\n        console.warn(`ICE disconnected for stream ${stream.name}`);\n        // Don't immediately handle as error, as disconnected can be temporary\n      }\n    };\n\n    // Also monitor connection state changes\n    pc.onconnectionstatechange = () => {\n      console.log(`Connection state changed for stream ${stream.name}:`, pc.connectionState);\n\n      if (pc.connectionState === 'failed') {\n        console.warn(`Connection failed for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('WebRTC connection failed');\n        }\n      }\n    };\n\n    // Add transceivers to ensure we get both audio and video tracks\n    pc.addTransceiver('video', {direction: 'recvonly'});\n    pc.addTransceiver('audio', {direction: 'recvonly'});\n\n    // Create an offer with specific codec requirements\n    const offerOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n\n    // Create a timeout for the entire WebRTC setup process\n    const setupTimeoutId = setTimeout(() => {\n      console.warn(`WebRTC setup timed out for stream ${stream.name}`);\n      if (callbacks.onError) {\n        callbacks.onError('WebRTC setup timed out');\n      }\n\n      // Clean up the connection if it exists\n      if (webrtcConnections.current[stream.name]) {\n        cleanupWebRTCPlayer(stream.name);\n      }\n    }, 30000); // 30 second timeout for the entire setup process\n\n    // Create a separate timeout for video playback\n    const videoPlaybackTimeoutId = setTimeout(() => {\n      // Only show error if the connection still exists but video isn't playing\n      if (webrtcConnections.current[stream.name] &&\n          (!videoElement.srcObject || videoElement.readyState < 2)) { // HAVE_CURRENT_DATA = 2\n        console.warn(`Video playback timed out for stream ${stream.name}`);\n        if (callbacks.onError) {\n          callbacks.onError('Video playback timed out');\n        }\n      }\n    }, 20000); // 20 second timeout for video playback\n\n    // Add a check to ensure the connection still exists before proceeding\n    const checkConnectionExists = () => {\n      return webrtcConnections.current[stream.name] === pc;\n    };\n\n    pc.createOffer(offerOptions)\n      .then(offer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up during offer creation');\n        }\n        console.log(`Created offer for stream ${stream.name}`);\n        return pc.setLocalDescription(offer);\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting local description');\n        }\n        console.log(`Set local description for stream ${stream.name}`);\n        // Send the offer to the server\n        return sendOffer(stream.name, pc.localDescription);\n      })\n      .then(answer => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after receiving answer');\n        }\n        console.log(`Received answer for stream ${stream.name}`);\n        // Set the remote description\n        return pc.setRemoteDescription(new RTCSessionDescription(answer));\n      })\n      .then(() => {\n        if (!checkConnectionExists()) {\n          throw new Error('Connection was cleaned up after setting remote description');\n        }\n        console.log(`Set remote description for stream ${stream.name}`);\n\n        // Clear both timeouts since we've successfully set up the connection\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n      })\n      .catch(error => {\n        // Clear both timeouts\n        clearTimeout(setupTimeoutId);\n        clearTimeout(videoPlaybackTimeoutId);\n\n        // Only log and call error callback if the connection still exists\n        if (checkConnectionExists()) {\n          console.error(`Error setting up WebRTC for stream ${stream.name}:`, error);\n          if (callbacks.onError) {\n            callbacks.onError(error.message);\n          }\n        } else {\n          console.log(`WebRTC setup for stream ${stream.name} was cancelled: ${error.message}`);\n        }\n      });\n\n    // Add event listener to clear the video playback timeout when video starts playing\n    videoElement.addEventListener('playing', () => {\n      clearTimeout(videoPlaybackTimeoutId);\n    }, { once: true }); // Use once: true to ensure it only fires once\n  };\n\n  /**\n   * Send WebRTC offer to server\n   * @param {string} streamName - Stream name\n   * @param {RTCSessionDescription} offer - WebRTC offer\n   * @returns {Promise<RTCSessionDescription>} Promise resolving to WebRTC answer\n   */\n  const sendOffer = useCallback(async (streamName, offer) => {\n    try {\n      // Format the offer according to go2rtc expectations\n      const formattedOffer = {\n        type: offer.type,\n        sdp: offer.sdp\n      };\n\n      console.log(`Sending formatted offer for stream ${streamName}`);\n\n      // Create an AbortController to allow cancellation of the request\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n\n      // Store the abort controller in the connection object for later cleanup\n      if (webrtcConnections.current[streamName]) {\n        webrtcConnections.current[streamName].abortController = abortController;\n      } else {\n        // If the connection no longer exists, abort immediately\n        console.log(`Connection for stream ${streamName} no longer exists, aborting offer`);\n        abortController.abort();\n        return Promise.reject(new Error('Connection no longer exists'));\n      }\n\n      // Use the mutation to send the offer with the abort signal\n      const result = await webrtcOfferMutation.mutateAsync({\n        ...formattedOffer,\n        streamName, // Add streamName for the URL construction in mutationFn\n        signal      // Add signal for request cancellation\n      });\n\n      // Check if the connection still exists before returning the result\n      if (webrtcConnections.current[streamName]) {\n        return result;\n      } else {\n        // If the connection was cleaned up during the request, abort and reject\n        console.log(`Connection for stream ${streamName} was cleaned up during offer, rejecting result`);\n        return Promise.reject(new Error('Connection was cleaned up during offer'));\n      }\n    } catch (error) {\n      // Check if this was an abort error, which we can safely ignore\n      if (error.name === 'AbortError') {\n        console.log(`WebRTC offer request for stream ${streamName} was aborted`);\n        // Return a rejected promise to stop the WebRTC connection process\n        return Promise.reject(new Error('Request aborted'));\n      }\n\n      console.error(`Error sending offer for stream ${streamName}:`, error);\n      throw error;\n    }\n  }, [webrtcOfferMutation]);\n\n  // ICE candidates are handled internally by the browser for go2rtc\n\n  /**\n   * Handle WebRTC error\n   * @param {string} streamName - Stream name\n   * @param {string} message - Error message\n   */\n  const handleWebRTCError = async (streamName, message) => {\n    console.error(`WebRTC error for stream ${streamName}:`, message);\n\n    // Find the video cell\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    if (!videoElement) return;\n\n    const videoCell = videoElement.closest('.video-cell');\n    if (!videoCell) return;\n\n    // Hide loading indicator\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'none';\n    }\n\n    // Create error indicator if it doesn't exist\n    let errorIndicator = videoCell.querySelector('.error-indicator');\n    if (!errorIndicator) {\n      errorIndicator = document.createElement('div');\n      errorIndicator.className = 'error-indicator';\n      errorIndicator.style.position = 'absolute';\n      errorIndicator.style.top = '0';\n      errorIndicator.style.left = '0';\n      errorIndicator.style.width = '100%';\n      errorIndicator.style.height = '100%';\n      errorIndicator.style.display = 'flex';\n      errorIndicator.style.flexDirection = 'column';\n      errorIndicator.style.justifyContent = 'center';\n      errorIndicator.style.alignItems = 'center';\n      errorIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n      errorIndicator.style.color = 'white';\n      errorIndicator.style.zIndex = '20'; // Above video but below controls\n      videoCell.appendChild(errorIndicator);\n    }\n\n    // Create the error message and retry button\n    const errorIcon = document.createElement('div');\n    errorIcon.className = 'error-icon';\n    errorIcon.textContent = '!';\n    errorIcon.style.fontSize = '24px';\n    errorIcon.style.marginBottom = '10px';\n    errorIcon.style.fontWeight = 'bold';\n\n    const errorMsg = document.createElement('p');\n    errorMsg.textContent = message || 'WebRTC connection failed';\n    errorMsg.style.marginBottom = '15px';\n    errorMsg.style.textAlign = 'center';\n    errorMsg.style.maxWidth = '80%';\n    errorMsg.style.color = 'white';\n\n    const retryButton = document.createElement('button');\n    retryButton.className = 'retry-button';\n    retryButton.textContent = 'Retry';\n    retryButton.style.padding = '8px 16px';\n    retryButton.style.backgroundColor = '#2563eb'; // blue-600\n    retryButton.style.color = 'white';\n    retryButton.style.borderRadius = '4px';\n    retryButton.style.border = 'none';\n    retryButton.style.cursor = 'pointer';\n    retryButton.style.position = 'relative';\n    retryButton.style.zIndex = '30';\n    retryButton.style.pointerEvents = 'auto';\n    retryButton.style.margin = '0 auto';\n    retryButton.style.display = 'block';\n\n    // Clear the error indicator and add the new elements\n    errorIndicator.innerHTML = '';\n    errorIndicator.appendChild(errorIcon);\n    errorIndicator.appendChild(errorMsg);\n    errorIndicator.appendChild(retryButton);\n\n    errorIndicator.style.display = 'flex';\n    errorIndicator.style.pointerEvents = 'auto'; // Enable pointer events when visible to allow retry button clicks\n\n    // Add event listener to retry button\n    retryButton.addEventListener('click', async (event) => {\n      console.log('Retry button clicked for stream:', streamName);\n      event.preventDefault();\n      event.stopPropagation();\n\n      // Show loading indicator\n      if (loadingIndicator) {\n        loadingIndicator.style.display = 'flex';\n      }\n\n      // Hide error indicator\n      errorIndicator.style.display = 'none';\n\n      // Cleanup existing connection\n      cleanupWebRTCPlayer(streamName);\n\n      // Find the stream in our streams array\n      const stream = streams.find(s => s.name === streamName);\n\n      if (stream) {\n        console.log(`Found stream ${streamName} in local state, reinitializing`);\n        // Small delay to ensure cleanup is complete\n        setTimeout(() => {\n          initializeWebRTCPlayer(stream);\n        }, 100);\n      } else {\n        console.log(`Stream ${streamName} not found in local state, fetching from API`);\n\n        try {\n          // Fetch stream info using queryClient\n          const streamInfo = await queryClient.fetchQuery({\n            queryKey: ['stream-details', streamName],\n            queryFn: async () => {\n              const response = await fetch(`/api/streams/${encodeURIComponent(streamName)}`);\n              if (!response.ok) {\n                throw new Error(`Failed to fetch stream info: ${response.status} ${response.statusText}`);\n              }\n              return response.json();\n            },\n            staleTime: 10000 // 10 seconds\n          });\n\n          console.log(`Received stream info for ${streamName}, reinitializing`);\n          // Reinitialize with a small delay\n          setTimeout(() => {\n            initializeWebRTCPlayer(streamInfo);\n          }, 100);\n        } catch (error) {\n          console.error('Error fetching stream info:', error);\n\n          // Show error indicator again with new message\n          errorIndicator.style.display = 'flex';\n          errorMsg.textContent = 'Could not reconnect: ' + error.message;\n\n          // Hide loading indicator\n          if (loadingIndicator) {\n            loadingIndicator.style.display = 'none';\n          }\n        }\n      }\n    });\n  };\n\n  /**\n   * Cleanup WebRTC player\n   * @param {string} streamName - Stream name\n   */\n  const cleanupWebRTCPlayer = (streamName) => {\n    console.log(`Cleaning up WebRTC player for stream ${streamName}`);\n\n    // Close and remove the RTCPeerConnection\n    if (webrtcConnections.current[streamName]) {\n      // Create a local reference to the connection before deleting it\n      const connection = webrtcConnections.current[streamName];\n\n      // Abort any pending fetch requests\n      if (connection.abortController) {\n        console.log(`Aborting pending WebRTC requests for stream ${streamName}`);\n        try {\n          connection.abortController.abort();\n        } catch (e) {\n          console.error(`Error aborting WebRTC request for stream ${streamName}:`, e);\n        }\n      }\n\n      // Remove all event listeners to prevent memory leaks\n      if (connection.onicecandidate) connection.onicecandidate = null;\n      if (connection.oniceconnectionstatechange) connection.oniceconnectionstatechange = null;\n      if (connection.onconnectionstatechange) connection.onconnectionstatechange = null;\n      if (connection.ontrack) connection.ontrack = null;\n\n      // Close the connection\n      connection.close();\n\n      // Remove from our reference object\n      delete webrtcConnections.current[streamName];\n\n      console.log(`Closed WebRTC connection for stream ${streamName}`);\n    }\n\n    // Clean up detection polling\n    cleanupDetectionPolling(streamName, detectionIntervals.current);\n  };\n\n  /**\n   * Stop all WebRTC streams\n   */\n  const stopAllWebRTCStreams = () => {\n    console.log('Stopping all WebRTC streams');\n    // Close all RTCPeerConnections\n    Object.keys(webrtcConnections.current).forEach(streamName => {\n      cleanupWebRTCPlayer(streamName);\n    });\n    console.log('All WebRTC streams stopped');\n  };\n\n// Note: takeSnapshot is now provided by the useSnapshotManager hook\n\n  /**\n   * Toggle fullscreen mode for a specific stream\n   * @param {string} streamName - Stream name\n   * @param {Event} event - Click event\n   */\n  const toggleStreamFullscreen = (streamName, event) => {\n    // Prevent default button behavior\n    if (event) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (!streamName) {\n      console.error('Stream name not provided for fullscreen toggle');\n      return;\n    }\n\n    console.log(`Toggling fullscreen for stream: ${streamName}`);\n    const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n    const videoElement = document.getElementById(videoElementId);\n    const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n\n    if (!videoCell) {\n      console.error('Stream not found:', streamName);\n      return;\n    }\n\n    if (!document.fullscreenElement) {\n      console.log('Entering fullscreen mode for video cell');\n      videoCell.requestFullscreen().catch(err => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        showStatusMessage(`Could not enable fullscreen mode: ${err.message}`);\n      });\n    } else {\n      console.log('Exiting fullscreen mode');\n      document.exitFullscreen();\n    }\n  };\n\n  return (\n    <section id=\"live-page\" className={`page ${isFullscreen ? 'fullscreen-mode' : ''}`}>\n      {/* Include the SnapshotManager component */}\n      <SnapshotManager />\n      {/* Include the FullscreenManager component */}\n      <FullscreenManager isFullscreen={isFullscreen} setIsFullscreen={setIsFullscreen} targetId=\"live-page\" />\n      <div className=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\">\n        <div className=\"flex items-center space-x-2\">\n          <h2 className=\"text-xl font-bold mr-4\">Live View</h2>\n          <div className=\"flex space-x-2\">\n            <button\n              id=\"hls-toggle-btn\"\n              className=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick={() => window.location.href = '/hls.html'}\n            >\n              HLS View\n            </button>\n          </div>\n        </div>\n        <div className=\"controls flex items-center space-x-2\">\n          <div className=\"flex items-center\">\n            <label for=\"layout-selector\" className=\"mr-2\">Layout:</label>\n            <select\n                id=\"layout-selector\"\n                className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                value={layout}\n                onChange={(e) => {\n                  const newLayout = e.target.value;\n                  setLayout(newLayout);\n                  setCurrentPage(0); // Reset to first page when layout changes\n                  // URL will be updated by the useEffect hook\n                }}\n            >\n              <option value=\"1\">1 Stream</option>\n              <option value=\"2\">2 Streams</option>\n              <option value=\"4\" selected>4 Streams</option>\n              <option value=\"6\">6 Streams</option>\n              <option value=\"9\">9 Streams</option>\n              <option value=\"16\">16 Streams</option>\n            </select>\n          </div>\n\n          {layout === '1' && (\n              <div className=\"flex items-center\">\n                <label for=\"stream-selector\" className=\"mr-2\">Stream:</label>\n                <select\n                    id=\"stream-selector\"\n                    className=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                    value={selectedStream}\n                    onChange={(e) => {\n                      const newStream = e.target.value;\n                      setSelectedStream(newStream);\n                      // URL will be updated by the useEffect hook\n                    }}\n                >\n                  {streams.map(stream =>\n                      <option key={stream.name} value={stream.name}>{stream.name}</option>\n                  )}\n                </select>\n              </div>\n          )}\n\n          <button\n              id=\"fullscreen-btn\"\n              className=\"p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 focus:outline-none\"\n              onClick={() => toggleFullscreen()}\n              title=\"Toggle Fullscreen\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\"\n                 stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n              <path\n                  d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path>\n            </svg>\n          </button>\n        </div>\n      </div>\n\n      <div className=\"flex flex-col space-y-4\">\n        <div\n            id=\"video-grid\"\n            className={`video-container layout-${layout}`}\n            ref={videoGridRef}\n        >\n          {isLoadingStreams ? (\n              <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n                <div className=\"flex flex-col items-center justify-center py-8\">\n                  <div\n                      className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                  <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (isLoading && !isLoadingStreams) ? (\n            <div className=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n              <div className=\"flex flex-col items-center justify-center py-8\">\n                <div\n                    className=\"inline-block animate-spin rounded-full border-4 border-gray-300 dark:border-gray-600 border-t-blue-600 dark:border-t-blue-500 w-16 h-16\"></div>\n                <p className=\"mt-4 text-gray-700 dark:text-gray-300\">Loading streams...</p>\n              </div>\n            </div>\n          ) : (streamsError) ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">Error loading streams: {streamsError.message}</p>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\"\n              >\n                Retry\n              </button>\n            </div>\n          ) : streams.length === 0 ? (\n            <div className=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n              <p className=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n              <a href=\"streams.html\" className=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n            </div>\n          ) : (\n            // Render video cells using our WebRTCVideoCell component\n            getStreamsToShow().map(stream => (\n              <WebRTCVideoCell\n                key={stream.name}\n                stream={stream}\n                onTakeSnapshot={takeSnapshot}\n                onToggleFullscreen={toggleStreamFullscreen}\n                webrtcConnections={webrtcConnections}\n                detectionIntervals={detectionIntervals}\n                initializeWebRTCPlayer={initializeWebRTCPlayer}\n                cleanupWebRTCPlayer={cleanupWebRTCPlayer}\n              />\n            ))\n          )}\n        </div>\n\n        {layout !== '1' && streams.length > getMaxStreamsForLayout() ? (\n          <div className=\"pagination-controls flex justify-center items-center space-x-4 mt-4\">\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to previous page');\n                setCurrentPage(Math.max(0, currentPage - 1));\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                const newPage = currentPage - 1;\n\n                if (newPage > 0) {\n                  url.searchParams.set('page', newPage + 1);\n                  sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n                } else {\n                  url.searchParams.delete('page');\n                  sessionStorage.removeItem('webrtc_current_page');\n                }\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage === 0}\n            >\n              Previous\n            </button>\n\n            <span className=\"text-gray-700 dark:text-gray-300\">\n              Page {currentPage + 1} of {Math.ceil(streams.length / getMaxStreamsForLayout())}\n            </span>\n\n            <button\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={() => {\n                console.log('Changing to next page');\n                const newPage = Math.min(Math.ceil(streams.length / getMaxStreamsForLayout()) - 1, currentPage + 1);\n                setCurrentPage(newPage);\n\n                // Update URL and sessionStorage\n                const url = new URL(window.location);\n                url.searchParams.set('page', newPage + 1);\n                sessionStorage.setItem('webrtc_current_page', (newPage + 1).toString());\n\n                window.history.replaceState({}, '', url);\n              }}\n              disabled={currentPage >= Math.ceil(streams.length / getMaxStreamsForLayout()) - 1}\n            >\n              Next\n            </button>\n          </div>\n        ) : null}\n      </div>\n    </section>\n  );\n}\n","/**\n * LightNVR Web Interface Live View Page\n * Entry point for the live view page with WebRTC/HLS support\n */\n\nimport { render } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { LiveView } from '../components/preact/LiveView.jsx';\nimport { WebRTCView } from '../components/preact/WebRTCView.jsx';\nimport { QueryClientProvider, queryClient } from '../query-client.js';\nimport { Header } from \"../components/preact/Header.jsx\";\nimport { Footer } from \"../components/preact/Footer.jsx\";\nimport { ToastContainer } from \"../components/preact/ToastContainer.jsx\";\n\n/**\n * Main App component that conditionally renders WebRTCView or LiveView\n * based on whether WebRTC is disabled in settings\n */\nfunction App() {\n    const [isWebRTCDisabled, setIsWebRTCDisabled] = useState(false);\n    const [isLoading, setIsLoading] = useState(true);\n\n    useEffect(() => {\n        // Check if WebRTC is disabled in settings\n        async function checkWebRTCStatus() {\n            try {\n                const response = await fetch('/api/settings');\n                if (!response.ok) {\n                    console.error('Failed to fetch settings:', response.status, response.statusText);\n                    setIsLoading(false);\n                    return;\n                }\n\n                const settings = await response.json();\n                \n                if (settings.webrtc_disabled) {\n                    console.log('WebRTC is disabled, using HLS view');\n                    setIsWebRTCDisabled(true);\n                } else {\n                    console.log('WebRTC is enabled, using WebRTC view');\n                    setIsWebRTCDisabled(false);\n                }\n            } catch (error) {\n                console.error('Error checking WebRTC status:', error);\n            } finally {\n                setIsLoading(false);\n            }\n        }\n\n        checkWebRTCStatus();\n    }, []);\n\n    if (isLoading) {\n        return <div className=\"loading\">Loading...</div>;\n    }\n\n    return (\n        <>\n            <Header />\n            <ToastContainer />\n            {isWebRTCDisabled ? <LiveView isWebRTCDisabled={true} /> : <WebRTCView />}\n            <Footer />\n        </>\n    );\n}\n\n// Render the App component when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Get the container element\n    const container = document.getElementById('main-content');\n\n    if (container) {\n        render(\n            <QueryClientProvider client={queryClient}>\n                <App />\n            </QueryClientProvider>,\n            container\n        );\n    }\n});\n"],"names":["document","style","createElement","textContent","head","appendChild","WebRTCVideoCell","stream","onTakeSnapshot","onToggleFullscreen","webrtcConnections","detectionIntervals","initializeWebRTCPlayer","cleanupWebRTCPlayer","isLoading","setIsLoading","useState","error","setError","videoRef","useRef","canvasRef","cellRef","useEffect","console","log","name","current","initTimeout","setTimeout","onLoadedData","onPlaying","detection_based_recording","detection_model","startDetectionPolling","onError","errorMessage","clearTimeout","jsxs","className","id","ref","position","children","jsx","replace","playsInline","autoPlay","muted","pointerEvents","width","height","objectFit","top","left","zIndex","padding","backgroundColor","color","borderRadius","fontSize","bottom","right","display","gap","onMouseOver","e","currentTarget","onMouseOut","SnapshotButton","streamId","streamName","title","onClick","border","cursor","xmlns","viewBox","fill","stroke","d","flexDirection","justifyContent","alignItems","textAlign","borderTop","animation","marginBottom","fontWeight","maxWidth","lineHeight","handleRetry","secondErrorMessage","boxShadow","transition","WebRTCView","takeSnapshot","useSnapshotManager","isFullscreen","setIsFullscreen","toggleFullscreen","useFullscreenManager","webrtcOfferMutation","useMutation","mutationFn","async","offerData","data","auth","localStorage","getItem","response","fetch","encodeURIComponent","method","headers","Authorization","body","JSON","stringify","signal","ok","Error","status","statusText","text","parse","jsonError","message","variables","streams","setStreams","layout","setLayout","layoutParam","URLSearchParams","window","location","search","get","sessionStorage","selectedStream","setSelectedStream","streamParam","currentPage","setCurrentPage","pageParam","Math","max","parseInt","storedPage","videoGridRef","setupModals","addModalStyles","handleBeforeUnload","url","URL","searchParams","set","delete","history","replaceState","setItem","toString","removeItem","addEventListener","connectionCheckInterval","setInterval","Object","keys","forEach","pc","debug","connectionState","iceConnectionState","warn","find","s","removeEventListener","clearInterval","stopAllWebRTCStreams","queryClient","useQueryClient","streamsData","isLoadingStreams","streamsError","useQuery","timeout","retries","retryDelay","Array","isArray","filteredStreams","filterStreamsForWebRTC","length","some","showStatusMessage","processStreams","previousValues","streamsLength","prev","updateVideoGrid","updateURLTimeout","streamPromises","map","fetchQuery","queryKey","queryFn","json","staleTime","detailedStreams","Promise","all","filter","is_deleted","enabled","streaming_enabled","getMaxStreamsForLayout","getStreamsToShow","streamsToShow","maxStreams","totalPages","ceil","startIdx","endIdx","min","slice","streamsToShowNames","connectionsToCleanup","includes","videoElement","canvasOverlay","callbacks","RTCPeerConnection","iceServers","urls","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","sdpSemantics","ontrack","event","track","kind","srcObject","onloadeddata","onplaying","onerror","onicecandidate","candidate","oniceconnectionstatechange","onconnectionstatechange","addTransceiver","direction","setupTimeoutId","videoPlaybackTimeoutId","readyState","checkConnectionExists","createOffer","offerToReceiveAudio","offerToReceiveVideo","then","offer","setLocalDescription","sendOffer","localDescription","answer","setRemoteDescription","RTCSessionDescription","catch","once","useCallback","formattedOffer","type","sdp","abortController","AbortController","abort","reject","result","mutateAsync","connection","close","cleanupDetectionPolling","toggleStreamFullscreen","preventDefault","stopPropagation","videoElementId","getElementById","videoCell","closest","fullscreenElement","exitFullscreen","requestFullscreen","err","SnapshotManager","FullscreenManager","targetId","href","for","value","onChange","newLayout","target","selected","newStream","reload","newPage","disabled","App","isWebRTCDisabled","setIsWebRTCDisabled","webrtc_disabled","checkWebRTCStatus","Fragment","Header","ToastContainer","LiveView","Footer","container","render","QueryClientProvider","client"],"mappings":"ijBAkBA,GAAwB,oBAAbA,SAA0B,CAC7B,MAAAC,EAAQD,SAASE,cAAc,SACrCD,EAAME,YAVa,6GAWVH,SAAAI,KAAKC,YAAYJ,EAC5B,CAcO,SAASK,GAAgBC,OAC9BA,EAAAC,eACAA,EAAAC,mBACAA,EAAAC,kBACAA,EAAAC,mBACAA,EAAAC,uBACAA,EAAAC,oBACAA,IAEA,MAAOC,EAAWC,GAAgBC,GAAS,IACpCC,EAAOC,GAAYF,EAAS,MAC7BG,EAAWC,EAAO,MAClBC,EAAYD,EAAO,MACnBE,EAAUF,EAAO,MA+GrB,OA5GFG,GAAU,KACR,IAAKhB,EAAQ,OAMb,GAJAiB,QAAQC,IAAI,mDAAmDlB,EAAOmB,QAGxChB,EAAkBiB,QAAQpB,EAAOmB,MAI7D,OAFAF,QAAQC,IAAI,2BAA2BlB,EAAOmB,+DAC9CX,GAAa,GAKfS,QAAQC,IAAI,2CAA2ClB,EAAOmB,4BAExD,MAAAE,EAAcC,YAAW,KACzBV,EAASQ,SAAWN,EAAUM,UAChCH,QAAQC,IAAI,4CAA4ClB,EAAOmB,QAC/Dd,EAAuBL,EAAQY,EAASQ,QAASN,EAAUM,QAAS,CAClEG,aAAcA,KACZN,QAAQC,IAAI,gCAAgClB,EAAOmB,QACnDX,GAAa,EAAK,EAEpBgB,UAAWA,KACTP,QAAQC,IAAI,4BAA4BlB,EAAOmB,QAC/CX,GAAa,GAGTR,EAAOyB,2BAA6BzB,EAAO0B,iBAAmBZ,EAAUM,UAC1EH,QAAQC,IAAI,yCAAyClB,EAAOmB,QAC5DQ,EAAsB3B,EAAOmB,KAAML,EAAUM,QAASR,EAASQ,QAAShB,GAAkB,EAG9FwB,QAAUC,IACRZ,QAAQP,MAAM,0BAA0BV,EAAOmB,QAASU,GACxDlB,EAASkB,GAAgB,wBACzBrB,GAAa,EAAK,IAErB,GAEF,KAGH,MAAO,KACLsB,aAAaT,GACTrB,IACFiB,QAAQC,IAAI,kDAAkDlB,EAAOmB,QACrEb,EAAoBN,EAAOmB,MAAI,CAEnC,GACC,CAACnB,EAAOmB,OAyDTY,EAAC,MAAA,CACCC,UAAU,aACV,mBAAkBhC,EAAOmB,KACzB,iBAAgBnB,EAAOiC,IAAMjC,EAAOmB,KACpCe,IAAKnB,EACLrB,MAAO,CAAEyC,SAAU,YAGnBC,SAAA,CAAAC,EAAC,QAAA,CACCJ,GAAI,SAASjC,EAAOmB,KAAKmB,QAAQ,OAAQ,OACzCN,UAAU,gBACVE,IAAKtB,EACL2B,aAAW,EACXC,UAAQ,EACRC,OAAK,EACL/C,MAAO,CAAEgD,cAAe,OAAQC,MAAO,OAAQC,OAAQ,OAAQC,UAAW,aAI5ER,EAAC,SAAA,CACCJ,GAAI,UAAUjC,EAAOmB,KAAKmB,QAAQ,OAAQ,OAC1CN,UAAU,oBACVE,IAAKpB,EACLpB,MAAO,CACLyC,SAAU,WACVW,IAAK,EACLC,KAAM,EACNJ,MAAO,OACPC,OAAQ,OACRF,cAAe,OACfM,OAAQ,KAKZX,EAAC,MAAA,CACCL,UAAU,sBACVtC,MAAO,CACLyC,SAAU,WACVW,IAAK,OACLC,KAAM,OACNE,QAAS,WACTC,gBAAiB,qBACjBC,MAAO,QACPC,aAAc,MACdC,SAAU,OACVL,OAAQ,GACRN,cAAe,QAGhBN,SAAOpC,EAAAmB,OAIVY,EAAC,MAAA,CACCC,UAAU,kBACVtC,MAAO,CACLyC,SAAU,WACVmB,OAAQ,OACRC,MAAO,OACPC,QAAS,OACTC,IAAK,OACLT,OAAQ,GACRE,gBAAiB,qBACjBD,QAAS,MACTG,aAAc,MACdV,cAAe,QAGjBN,SAAA,CAAAC,EAAC,MAAA,CACC3C,MAAO,CACLwD,gBAAiB,cACjBD,QAAS,MACTG,aAAc,MACdjB,SAAU,WACVa,OAAQ,IAEVU,YAAcC,GAAMA,EAAEC,cAAclE,MAAMwD,gBAAkB,2BAC5DW,WAAaF,GAAMA,EAAEC,cAAclE,MAAMwD,gBAAkB,cAE3Dd,SAAAC,EAACyB,EAAA,CACCC,SAAU/D,EAAOiC,IAAMjC,EAAOmB,KAC9B6C,WAAYhE,EAAOmB,SAGvBkB,EAAC,SAAA,CACCL,UAAU,iBACViC,MAAM,oBACN,UAASjE,EAAOiC,IAAMjC,EAAOmB,KAC7B,YAAWnB,EAAOmB,KAClB+C,QAAUP,GAAMzD,EAAmBF,EAAOmB,KAAMwC,GAChDjE,MAAO,CACLwD,gBAAiB,cACjBiB,OAAQ,OACRlB,QAAS,MACTG,aAAc,MACdD,MAAO,QACPiB,OAAQ,UACRjC,SAAU,WACVa,OAAQ,IAEVU,YAAcC,GAAMA,EAAEC,cAAclE,MAAMwD,gBAAkB,2BAC5DW,WAAaF,GAAMA,EAAEC,cAAclE,MAAMwD,gBAAkB,cAE3Dd,SAAAC,EAAC,MAAI,CAAAgC,MAAM,6BAA6B1B,MAAM,KAAKC,OAAO,KAAK0B,QAAQ,YAAYC,KAAK,OAAOC,OAAO,QAAQ,eAAa,IAAI,iBAAe,QAAQ,kBAAgB,QAAQpC,SAACC,EAAA,OAAA,CAAKoC,EAAE,yGAKzLlE,GACC8B,EAAC,MAAA,CACCL,UAAU,oBACVtC,MAAO,CACLyC,SAAU,WACVW,IAAK,EACLC,KAAM,EACNQ,MAAO,EACPD,OAAQ,EACRX,MAAO,OACPC,OAAQ,OACRY,QAAS,OACTkB,cAAe,SACfC,eAAgB,SAChBC,WAAY,SACZ1B,gBAAiB,qBACjBC,MAAO,QACPH,OAAQ,GACRN,cAAe,OACfmC,UAAW,UAGbzC,SAAAL,EAAC,MAAA,CACCC,UAAU,kBACVtC,MAAO,CACL8D,QAAS,OACTkB,cAAe,SACfC,eAAgB,SAChBC,WAAY,SACZ3B,QAAS,OACTG,aAAc,MACdF,gBAAiB,sBAGnBd,SAAA,CAACC,EAAA,MAAA,CAAIL,UAAU,UAAUtC,MAAO,CAC9BiD,MAAO,OACPC,OAAQ,OACRuB,OAAQ,qCACRf,aAAc,MACd0B,UAAW,kBACXC,UAAW,0BACXC,aAAc,UAEhB3C,EAAC,KAAE3C,MAAO,CACR2D,SAAU,OACV4B,WAAY,QACX7C,SAAa,uBAMrB1B,GACC2B,EAAC,MAAA,CACCL,UAAU,kBACVtC,MAAO,CACLyC,SAAU,WACVW,IAAK,EACLC,KAAM,EACNQ,MAAO,EACPD,OAAQ,EACRX,MAAO,OACPC,OAAQ,OACRY,QAAS,OACTkB,cAAe,SACfC,eAAgB,SAChBC,WAAY,SACZ1B,gBAAiB,qBACjBC,MAAO,QACPH,OAAQ,GACRN,cAAe,OACfmC,UAAW,UAGbzC,SAAAL,EAAC,MAAA,CACCC,UAAU,gBACVtC,MAAO,CACL8D,QAAS,OACTkB,cAAe,SACfC,eAAgB,SAChBC,WAAY,SACZjC,MAAO,MACPuC,SAAU,QACVjC,QAAS,OACTG,aAAc,MACdF,gBAAiB,sBAGnBd,SAAA,CAAAC,EAAC,MAAA,CACCL,UAAU,aACVtC,MAAO,CACL2D,SAAU,OACV2B,aAAc,OACdC,WAAY,OACZtC,MAAO,OACPC,OAAQ,OACRuC,WAAY,OACZ/B,aAAc,MACdF,gBAAiB,yBACjB2B,UAAW,UAEdzC,SAAA,MAGDC,EAAC,KAAE3C,MAAO,CACRsF,aAAc,OACdH,UAAW,SACXlC,MAAO,OACPU,SAAU,OACV8B,WAAY,OAEX/C,SACH1B,IACA2B,EAAC,SAAA,CACCL,UAAU,eACVkC,QAtRQkB,KACbpF,IAELiB,QAAQC,IAAI,kCAAkClB,EAAOmB,QACrDX,GAAa,GACbG,EAAS,MAGTL,EAAoBN,EAAOmB,MAG3BG,YAAW,KACLV,EAASQ,SAAWN,EAAUM,UAChCH,QAAQC,IAAI,2CAA2ClB,EAAOmB,QAC9Dd,EAAuBL,EAAQY,EAASQ,QAASN,EAAUM,QAAS,CAClEG,aAAcA,KACZN,QAAQC,IAAI,gCAAgClB,EAAOmB,QACnDX,GAAa,EAAK,EAEpBgB,UAAWA,KACTP,QAAQC,IAAI,4BAA4BlB,EAAOmB,QAC/CX,GAAa,EAAK,EAEpBoB,QAAUC,IACRZ,QAAQP,MAAM,0BAA0BV,EAAOmB,QAASU,GAExDZ,QAAQC,IAAI,mCAAmClB,EAAOmB,4BAEtDG,YAAW,KACLV,EAASQ,SAAWN,EAAUM,SAChCf,EAAuBL,EAAQY,EAASQ,QAASN,EAAUM,QAAS,CAClEG,aAAcA,KACZN,QAAQC,IAAI,gCAAgClB,EAAOmB,0BACnDX,GAAa,EAAK,EAEpBgB,UAAWA,KACTP,QAAQC,IAAI,4BAA4BlB,EAAOmB,0BAC/CX,GAAa,EAAK,EAEpBoB,QAAUyD,IACRpE,QAAQP,MAAM,0BAA0BV,EAAOmB,0BAA2BkE,GAC1E1E,EAAS0E,GAAsB,wBAC/B7E,GAAa,EAAK,GAErB,GAEF,IAAI,IAEV,GAEF,KAAG,EAqOId,MAAO,CACLuD,QAAS,WACTC,gBAAiB,UACjBC,MAAO,QACPC,aAAc,MACde,OAAQ,OACRC,OAAQ,UACRa,WAAY,OACZ5B,SAAU,OACViC,UAAW,+BACXC,WAAY,8BAEd7B,YAAcC,GAAMA,EAAEC,cAAclE,MAAMwD,gBAAkB,UAC5DW,WAAaF,GAAMA,EAAEC,cAAclE,MAAMwD,gBAAkB,UAC5Dd,SAAA,iBAQb,CCpYO,SAASoD,IAER,MAAAC,aAAEA,GAAiBC,KAEnBC,aAAEA,EAAAC,gBAAcA,EAAiBC,iBAAAA,GAAqBC,IAEtDC,EAAsBC,EAAY,CACtCC,WAAYC,UACV,MAAMlC,WAAEA,KAAemC,GAAcC,EAC/BC,EAAOC,aAAaC,QAAQ,QAE5BC,QAAiBC,MAAM,mBAAmBC,mBAAmB1C,KAAe,CAChF2C,OAAQ,OACRC,QAAS,CACP,eAAgB,sBACZP,EAAO,CAAEQ,cAAiB,SAAWR,GAAS,CAAA,GAEpDS,KAAMC,KAAKC,UAAUb,GACrBc,OAAQb,EAAKa,SAGX,IAACT,EAASU,GACN,MAAI,IAAAC,MAAM,yBAAyBX,EAASY,UAAUZ,EAASa,cAGjE,MAAAC,QAAad,EAASc,OACxB,IACK,OAAAP,KAAKQ,MAAMD,SACXE,GAGP,MAFAvG,QAAQP,MAAM,iCAAiCsD,KAAewD,GACtDvG,QAAAC,IAAI,sBAAsBoG,KAC5B,IAAIH,MAAM,kCAAkCK,EAAUC,UAAS,GAGzE7F,QAASA,CAAClB,EAAOgH,KACfzG,QAAQP,MAAM,yCAAyCgH,EAAU1D,cAAetD,EAAK,KAIlFiH,EAASC,GAAcnH,EAAS,KAEhCoH,EAAQC,GAAarH,GAAS,KACnC,MACMsH,EADY,IAAIC,gBAAgBC,OAAOC,SAASC,QACxBC,IAAI,UAClC,OAAIL,IAIiBM,eAAe9B,QAAQ,kBACrB,IAAA,KAIlB+B,EAAgBC,GAAqB9H,GAAS,KACnD,MACM+H,EADY,IAAIR,gBAAgBC,OAAOC,SAASC,QACxBC,IAAI,UAClC,OAAII,IAIiBH,eAAe9B,QAAQ,2BACrB,GAAA,KAIlBhG,EAAWC,GAAgBC,GAAS,IAGpCgI,EAAaC,GAAkBjI,GAAS,KAC7C,MACMkI,EADY,IAAIX,gBAAgBC,OAAOC,SAASC,QAC1BC,IAAI,QAChC,GAAIO,EAEF,OAAOC,KAAKC,IAAI,EAAGC,SAASH,EAAW,IAAM,GAGzC,MAAAI,EAAaV,eAAe9B,QAAQ,uBAC1C,OAAIwC,EAEKH,KAAKC,IAAI,EAAGC,SAASC,EAAY,IAAM,GAEzC,CAAA,IAEHC,EAAenI,EAAO,MACtBV,EAAoBU,EAAO,IAC3BT,EAAqBS,EAAO,IAGlCG,GAAU,KAEIiI,IACGC,IAGf,MAAMC,EAAqBA,KACzBlI,QAAQC,IAAI,gDAGZ,MAAMkI,EAAM,IAAIC,IAAIpB,OAAOC,UAGvBO,EAAc,EAChBW,EAAIE,aAAaC,IAAI,OAAQd,EAAc,GAEvCW,EAAAE,aAAaE,OAAO,QAIX,MAAX3B,EACEuB,EAAAE,aAAaC,IAAI,SAAU1B,GAE3BuB,EAAAE,aAAaE,OAAO,UAIX,MAAX3B,GAAkBS,EAChBc,EAAAE,aAAaC,IAAI,SAAUjB,GAE3Bc,EAAAE,aAAaE,OAAO,UAI1BvB,OAAOwB,QAAQC,aAAa,CAAA,EAAI,GAAIN,GAGhCX,EAAc,EAChBJ,eAAesB,QAAQ,uBAAwBlB,EAAc,GAAGmB,YAEhEvB,eAAewB,WAAW,uBAIb,MAAXhC,EACaQ,eAAAsB,QAAQ,gBAAiB9B,GAExCQ,eAAewB,WAAW,iBAIb,MAAXhC,GAAkBS,EACLD,eAAAsB,QAAQ,yBAA0BrB,GAEjDD,eAAewB,WAAW,yBAAwB,EAK/C5B,OAAA6B,iBAAiB,eAAgBX,GAGlC,MAAAY,EAA0BC,aAAY,KAC1CC,OAAOC,KAAK/J,EAAkBiB,SAAS+I,SAAsBnG,IACrD,MAAAoG,EAAKjK,EAAkBiB,QAAQ4C,GACrC,GAAIoG,IAEMnJ,QAAAoJ,MAAM,+BAA+BrG,MAAeoG,EAAGE,+BAA+BF,EAAGG,sBAGnE,WAA1BH,EAAGG,oBAA6D,iBAA1BH,EAAGG,oBAAuC,CAClFtJ,QAAQuJ,KAAK,yBAAyBxG,WAAoBoG,EAAGG,oDAG7DjK,EAAoB0D,GAGpB,MAAMhE,EAAS2H,EAAQ8C,MAAUC,GAAAA,EAAEvJ,OAAS6C,IACxChE,IACMiB,QAAAC,IAAI,6CAA6C8C,KACzD3D,EAAuBL,GACzB,CACF,GAEH,GACA,KAGH,MAAO,KAEEiI,OAAA0C,oBAAoB,eAAgBxB,GAC3CyB,cAAcb,GACOc,GAAA,CACvB,GACC,CAAClD,EAASc,EAAaZ,EAAQS,IAGlC,MAAMwC,EAAcC,KAIlB3E,KAAM4E,EACNzK,UAAW0K,EACXvK,MAAOwK,GACLC,EACF,UACA,eACA,CACEC,QAAS,KACTC,QAAS,EACTC,WAAY,MAKhBtK,GAAU,KACRR,EAAayK,EAAgB,GAC5B,CAACA,IAGJjK,GAAU,KACJgK,GAAeO,MAAMC,QAAQR,IAER9E,WACjB,IAEI,MAAAuF,QAAwBC,EAAuBV,GAEjD,GAAAS,EAAgBE,OAAS,EAAG,CAC9B/D,EAAW6D,GAGX,MACMjD,EADY,IAAIR,gBAAgBC,OAAOC,SAASC,QACxBC,IAAI,UAE9BI,GAAeiD,EAAgBG,SAAe5L,EAAOmB,OAASqH,IAEhED,EAAkBC,GACRF,GAAmBmD,EAAgBG,MAAe5L,GAAAA,EAAOmB,OAASmH,KAE1DC,EAAAkD,EAAgB,GAAGtK,KACvC,MAEAF,QAAQuJ,KAAK,8DAER9J,GACCO,QAAAP,MAAM,4BAA6BA,GACzBmL,EAAA,6BAA+BnL,EAAM+G,QAAO,GAInDqE,EAAA,GAEhB,CAACd,EAAa1C,EAAgBwC,IAG3B,MAAAiB,EAAiBlL,EAAO,CAAEgH,SAAQS,iBAAgBG,cAAauD,cAAerE,EAAQgE,SAE5F3K,GAAU,KAER,MAAMiL,EAAOF,EAAe3K,QAE1B6K,EAAKpE,SAAWA,GAChBoE,EAAK3D,iBAAmBA,GACxB2D,EAAKxD,cAAgBA,GACrBwD,EAAKD,gBAAkBrE,EAAQgE,SAE/B1K,QAAQC,IAAI,gFACIgL,IAGhBH,EAAe3K,QAAU,CAAEyG,SAAQS,iBAAgBG,cAAauD,cAAerE,EAAQgE,QAAO,GAE/F,CAAC9D,EAAQS,EAAgBX,EAASc,IAGrCzH,GAAU,KAEJ,GAAmB,IAAnB2G,EAAQgE,OAAc,OAGpB,MAAAQ,EAAmB7K,YAAW,KAClCL,QAAQC,IAAI,2BACZ,MAAMkI,EAAM,IAAIC,IAAIpB,OAAOC,UAGP,IAAhBO,EACEW,EAAAE,aAAaE,OAAO,QAGxBJ,EAAIE,aAAaC,IAAI,OAAQd,EAAc,GAI9B,MAAXZ,EACEuB,EAAAE,aAAaC,IAAI,SAAU1B,GAG3BuB,EAAAE,aAAaE,OAAO,UAIX,MAAX3B,GAAkBS,EAChBc,EAAAE,aAAaC,IAAI,SAAUjB,GAG3Bc,EAAAE,aAAaE,OAAO,UAI1BvB,OAAOwB,QAAQC,aAAa,CAAA,EAAI,GAAIN,GAGhCX,EAAc,EAChBJ,eAAesB,QAAQ,uBAAwBlB,EAAc,GAAGmB,YAEhEvB,eAAewB,WAAW,uBAGb,MAAXhC,EACaQ,eAAAsB,QAAQ,gBAAiB9B,GAExCQ,eAAewB,WAAW,iBAGb,MAAXhC,GAAkBS,EACLD,eAAAsB,QAAQ,yBAA0BrB,GAEjDD,eAAewB,WAAW,yBAAwB,GAEnD,KAGI,MAAA,IAAM/H,aAAaqK,EAAgB,GACzC,CAAC1D,EAAaZ,EAAQS,EAAgBX,EAAQgE,SAO3C,MAAAD,EAAyBxF,UACzB,IACF,IAAKyB,IAAY4D,MAAMC,QAAQ7D,GAE7B,OADA1G,QAAQuJ,KAAK,sCACN,GAIT,MAAM4B,EAAiBzE,EAAQ0E,KAAInG,UAC7B,IACI,MAAAnC,EAAW/D,EAAOiC,IAAMjC,EAAOmB,KAc9B,aAZqB2J,EAAYwB,WAAW,CACjDC,SAAU,CAAC,iBAAkBxI,GAC7ByI,QAAStG,UACP,MAAMM,QAAiBC,MAAM,gBAAgBC,mBAAmB3C,MAC5D,IAACyC,EAASU,GACZ,UAAUC,MAAM,qCAAqCnH,EAAOmB,QAE9D,OAAOqF,EAASiG,MAAK,EAEvBC,UAAW,YAINhM,GAGA,OAFPO,QAAQP,MAAM,oCAAoCV,EAAOmB,QAAST,GAE3DV,CAAA,KAIL2M,QAAwBC,QAAQC,IAAIT,GAClCnL,QAAAC,IAAI,2CAA4CyL,GAGlD,MAAAlB,EAAkBkB,EAAgBG,QAAiB9M,GAEnDA,EAAO+M,YACT9L,QAAQC,IAAI,UAAUlB,EAAOmB,wCACtB,GAIJnB,EAAOgN,UAMPhN,EAAOiN,oBACVhM,QAAQC,IAAI,UAAUlB,EAAOmB,wDACtB,IAPPF,QAAQC,IAAI,UAAUlB,EAAOmB,oCACtB,KAcX,OAFQF,QAAAC,IAAI,oCAAqCuK,GAE1CA,GAAmB,SACnB/K,GAGP,OAFQO,QAAAP,MAAM,2CAA4CA,GACxCmL,EAAA,6BAA+BnL,EAAM+G,SAChD,EAAC,GAQNyF,EAAyBA,KAC7B,OAAQrF,GACN,IAAK,IAAY,OAAA,EACjB,IAAK,IAAY,OAAA,EACjB,IAAK,IAIL,QAAgB,SAHhB,IAAK,IAAY,OAAA,EACjB,IAAK,IAAY,OAAA,EACjB,IAAK,KAAa,OAAA,GACF,EAQdsF,EAAmBA,KAEvB,IAAIC,EAAgBzF,EAChB,GAAW,MAAXE,GAAkBS,EACpB8E,EAAgBzF,EAAQmF,QAAiB9M,GAAAA,EAAOmB,OAASmH,QACpD,CAEL,MAAM+E,EAAaH,IACbI,EAAa1E,KAAK2E,KAAK5F,EAAQgE,OAAS0B,GAG1C,GAAA5E,GAAe6E,GAAcA,EAAa,EAE5C,MAAO,GAIT,MAAME,EAAW/E,EAAc4E,EACzBI,EAAS7E,KAAK8E,IAAIF,EAAWH,EAAY1F,EAAQgE,QACvCyB,EAAAzF,EAAQgG,MAAMH,EAAUC,EAAM,CAGzC,OAAAL,CAAA,EAMHlB,EAAkBA,KAClB,IAAClD,EAAa5H,QAAS,OAG3B,IAAIgM,EAAgBD,IAGpB,GAA6B,IAAzBC,EAAczB,QAAgBhE,EAAQgE,OAAS,EAAG,CACpD,MAAM0B,EAAaH,IACbI,EAAa1E,KAAK2E,KAAK5F,EAAQgE,OAAS0B,GAE9C,GAAI5E,GAAe6E,EAEjB,YADA5E,EAAeE,KAAKC,IAAI,EAAGyE,EAAa,GAE1C,CAIF,MAAMM,EAAqBR,EAAcf,KAAIrM,GAAUA,EAAOmB,OAG9DF,QAAQC,IAAI,gCAAgCuH,EAAc,sBAAuBmF,GAGjF,MAAMC,EAAuB5D,OAAOC,KAAK/J,EAAkBiB,SAAS0L,QACpD9I,IAAC4J,EAAmBE,SAAS9J,KAGzC6J,EAAqBlC,OAAS,IAChC1K,QAAQC,IAAI,eAAe2M,EAAqBlC,wDAAyDkC,GACzGA,EAAqB1D,SAAsBnG,IACzC1D,EAAoB0D,EAAU,IAC/B,EAWC3D,EAAyBA,CAACL,EAAQ+N,EAAcC,EAAeC,EAAY,MAC3E,IAACjO,IAAW+N,EAEd,YADA9M,QAAQP,MAAM,oEAKZP,EAAkBiB,QAAQpB,EAAOmB,QACnCF,QAAQC,IAAI,gCAAgClB,EAAOmB,0CACnDb,EAAoBN,EAAOmB,OAG7BF,QAAQC,IAAI,yCAAyClB,EAAOmB,QAGtD,MAAAiJ,EAAK,IAAI8D,kBAAkB,CAC/BC,WAAY,CACV,CAAEC,KAAM,iCAGVC,mBAAoB,MACpBC,aAAc,WACdC,cAAe,UACfC,aAAc,iBAIErO,EAAAiB,QAAQpB,EAAOmB,MAAQiJ,EAGtCA,EAAAqE,QAAWC,IACZzN,QAAQC,IAAI,6BAA6BlB,EAAOmB,QAASuN,GAChC,UAArBA,EAAMC,MAAMC,OACDb,EAAAc,UAAYH,EAAM/G,QAAQ,GAGvCoG,EAAae,aAAe,KAC1B7N,QAAQC,IAAI,gCAAgClB,EAAOmB,QAC/C8M,EAAU1M,cACZ0M,EAAU1M,cAAa,EAI3BwM,EAAagB,UAAY,KACvB9N,QAAQC,IAAI,4BAA4BlB,EAAOmB,QAC3C8M,EAAUzM,WACZyM,EAAUzM,YAIRxB,EAAOyB,2BAA6BzB,EAAO0B,iBAAmBsM,GAChE/M,QAAQC,IAAI,yCAAyClB,EAAOmB,kCAC5DQ,EAAsB3B,EAAOmB,KAAM6M,EAAeD,EAAc3N,EAAmBgB,UAEnFH,QAAQC,IAAI,oCAAoClB,EAAOmB,OAAM,EAIpD4M,EAAAiB,QAAWrL,IACtB1C,QAAQP,MAAM,0BAA0BV,EAAOmB,QAASwC,GACpDsK,EAAUrM,SACZqM,EAAUrM,QAAQ,uBAAsB,EAE5C,EAIDwI,EAAA6E,eAAkBP,IACfA,EAAMQ,WACRjO,QAAQC,IAAI,4BAA4BlB,EAAOmB,QAASuN,EAAMQ,UAAS,EAK3E9E,EAAG+E,2BAA6B,KAC9BlO,QAAQC,IAAI,mCAAmClB,EAAOmB,QAASiJ,EAAGG,oBAGpC,WAA1BH,EAAGG,oBACLtJ,QAAQuJ,KAAK,yBAAyBxK,EAAOmB,QACzC8M,EAAUrM,SACZqM,EAAUrM,QAAQ,iCAEe,iBAA1BwI,EAAGG,oBACZtJ,QAAQuJ,KAAK,+BAA+BxK,EAAOmB,OAAM,EAM7DiJ,EAAGgF,wBAA0B,KAC3BnO,QAAQC,IAAI,uCAAuClB,EAAOmB,QAASiJ,EAAGE,iBAE3C,WAAvBF,EAAGE,kBACLrJ,QAAQuJ,KAAK,gCAAgCxK,EAAOmB,QAChD8M,EAAUrM,SACZqM,EAAUrM,QAAQ,4BACpB,EAKJwI,EAAGiF,eAAe,QAAS,CAACC,UAAW,aACvClF,EAAGiF,eAAe,QAAS,CAACC,UAAW,aAGvC,MAMMC,EAAiBjO,YAAW,KAChCL,QAAQuJ,KAAK,qCAAqCxK,EAAOmB,QACrD8M,EAAUrM,SACZqM,EAAUrM,QAAQ,0BAIhBzB,EAAkBiB,QAAQpB,EAAOmB,OACnCb,EAAoBN,EAAOmB,KAAI,GAEhC,KAGGqO,EAAyBlO,YAAW,KAEpCnB,EAAkBiB,QAAQpB,EAAOmB,SAC/B4M,EAAac,WAAad,EAAa0B,WAAa,KACxDxO,QAAQuJ,KAAK,uCAAuCxK,EAAOmB,QACvD8M,EAAUrM,SACZqM,EAAUrM,QAAQ,4BACpB,GAED,KAGG8N,EAAwBA,IACrBvP,EAAkBiB,QAAQpB,EAAOmB,QAAUiJ,EAGpDA,EAAGuF,YAnCkB,CACnBC,qBAAqB,EACrBC,qBAAqB,IAkCpBC,MAAcC,IACT,IAACL,IACG,MAAI,IAAAvI,MAAM,mDAGX,OADPlG,QAAQC,IAAI,4BAA4BlB,EAAOmB,QACxCiJ,EAAG4F,oBAAoBD,EAAK,IAEpCD,MAAK,KACA,IAACJ,IACG,MAAI,IAAAvI,MAAM,6DAIlB,OAFAlG,QAAQC,IAAI,oCAAoClB,EAAOmB,QAEhD8O,EAAUjQ,EAAOmB,KAAMiJ,EAAG8F,iBAAgB,IAElDJ,MAAeK,IACV,IAACT,IACG,MAAI,IAAAvI,MAAM,oDAIlB,OAFAlG,QAAQC,IAAI,8BAA8BlB,EAAOmB,QAE1CiJ,EAAGgG,qBAAqB,IAAIC,sBAAsBF,GAAO,IAEjEL,MAAK,KACA,IAACJ,IACG,MAAA,IAAIvI,MAAM,8DAElBlG,QAAQC,IAAI,qCAAqClB,EAAOmB,QAGxDW,aAAayN,GACbzN,aAAa0N,EAAsB,IAEpCc,OAAe5P,IAEdoB,aAAayN,GACbzN,aAAa0N,GAGTE,KACFzO,QAAQP,MAAM,sCAAsCV,EAAOmB,QAAST,GAChEuN,EAAUrM,SACFqM,EAAArM,QAAQlB,EAAM+G,UAG1BxG,QAAQC,IAAI,2BAA2BlB,EAAOmB,uBAAuBT,EAAM+G,UAAS,IAK7EsG,EAAAjE,iBAAiB,WAAW,KACvChI,aAAa0N,EAAsB,GAClC,CAAEe,MAAM,GAAM,EASbN,EAAYO,GAAYtK,MAAOlC,EAAY+L,KAC3C,IAEF,MAAMU,EAAiB,CACrBC,KAAMX,EAAMW,KACZC,IAAKZ,EAAMY,KAGL1P,QAAAC,IAAI,sCAAsC8C,KAG5C,MAAA4M,EAAkB,IAAIC,gBACtB5J,EAAS2J,EAAgB3J,OAG3B,IAAA9G,EAAkBiB,QAAQ4C,GAM5B,OAFQ/C,QAAAC,IAAI,yBAAyB8C,sCACrC4M,EAAgBE,QACTlE,QAAQmE,OAAO,IAAI5J,MAAM,gCALdhH,EAAAiB,QAAQ4C,GAAY4M,gBAAkBA,EASpD,MAAAI,QAAejL,EAAoBkL,YAAY,IAChDR,EACHzM,aACAiD,WAIE,OAAA9G,EAAkBiB,QAAQ4C,GACrBgN,GAGC/P,QAAAC,IAAI,yBAAyB8C,mDAC9B4I,QAAQmE,OAAO,IAAI5J,MAAM,kDAE3BzG,GAEH,GAAe,eAAfA,EAAMS,KAGR,OAFQF,QAAAC,IAAI,mCAAmC8C,iBAExC4I,QAAQmE,OAAO,IAAI5J,MAAM,oBAI5B,MADNlG,QAAQP,MAAM,kCAAkCsD,KAAetD,GACzDA,CAAA,IAEP,CAACqF,IAyJEzF,EAAuB0D,IAIvB,GAHI/C,QAAAC,IAAI,wCAAwC8C,KAGhD7D,EAAkBiB,QAAQ4C,GAAa,CAEnC,MAAAkN,EAAa/Q,EAAkBiB,QAAQ4C,GAG7C,GAAIkN,EAAWN,gBAAiB,CACtB3P,QAAAC,IAAI,+CAA+C8C,KACvD,IACFkN,EAAWN,gBAAgBE,cACpBnN,GACP1C,QAAQP,MAAM,4CAA4CsD,KAAeL,EAAC,CAC5E,CAIEuN,EAAWjC,iBAAgBiC,EAAWjC,eAAiB,MACvDiC,EAAW/B,6BAA4B+B,EAAW/B,2BAA6B,MAC/E+B,EAAW9B,0BAAyB8B,EAAW9B,wBAA0B,MACzE8B,EAAWzC,UAASyC,EAAWzC,QAAU,MAG7CyC,EAAWC,eAGJhR,EAAkBiB,QAAQ4C,GAEzB/C,QAAAC,IAAI,uCAAuC8C,IAAY,CAIzCoN,EAAApN,EAAY5D,EAAmBgB,QAAO,EAM1DyJ,EAAuBA,KAC3B5J,QAAQC,IAAI,+BAEZ+I,OAAOC,KAAK/J,EAAkBiB,SAAS+I,SAAsBnG,IAC3D1D,EAAoB0D,EAAU,IAEhC/C,QAAQC,IAAI,6BAA4B,EAUpCmQ,EAAyBA,CAACrN,EAAY0K,KAO1C,GALIA,IACFA,EAAM4C,iBACN5C,EAAM6C,oBAGHvN,EAEH,YADA/C,QAAQP,MAAM,kDAIRO,QAAAC,IAAI,mCAAmC8C,KAC/C,MAAMwN,EAAiB,SAASxN,EAAW1B,QAAQ,OAAQ,OACrDyL,EAAetO,SAASgS,eAAeD,GACvCE,EAAY3D,EAAeA,EAAa4D,QAAQ,eAAiB,KAElED,EAKAjS,SAASmS,mBAOZ3Q,QAAQC,IAAI,2BACZzB,SAASoS,mBAPT5Q,QAAQC,IAAI,2CACFwQ,EAAAI,oBAAoBxB,OAAayB,IACzC9Q,QAAQP,MAAM,0CAA0CqR,EAAItK,WAC1CoE,EAAA,qCAAqCkG,EAAItK,UAAS,KAR9DxG,QAAAP,MAAM,oBAAqBsD,EAYX,EAK1B,OAAAjC,EAAC,WAAQE,GAAG,YAAYD,UAAW,SAAQ2D,EAAe,kBAAoB,IAE5EvD,SAAA,CAAAC,EAAC2P,EAAgB,IAEhB3P,EAAA4P,EAAA,CAAkBtM,eAA4BC,kBAAkCsM,SAAS,cAC1FnQ,EAAC,MAAI,CAAAC,UAAU,qGACbI,SAAA,CAACL,EAAA,MAAA,CAAIC,UAAU,8BACbI,SAAA,CAACC,EAAA,KAAA,CAAGL,UAAU,yBAAyBI,SAAS,cAChDC,EAAC,MAAI,CAAAL,UAAU,iBACbI,SAAAC,EAAC,SAAA,CACCJ,GAAG,iBACHD,UAAU,6LACVkC,QAASA,IAAM+D,OAAOC,SAASiK,KAAO,YACvC/P,SAAA,kBAKLL,EAAC,MAAI,CAAAC,UAAU,uCACbI,SAAA,CAACL,EAAA,MAAA,CAAIC,UAAU,oBACbI,SAAA,CAAAC,EAAC,QAAM,CAAA+P,IAAI,kBAAkBpQ,UAAU,OAAOI,SAAO,YACrDL,EAAC,SAAA,CACGE,GAAG,kBACHD,UAAU,2JACVqQ,MAAOxK,EACPyK,SAAW3O,IACH,MAAA4O,EAAY5O,EAAE6O,OAAOH,MAC3BvK,EAAUyK,GACV7J,EAAe,EAAC,EAIpBtG,SAAA,CAACC,EAAA,SAAA,CAAOgQ,MAAM,IAAIjQ,SAAQ,aACzBC,EAAA,SAAA,CAAOgQ,MAAM,IAAIjQ,SAAS,gBAC1B,SAAO,CAAAiQ,MAAM,IAAII,UAAQ,EAACrQ,SAAS,cACnCC,EAAA,SAAA,CAAOgQ,MAAM,IAAIjQ,SAAS,cAC1BC,EAAA,SAAA,CAAOgQ,MAAM,IAAIjQ,SAAS,cAC1BC,EAAA,SAAA,CAAOgQ,MAAM,KAAKjQ,SAAU,qBAIrB,MAAXyF,GACI9F,EAAA,MAAA,CAAIC,UAAU,oBACbI,SAAA,CAAAC,EAAC,QAAM,CAAA+P,IAAI,kBAAkBpQ,UAAU,OAAOI,SAAO,YACrDC,EAAC,SAAA,CACGJ,GAAG,kBACHD,UAAU,2JACVqQ,MAAO/J,EACPgK,SAAW3O,IACH,MAAA+O,EAAY/O,EAAE6O,OAAOH,MAC3B9J,EAAkBmK,EAAS,EAI9BtQ,SAAQuF,EAAA0E,KAAIrM,KACR,SAAyB,CAAAqS,MAAOrS,EAAOmB,KAAOiB,SAAApC,EAAOmB,MAAzCnB,EAAOmB,aAMhCkB,EAAC,SAAA,CACGJ,GAAG,iBACHD,UAAU,4GACVkC,QAASA,IAAM2B,IACf5B,MAAM,oBAER7B,SAAAC,EAAC,MAAA,CAAIgC,MAAM,6BAA6B1B,MAAM,KAAKC,OAAO,KAAK0B,QAAQ,YAAYC,KAAK,OACnFC,OAAO,eAAe,eAAa,IAAI,iBAAe,QAAQ,kBAAgB,QACjFpC,SAAAC,EAAC,OAAA,CACGoC,EAAE,4GAMd1C,EAAC,MAAI,CAAAC,UAAU,0BACbI,SAAA,CAAAC,EAAC,MAAA,CACGJ,GAAG,aACHD,UAAW,0BAA0B6F,IACrC3F,IAAK8G,EAEN5G,SAAA6I,GAQI1K,IAAc0K,IAPd,MAAI,CAAAjJ,UAAU,2EACbI,SAACL,EAAA,MAAA,CAAIC,UAAU,iDACbI,SAAA,CAAAC,EAAC,MAAA,CACGL,UAAU,4IACbK,EAAA,IAAA,CAAEL,UAAU,wCAAwCI,SAAkB,4BAW1E8I,EACFnJ,EAAA,MAAA,CAAIC,UAAU,mJACbI,SAAA,CAACL,EAAA,IAAA,CAAEC,UAAU,gDAAgDI,SAAA,CAAA,0BAAwB8I,EAAazD,WAClGpF,EAAC,SAAA,CACC6B,QAASA,IAAM+D,OAAOC,SAASyK,SAC/B3Q,UAAU,2FACXI,SAAA,aAIkB,IAAnBuF,EAAQgE,OACT5J,EAAA,MAAA,CAAIC,UAAU,mJACbI,SAAA,CAACC,EAAA,IAAA,CAAEL,UAAU,gDAAgDI,SAAqB,4BACjF,IAAE,CAAA+P,KAAK,eAAenQ,UAAU,2FAA2FI,SAAiB,yBAI/I+K,IAAmBd,KACjBrM,GAAAqC,EAACtC,EAAA,CAECC,SACAC,eAAgBwF,EAChBvF,mBAAoBmR,EACpBlR,oBACAC,qBACAC,yBACAC,uBAPKN,EAAOmB,UAaR,MAAX0G,GAAkBF,EAAQgE,OAASuB,IAClCnL,EAAC,MAAI,CAAAC,UAAU,sEACbI,SAAA,CAAAC,EAAC,SAAA,CACCL,UAAU,0OACVkC,QAASA,KACPjD,QAAQC,IAAI,6BACZwH,EAAeE,KAAKC,IAAI,EAAGJ,EAAc,IAGzC,MAAMW,EAAM,IAAIC,IAAIpB,OAAOC,UACrB0K,EAAUnK,EAAc,EAE1BmK,EAAU,GACZxJ,EAAIE,aAAaC,IAAI,OAAQqJ,EAAU,GACvCvK,eAAesB,QAAQ,uBAAwBiJ,EAAU,GAAGhJ,cAExDR,EAAAE,aAAaE,OAAO,QACxBnB,eAAewB,WAAW,wBAG5B5B,OAAOwB,QAAQC,aAAa,CAAA,EAAI,GAAIN,EAAG,EAEzCyJ,SAA0B,IAAhBpK,EACXrG,SAAA,aAIDL,EAAC,OAAK,CAAAC,UAAU,mCAAmCI,SAAA,CAAA,QAC3CqG,EAAc,EAAE,OAAKG,KAAK2E,KAAK5F,EAAQgE,OAASuB,QAGxD7K,EAAC,SAAA,CACCL,UAAU,0OACVkC,QAASA,KACPjD,QAAQC,IAAI,yBACZ,MAAM0R,EAAUhK,KAAK8E,IAAI9E,KAAK2E,KAAK5F,EAAQgE,OAASuB,KAA4B,EAAGzE,EAAc,GACjGC,EAAekK,GAGf,MAAMxJ,EAAM,IAAIC,IAAIpB,OAAOC,UAC3BkB,EAAIE,aAAaC,IAAI,OAAQqJ,EAAU,GACvCvK,eAAesB,QAAQ,uBAAwBiJ,EAAU,GAAGhJ,YAE5D3B,OAAOwB,QAAQC,aAAa,CAAA,EAAI,GAAIN,EAAG,EAEzCyJ,SAAUpK,GAAeG,KAAK2E,KAAK5F,EAAQgE,OAASuB,KAA4B,EACjF9K,SAAA,YAID,UAIZ,CClpCA,SAAS0Q,IACL,MAAOC,EAAkBC,GAAuBvS,GAAS,IAClDF,EAAWC,GAAgBC,GAAS,GAgC3C,OA9BAO,GAAU,MAENkF,iBACQ,IACM,MAAAM,QAAiBC,MAAM,iBACzB,IAACD,EAASU,GAGV,OAFAjG,QAAQP,MAAM,4BAA6B8F,EAASY,OAAQZ,EAASa,iBACrE7G,GAAa,UAIMgG,EAASiG,QAEnBwG,iBACThS,QAAQC,IAAI,sCACZ8R,GAAoB,KAEpB/R,QAAQC,IAAI,wCACZ8R,GAAoB,UAEnBtS,GACGO,QAAAP,MAAM,gCAAiCA,EAAK,CACtD,QACEF,GAAa,EAAK,CACtB,CAGc0S,EAAA,GACnB,IAEC3S,EACQ8B,EAAA,MAAA,CAAIL,UAAU,UAAUI,SAAU,eAKtCL,EAAAoR,EAAA,CAAA/Q,SAAA,CAAAC,EAAC+Q,EAAO,MACPC,EAAe,IACfN,EAAoB1Q,EAAAiR,EAAA,CAASP,kBAAkB,MAAYvN,EAAW,MACtE+N,EAAO,CAAA,KAGpB,CAGA9T,SAASqK,iBAAiB,oBAAoB,KAEpC,MAAA0J,EAAY/T,SAASgS,eAAe,gBAEtC+B,GACAC,IACKC,EAAoB,CAAAC,OAAQ7I,EACzB1I,SAAAC,EAACyQ,GAAI,KAETU,EACJ"}