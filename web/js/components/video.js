/**
 * LightNVR Web Interface Video Player
 * Contains functionality for video playback, layout, fullscreen
 */

/**
 * Update video grid with streams
 */
function updateVideoGrid(streams) {
    const videoGrid = document.getElementById('video-grid');
    if (!videoGrid) return;

    // Clear existing content
    videoGrid.innerHTML = '';

    if (!streams || streams.length === 0) {
        const placeholder = document.createElement('div');
        placeholder.className = 'placeholder';
        placeholder.innerHTML = `
            <p>No streams configured</p>
            <a href="/streams" class="btn">Configure Streams</a>
        `;
        videoGrid.appendChild(placeholder);
        return;
    }

    // Get layout
    const layout = document.getElementById('layout-selector').value;

    // Update video layout
    updateVideoLayout(layout);

    // Add video elements for each stream
    streams.forEach(stream => {
        // Ensure we have an ID for the stream (use name as fallback if needed)
        const streamId = stream.id || stream.name;

        const videoContainer = document.createElement('div');
        videoContainer.className = 'video-item';

        videoContainer.innerHTML = `
            <div class="video-header">
                <span>${stream.name}</span>
                <div class="video-controls">
                    <button class="btn-small snapshot" data-id="${streamId}" data-name="${stream.name}">Snapshot</button>
                    <button class="btn-small fullscreen" data-id="${streamId}" data-name="${stream.name}">Fullscreen</button>
                </div>
            </div>
            <div class="video-player" id="player-${stream.name.replace(/\s+/g, '-')}">
                <video id="video-${stream.name.replace(/\s+/g, '-')}" autoplay muted></video>
                <div class="loading-overlay">
                    <div class="spinner"></div>
                    <p>Connecting to stream...</p>
                </div>
            </div>
        `;

        videoGrid.appendChild(videoContainer);
    });

    // Initialize video players and add event listeners
    streams.forEach(stream => {
        initializeVideoPlayer(stream);

        // Ensure we have an ID for the stream (use name as fallback if needed)
        const streamId = stream.id || stream.name;

        // Add event listener for snapshot button
        const snapshotBtn = videoGrid.querySelector(`.snapshot[data-id="${streamId}"]`);
        if (snapshotBtn) {
            snapshotBtn.addEventListener('click', () => {
                console.log('Taking snapshot of stream with ID:', streamId);
                takeSnapshot(streamId);
            });
        }

        // Add event listener for fullscreen button
        const fullscreenBtn = videoGrid.querySelector(`.fullscreen[data-id="${streamId}"]`);
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', () => {
                console.log('Toggling fullscreen for stream with ID:', streamId);
                toggleStreamFullscreen(stream.name);
            });
        }
    });
}

/**
 * Update video layout
 */
function updateVideoLayout(layout) {
    const videoGrid = document.getElementById('video-grid');
    if (!videoGrid) return;

    // Set grid columns based on layout
    if (layout === '1') {
        videoGrid.style.gridTemplateColumns = '1fr';
    } else if (layout === '4') {
        videoGrid.style.gridTemplateColumns = 'repeat(2, 1fr)';
    } else if (layout === '9') {
        videoGrid.style.gridTemplateColumns = 'repeat(3, 1fr)';
    } else if (layout === '16') {
        videoGrid.style.gridTemplateColumns = 'repeat(4, 1fr)';
    }
}

/**
 * Initialize video player for a stream using HLS.js
 */
function initializeVideoPlayer(stream) {
    const videoElementId = `video-${stream.name.replace(/\s+/g, '-')}`;
    const videoElement = document.getElementById(videoElementId);
    const containerId = `player-${stream.name.replace(/\s+/g, '-')}`;
    const container = document.getElementById(containerId);

    if (!videoElement || !container) return;

    // Show loading state
    container.classList.add('loading');

    // Build the HLS stream URL - this would be generated by your backend
    // Your backend needs to convert RTSP to HLS using FFmpeg
    const hlsStreamUrl = `/api/streaming/${encodeURIComponent(stream.name)}/hls/index.m3u8`;

    // Check if HLS is supported natively
    if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
        // Native HLS support (Safari)
        videoElement.src = hlsStreamUrl;
        videoElement.addEventListener('loadedmetadata', function() {
            container.classList.remove('loading');
        });

        videoElement.addEventListener('error', function() {
            handleVideoError(stream.name);
        });
    }
    // Use HLS.js for browsers that don't support HLS natively
    else if (Hls && Hls.isSupported()) {
        const hls = new Hls({
            maxBufferLength: 30,
            maxMaxBufferLength: 60,
            liveSyncDurationCount: 3,
            enableWorker: true
        });

        hls.loadSource(hlsStreamUrl);
        hls.attachMedia(videoElement);

        hls.on(Hls.Events.MANIFEST_PARSED, function() {
            container.classList.remove('loading');
            videoElement.play().catch(error => {
                console.warn('Auto-play prevented:', error);
                // Add play button overlay for user interaction
                addPlayButtonOverlay(container, videoElement);
            });
        });

        hls.on(Hls.Events.ERROR, function(event, data) {
            if (data.fatal) {
                console.error('HLS error:', data);
                hls.destroy();
                handleVideoError(stream.name);
            }
        });

        // Store hls instance for cleanup
        container.hlsPlayer = hls;
    }
    // Fallback for unsupported browsers
    else {
        handleVideoError(stream.name, 'HLS not supported by your browser');
    }
}

/**
 * Add play button overlay for browsers that block autoplay
 */
function addPlayButtonOverlay(container, videoElement) {
    const playOverlay = document.createElement('div');
    playOverlay.className = 'play-overlay';
    playOverlay.innerHTML = '<div class="play-button"></div>';
    container.appendChild(playOverlay);

    playOverlay.addEventListener('click', function() {
        videoElement.play()
            .then(() => {
                playOverlay.remove();
            })
            .catch(error => {
                console.error('Play failed:', error);
            });
    });
}

/**
 * Handle video player errors
 */
function handleVideoError(streamName, message) {
    const containerId = `player-${streamName.replace(/\s+/g, '-')}`;
    const container = document.getElementById(containerId);

    if (!container) return;

    container.classList.remove('loading');
    container.classList.add('error');

    const errorMessage = document.createElement('div');
    errorMessage.className = 'error-message';
    errorMessage.innerHTML = `
        <div class="error-icon">!</div>
        <p>${message || 'Stream connection failed'}</p>
        <button class="retry-button">Retry</button>
    `;

    // Remove any existing error message
    const existingError = container.querySelector('.error-message');
    if (existingError) {
        existingError.remove();
    }

    container.appendChild(errorMessage);

    // Add retry button handler
    const retryButton = errorMessage.querySelector('.retry-button');
    if (retryButton) {
        retryButton.addEventListener('click', function() {
            // Fetch stream info again and reinitialize
            fetch(`/api/streams/${encodeURIComponent(streamName)}`)
                .then(response => response.json())
                .then(streamInfo => {
                    // Remove error message
                    errorMessage.remove();
                    container.classList.remove('error');

                    // Cleanup existing player if any
                    cleanupVideoPlayer(streamName);

                    // Reinitialize
                    initializeVideoPlayer(streamInfo);
                })
                .catch(error => {
                    console.error('Error fetching stream info:', error);
                    alert('Could not reconnect to stream: ' + error.message);
                });
        });
    }
}

/**
 * Cleanup video player resources when switching pages or streams
 */
function cleanupVideoPlayer(streamName) {
    const containerId = `player-${streamName.replace(/\s+/g, '-')}`;
    const container = document.getElementById(containerId);

    if (!container) return;

    // Destroy HLS instance if exists
    if (container.hlsPlayer) {
        container.hlsPlayer.destroy();
        delete container.hlsPlayer;
    }

    // Reset video element
    const videoElementId = `video-${streamName.replace(/\s+/g, '-')}`;
    const videoElement = document.getElementById(videoElementId);

    if (videoElement) {
        videoElement.pause();
        videoElement.removeAttribute('src');
        videoElement.load();
    }

    // Reset container state
    container.classList.remove('loading', 'error');

    // Remove error message if any
    const errorMessage = container.querySelector('.error-message');
    if (errorMessage) {
        errorMessage.remove();
    }

    // Remove play overlay if any
    const playOverlay = container.querySelector('.play-overlay');
    if (playOverlay) {
        playOverlay.remove();
    }
}

/**
 * Toggle fullscreen for a specific stream
 */
function toggleStreamFullscreen(streamName) {
    const containerId = `player-${streamName.replace(/\s+/g, '-')}`;
    const container = document.getElementById(containerId);

    if (!container) {
        alert('Stream not found');
        return;
    }

    if (!document.fullscreenElement) {
        container.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable fullscreen: ${err.message}`);
            alert(`Could not enable fullscreen mode: ${err.message}`);
        });
    } else {
        document.exitFullscreen();
    }
}

/**
 * Toggle fullscreen mode for the entire video grid
 */
function toggleFullscreen() {
    const videoGrid = document.getElementById('video-grid');
    if (!videoGrid) return;

    if (!document.fullscreenElement) {
        videoGrid.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable fullscreen: ${err.message}`);
        });
    } else {
        document.exitFullscreen();
    }
}

/**
 * Play recording - Ultra-simplified direct implementation
 */
function playRecording(recordingId) {
    const videoModal = document.getElementById('video-modal');
    const videoPlayer = document.getElementById('video-player');
    const videoTitle = document.getElementById('video-modal-title');
    const videoCloseBtn = document.getElementById('video-close-btn');
    const modalCloseBtn = videoModal?.querySelector('.close');

    if (!videoModal || !videoPlayer || !videoTitle) {
        console.error('Video modal elements not found');
        return;
    }

    // Set up close button event handlers
    if (videoCloseBtn) {
        videoCloseBtn.onclick = function() {
            closeVideoModal();
        };
    }
    
    if (modalCloseBtn) {
        modalCloseBtn.onclick = function() {
            closeVideoModal();
        };
    }

    // Show loading state
    videoModal.classList.add('loading');
    videoModal.style.display = 'block';

    // Fetch recording details
    fetch(`/api/recordings/${recordingId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to load recording details');
            }
            return response.json();
        })
        .then(recording => {
            console.log('Recording details:', recording);

            // Set video title
            videoTitle.textContent = `${recording.stream} - ${recording.start_time}`;

            // Base URLs for video
            const videoUrl = `/api/recordings/download/${recordingId}`;
            const downloadUrl = `${videoUrl}?download=1`;

            console.log('Video URL:', videoUrl);
            console.log('Download URL:', downloadUrl);

            // Reset video player
            videoPlayer.innerHTML = '';
            videoPlayer.controls = true;

            // Determine if HLS or MP4
            if (recording.path.endsWith('.m3u8')) {
                if (Hls.isSupported()) {
                    let hls = new Hls();
                    hls.loadSource(videoUrl);
                    hls.attachMedia(videoPlayer);
                    hls.on(Hls.Events.MANIFEST_PARSED, function () {
                        videoPlayer.play();
                    });
                } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                    videoPlayer.src = videoUrl;
                    videoPlayer.play();
                } else {
                    console.error('HLS not supported');
                    videoPlayer.innerHTML = `
                        <p>HLS playback is not supported in this browser.</p>
                        <a href="${downloadUrl}" class="btn btn-primary" download>Download Video</a>
                    `;
                }
            } else {
                // Standard MP4 playback
                videoPlayer.src = videoUrl;
                videoPlayer.play();
            }

            // Update download button
            const downloadBtn = document.getElementById('video-download-btn');
            if (downloadBtn) {
                downloadBtn.onclick = function(e) {
                    e.preventDefault();
                    const link = document.createElement('a');
                    link.href = downloadUrl;
                    link.download = '';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    return false;
                };
            }

            // Remove loading state
            videoModal.classList.remove('loading');
        })
        .catch(error => {
            console.error('Error loading recording:', error);
            videoModal.classList.remove('loading');
            videoPlayer.innerHTML = `
                <div style="height:70vh;display:flex;flex-direction:column;justify-content:center;align-items:center;background:#000;color:#fff;padding:20px;text-align:center;">
                    <p style="font-size:18px;margin-bottom:10px;">Error: ${error.message}</p>
                    <p style="margin-bottom:20px;">Cannot load the recording.</p>
                    <a href="/api/recordings/download/${recordingId}?download=1" class="btn btn-primary" download>Download Video</a>
                </div>
            `;
        });
}
