// This file provides implementations of the HLS API functions

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include "web/mongoose_adapter.h"
#include "core/logger.h"
#include "core/config.h"
#include "web/http_server.h"
#include "video/streams.h"

// Forward declarations
void mg_handle_direct_hls_request(struct mg_connection *c, struct mg_http_message *hm);

void mg_handle_hls_master_playlist(struct mg_connection *c, struct mg_http_message *hm) {
    log_info("HLS API: Handling master playlist request directly");
    
    // Extract stream name from URI
    // URI format: /api/streaming/{stream_name}/hls/index.m3u8
    char uri[MAX_PATH_LENGTH];
    size_t uri_len = hm->uri.len < sizeof(uri) - 1 ? hm->uri.len : sizeof(uri) - 1;
    memcpy(uri, hm->uri.buf, uri_len);
    uri[uri_len] = '\0';
    
    // Parse the URI to extract stream name
    char stream_name[MAX_STREAM_NAME] = {0};
    if (sscanf(uri, "/api/streaming/%[^/]/hls/", stream_name) != 1) {
        log_error("Failed to extract stream name from URI: %s", uri);
        mg_http_reply(c, 400, "", "{\"error\": \"Invalid URI format\"}\n");
        return;
    }
    
    // Get the config to find the storage path
    config_t *global_config = get_streaming_config();
    
    // Construct the full path to the HLS file
    char hls_file_path[MAX_PATH_LENGTH * 2]; // Double the buffer size to avoid truncation
    
    // Use storage_path_hls if specified, otherwise fall back to storage_path
    if (global_config->storage_path_hls[0] != '\0') {
        snprintf(hls_file_path, sizeof(hls_file_path), "%s/hls/%s/index.m3u8", 
                global_config->storage_path_hls, stream_name);
        log_info("Using HLS-specific storage path: %s", global_config->storage_path_hls);
    } else {
        snprintf(hls_file_path, sizeof(hls_file_path), "%s/hls/%s/index.m3u8", 
                global_config->storage_path, stream_name);
        log_info("Using default storage path for HLS: %s", global_config->storage_path);
    }
    
    log_info("Serving HLS master playlist directly: %s", hls_file_path);
    
    // Check if file exists
    struct stat st;
    if (stat(hls_file_path, &st) == 0 && S_ISREG(st.st_mode)) {
        // Serve the file with appropriate headers
        const char *headers = 
            "Content-Type: application/vnd.apple.mpegurl\r\n"
            "Cache-Control: max-age=2\r\n"
            "Connection: close\r\n"
            "Access-Control-Allow-Origin: *\r\n"
            "Access-Control-Allow-Methods: GET, OPTIONS\r\n"
            "Access-Control-Allow-Headers: Origin, Content-Type, Accept, Authorization\r\n";
        
        mg_http_serve_file(c, hm, hls_file_path, &(struct mg_http_serve_opts){
            .mime_types = "",
            .extra_headers = headers
        });
    } else {
        // File doesn't exist - let the client know
        log_info("HLS master playlist not found: %s (waiting for FFmpeg to create it)", hls_file_path);
        
        // Return a 404 with a message that indicates the file is being generated
        mg_http_reply(c, 404, "", "{\"error\": \"HLS master playlist not found or still being generated by FFmpeg\"}\n");
    }
}

void mg_handle_hls_media_playlist(struct mg_connection *c, struct mg_http_message *hm) {
    log_info("HLS API: Handling media playlist request directly");
    
    // Extract stream name from URI
    // URI format: /api/streaming/{stream_name}/hls/stream.m3u8
    char uri[MAX_PATH_LENGTH];
    size_t uri_len = hm->uri.len < sizeof(uri) - 1 ? hm->uri.len : sizeof(uri) - 1;
    memcpy(uri, hm->uri.buf, uri_len);
    uri[uri_len] = '\0';
    
    // Parse the URI to extract stream name
    char stream_name[MAX_STREAM_NAME] = {0};
    if (sscanf(uri, "/api/streaming/%[^/]/hls/", stream_name) != 1) {
        log_error("Failed to extract stream name from URI: %s", uri);
        mg_http_reply(c, 400, "", "{\"error\": \"Invalid URI format\"}\n");
        return;
    }
    
    // Get the config to find the storage path
    config_t *global_config = get_streaming_config();
    
    // Construct the full path to the HLS file
    char hls_file_path[MAX_PATH_LENGTH * 2]; // Double the buffer size to avoid truncation
    
    // Use storage_path_hls if specified, otherwise fall back to storage_path
    if (global_config->storage_path_hls[0] != '\0') {
        snprintf(hls_file_path, sizeof(hls_file_path), "%s/hls/%s/stream.m3u8", 
                global_config->storage_path_hls, stream_name);
        log_info("Using HLS-specific storage path: %s", global_config->storage_path_hls);
    } else {
        snprintf(hls_file_path, sizeof(hls_file_path), "%s/hls/%s/stream.m3u8", 
                global_config->storage_path, stream_name);
        log_info("Using default storage path for HLS: %s", global_config->storage_path);
    }
    
    log_info("Serving HLS media playlist directly: %s", hls_file_path);
    
    // Check if file exists
    struct stat st;
    if (stat(hls_file_path, &st) == 0 && S_ISREG(st.st_mode)) {
        // Serve the file with appropriate headers
        const char *headers = 
            "Content-Type: application/vnd.apple.mpegurl\r\n"
            "Cache-Control: max-age=2\r\n"
            "Connection: close\r\n"
            "Access-Control-Allow-Origin: *\r\n"
            "Access-Control-Allow-Methods: GET, OPTIONS\r\n"
            "Access-Control-Allow-Headers: Origin, Content-Type, Accept, Authorization\r\n";
        
        mg_http_serve_file(c, hm, hls_file_path, &(struct mg_http_serve_opts){
            .mime_types = "",
            .extra_headers = headers
        });
    } else {
        // File doesn't exist - let the client know
        log_info("HLS media playlist not found: %s (waiting for FFmpeg to create it)", hls_file_path);
        
        // Return a 404 with a message that indicates the file is being generated
        mg_http_reply(c, 404, "", "{\"error\": \"HLS media playlist not found or still being generated by FFmpeg\"}\n");
    }
}

void mg_handle_direct_hls_request(struct mg_connection *c, struct mg_http_message *hm) {
    log_info("HLS API: Handling direct HLS request");
    
    // Extract URI
    char uri[MAX_PATH_LENGTH];
    size_t uri_len = hm->uri.len < sizeof(uri) - 1 ? hm->uri.len : sizeof(uri) - 1;
    memcpy(uri, hm->uri.buf, uri_len);
    uri[uri_len] = '\0';
    
    // Extract stream name from URI
    // URI format: /hls/{stream_name}/{file}
    char stream_name[MAX_STREAM_NAME] = {0};
    const char *stream_start = uri + 5; // Skip "/hls/"
    const char *file_part = strchr(stream_start, '/');
    
    if (!file_part) {
        log_error("Failed to extract stream name from URI: %s", uri);
        mg_http_reply(c, 400, "", "{\"error\": \"Invalid HLS path\"}\n");
        return;
    }
    
    // Extract stream name
    size_t name_len = file_part - stream_start;
    if (name_len >= MAX_STREAM_NAME) {
        name_len = MAX_STREAM_NAME - 1;
    }
    strncpy(stream_name, stream_start, name_len);
    stream_name[name_len] = '\0';
    
    // Extract file name (everything after the stream name)
    const char *file_name = file_part + 1; // Skip "/"
    
    // Get the config to find the storage path
    config_t *global_config = get_streaming_config();
    
    // Construct the full path to the HLS file
    char hls_file_path[MAX_PATH_LENGTH * 2]; // Double the buffer size to avoid truncation
    
    // Use storage_path_hls if specified, otherwise fall back to storage_path
    if (global_config->storage_path_hls[0] != '\0') {
        snprintf(hls_file_path, sizeof(hls_file_path), "%s/hls/%s/%s", 
                global_config->storage_path_hls, stream_name, file_name);
        log_info("Using HLS-specific storage path: %s", global_config->storage_path_hls);
    } else {
        snprintf(hls_file_path, sizeof(hls_file_path), "%s/hls/%s/%s", 
                global_config->storage_path, stream_name, file_name);
        log_info("Using default storage path for HLS: %s", global_config->storage_path);
    }
    
    log_info("Serving HLS file directly: %s", hls_file_path);
    
    // Check if file exists
    struct stat st;
    if (stat(hls_file_path, &st) == 0 && S_ISREG(st.st_mode)) {
        // Determine content type based on file extension
        const char *content_type_header = "Content-Type: application/octet-stream\r\n";
        if (strstr(file_name, ".m3u8")) {
            content_type_header = "Content-Type: application/vnd.apple.mpegurl\r\n";
        } else if (strstr(file_name, ".ts")) {
            content_type_header = "Content-Type: video/mp2t\r\n";
        } else if (strstr(file_name, ".m4s")) {
            content_type_header = "Content-Type: video/iso.segment\r\n";
        } else if (strstr(file_name, "init.mp4")) {
            content_type_header = "Content-Type: video/mp4\r\n";
        }
        
        // Use more mobile-friendly cache headers with longer cache times
        char headers[512];
        
        // Different cache settings for different file types
        const char* cache_control;
        if (strstr(file_name, ".m3u8")) {
            // For playlist files, use a shorter cache time to ensure updates are seen
            cache_control = "Cache-Control: max-age=2\r\n";
        } else if (strstr(file_name, ".ts") || strstr(file_name, ".m4s")) {
            // For media segments, use a longer cache time to improve mobile performance
            cache_control = "Cache-Control: max-age=60\r\n";
        } else if (strstr(file_name, "init.mp4")) {
            // For initialization segments, use a longer cache time
            cache_control = "Cache-Control: max-age=3600\r\n";
        } else {
            // Default cache time
            cache_control = "Cache-Control: max-age=5\r\n";
        }
        
        snprintf(headers, sizeof(headers),
            "%s"
            "%s"  // Dynamic cache control based on file type
            "Connection: close\r\n"
            "Access-Control-Allow-Origin: *\r\n"
            "Access-Control-Allow-Methods: GET, OPTIONS\r\n"
            "Access-Control-Allow-Headers: Origin, Content-Type, Accept, Authorization\r\n",
            content_type_header, cache_control);
        
        mg_http_serve_file(c, hm, hls_file_path, &(struct mg_http_serve_opts){
            .mime_types = "",
            .extra_headers = headers
        });
    } else {
        // File doesn't exist - let the client know
        log_info("HLS file not found: %s (waiting for FFmpeg to create it)", hls_file_path);
        
        // Return a 404 with a message that indicates the file is being generated
        mg_http_reply(c, 404, "", "{\"error\": \"HLS file not found or still being generated by FFmpeg\"}\n");
    }
}

void mg_handle_hls_segment(struct mg_connection *c, struct mg_http_message *hm) {
    log_info("HLS API: Handling segment request directly");
    
    // Extract stream name from URI
    // URI format: /api/streaming/{stream_name}/hls/segment_{segment_id}.ts
    char uri[MAX_PATH_LENGTH];
    size_t uri_len = hm->uri.len < sizeof(uri) - 1 ? hm->uri.len : sizeof(uri) - 1;
    memcpy(uri, hm->uri.buf, uri_len);
    uri[uri_len] = '\0';
    
    // Parse the URI to extract stream name
    char stream_name[MAX_STREAM_NAME] = {0};
    if (sscanf(uri, "/api/streaming/%[^/]/hls/", stream_name) != 1) {
        log_error("Failed to extract stream name from URI: %s", uri);
        mg_http_reply(c, 400, "", "{\"error\": \"Invalid URI format\"}\n");
        return;
    }
    
    // Extract the segment filename (everything after the last /)
    const char *segment_filename = strrchr(uri, '/');
    if (!segment_filename) {
        log_error("Failed to extract segment filename from URI: %s", uri);
        mg_http_reply(c, 400, "", "{\"error\": \"Invalid URI format\"}\n");
        return;
    }
    segment_filename++; // Skip the '/'
    
    // Get the config to find the storage path
    config_t *global_config = get_streaming_config();
    
    // Construct the full path to the HLS file
    char hls_file_path[MAX_PATH_LENGTH * 2]; // Double the buffer size to avoid truncation
    
    // Use storage_path_hls if specified, otherwise fall back to storage_path
    if (global_config->storage_path_hls[0] != '\0') {
        snprintf(hls_file_path, sizeof(hls_file_path), "%s/hls/%s/%s", 
                global_config->storage_path_hls, stream_name, segment_filename);
        log_info("Using HLS-specific storage path: %s", global_config->storage_path_hls);
    } else {
        snprintf(hls_file_path, sizeof(hls_file_path), "%s/hls/%s/%s", 
                global_config->storage_path, stream_name, segment_filename);
        log_info("Using default storage path for HLS: %s", global_config->storage_path);
    }
    
    log_info("Serving HLS file directly: %s", hls_file_path);
    
    // Check if file exists
    struct stat st;
    if (stat(hls_file_path, &st) == 0 && S_ISREG(st.st_mode)) {
        // Determine content type based on file extension
        const char *content_type = "application/octet-stream"; // Default
        if (strstr(segment_filename, ".m3u8")) {
            content_type = "application/vnd.apple.mpegurl";
        } else if (strstr(segment_filename, ".ts")) {
            content_type = "video/mp2t";
        } else if (strstr(segment_filename, ".m4s")) {
            content_type = "video/iso.segment";
        } else if (strstr(segment_filename, "init.mp4")) {
            content_type = "video/mp4";
        }
        
        // Serve the file with appropriate headers
        // Use a more efficient approach for HLS files to reduce overhead
        // Determine content type based on file extension
        const char *content_type_header = "Content-Type: application/octet-stream\r\n";
        if (strstr(segment_filename, ".m3u8")) {
            content_type_header = "Content-Type: application/vnd.apple.mpegurl\r\n";
        } else if (strstr(segment_filename, ".ts")) {
            content_type_header = "Content-Type: video/mp2t\r\n";
        } else if (strstr(segment_filename, ".m4s")) {
            content_type_header = "Content-Type: video/iso.segment\r\n";
        } else if (strstr(segment_filename, "init.mp4")) {
            content_type_header = "Content-Type: video/mp4\r\n";
        }
        
        // Use more mobile-friendly cache headers with longer cache times
        char headers[512];
        
        // Different cache settings for different file types
        const char* cache_control;
        if (strstr(segment_filename, ".m3u8")) {
            // For playlist files, use a shorter cache time to ensure updates are seen
            cache_control = "Cache-Control: max-age=2\r\n";
        } else if (strstr(segment_filename, ".ts") || strstr(segment_filename, ".m4s")) {
            // For media segments, use a longer cache time to improve mobile performance
            cache_control = "Cache-Control: max-age=60\r\n";
        } else if (strstr(segment_filename, "init.mp4")) {
            // For initialization segments, use a longer cache time
            cache_control = "Cache-Control: max-age=3600\r\n";
        } else {
            // Default cache time
            cache_control = "Cache-Control: max-age=5\r\n";
        }
        
        snprintf(headers, sizeof(headers),
            "%s"
            "%s"  // Dynamic cache control based on file type
            "Connection: close\r\n"
            "Access-Control-Allow-Origin: *\r\n"
            "Access-Control-Allow-Methods: GET, OPTIONS\r\n"
            "Access-Control-Allow-Headers: Origin, Content-Type, Accept, Authorization\r\n",
            content_type_header, cache_control);
        
        mg_http_serve_file(c, hm, hls_file_path, &(struct mg_http_serve_opts){
            .mime_types = "",
            .extra_headers = headers
        });
    } else {
        // File doesn't exist - let the client know
        log_info("HLS file not found: %s (waiting for FFmpeg to create it)", hls_file_path);
        
        // Return a 404 with a message that indicates the file is being generated
        mg_http_reply(c, 404, "", "{\"error\": \"HLS file not found or still being generated by FFmpeg\"}\n");
    }
}
